<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>希望是最淺顯易懂的 RxJS 教學 - Huli</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content>





    <meta name="description" content="前言 關注 RxJS 已經好一段時間了，最早知道這個東西是因為 redux-observable，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連redux-saga都還沒搞懂，沒想到就又有新的東西出來了。 半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學">
<meta name="keywords" content="Front-end">
<meta property="og:type" content="article">
<meta property="og:title" content="希望是最淺顯易懂的 RxJS 教學">
<meta property="og:url" content="https://blog.huli.tw/2017/12/08/introduction-to-rxjs-observable/index.html">
<meta property="og:site_name" content="Huli">
<meta property="og:description" content="前言 關注 RxJS 已經好一段時間了，最早知道這個東西是因為 redux-observable，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連redux-saga都還沒搞懂，沒想到就又有新的東西出來了。 半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學">
<meta property="og:locale" content="zh-tw">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350819-7a09a500-f6eb-11e8-9f05-6d1303b93f60.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350828-85f56700-f6eb-11e8-984e-78140c0a8228.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350837-91e12900-f6eb-11e8-8b59-dccc306b24e6.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350841-973e7380-f6eb-11e8-8eb0-443adb7114c6.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350844-9ad1fa80-f6eb-11e8-9e14-861fb107e774.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350845-9e658180-f6eb-11e8-871f-92b229fefdd5.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350864-b806c900-f6eb-11e8-8718-dce100ca1604.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350866-bccb7d00-f6eb-11e8-8aff-eaca7ace9137.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350868-c0f79a80-f6eb-11e8-9716-a0c4d114c61f.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350873-c3f28b00-f6eb-11e8-8376-c87a1d261680.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350879-c8b73f00-f6eb-11e8-852d-14e96c9d9fed.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350882-ce148980-f6eb-11e8-8722-5a9ce5e2a939.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350900-e5537700-f6eb-11e8-9a25-f53bc4a892ee.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350905-eb495800-f6eb-11e8-9ed8-3f0a1ce31d73.gif">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350911-f2706600-f6eb-11e8-990a-d7bb0cbf48f4.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350913-f603ed00-f6eb-11e8-86a7-62fdc83c9345.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49350925-fe5c2800-f6eb-11e8-9ce6-a4d15c8130a6.png">
<meta property="og:updated_time" content="2019-09-25T11:30:16.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="希望是最淺顯易懂的 RxJS 教學">
<meta name="twitter:description" content="前言 關注 RxJS 已經好一段時間了，最早知道這個東西是因為 redux-observable，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連redux-saga都還沒搞懂，沒想到就又有新的東西出來了。 半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/2755720/49350819-7a09a500-f6eb-11e8-9f05-6d1303b93f60.png">





<link rel="icon" href="/img/lidemy_logo.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-49773306-3"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-49773306-3');
</script>


    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    Huli
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">文章列表</a>
            
            <a class="navbar-item " href="/categories">分類</a>
            
            <a class="navbar-item " href="/recommend">推薦閱讀</a>
            
            <a class="navbar-item " href="/about">關於我</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜尋" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" target="_blank" title="Medium" href="https://medium.com/@hulitw">
                
                <i class="fab fa-medium"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="Twitter" href="https://twitter.com/aszx87410">
                
                <i class="fab fa-twitter"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="Facebook" href="https://www.facebook.com/profile.php?id=100000221410594">
                
                <i class="fab fa-facebook"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            希望是最淺顯易懂的 RxJS 教學
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2017-12-08T21:07:00.000Z" itemprop="datePublished">2017年12月8日(2 年前)</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Front-end/">Front-end</a>
        </span>
        
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1><span id="前言">前言</span></h1>
<p>關注 RxJS 已經好一段時間了，最早知道這個東西是因為 <a href="https://redux-observable.js.org/" target="_blank" rel="noopener">redux-observable</a>，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連<code>redux-saga</code>都還沒搞懂，沒想到就又有新的東西出來了。</p>
<p>半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學者無所適從。</p>
<p>這次有機會在公司的新專案裡面嘗試導入<code>redux-observable</code>，身為提倡要導入的人，勢必要對這東西有一定的瞭解。秉持著這個想法，上週認真花了點時間再次把相關資源都研究了一下，漸漸整理出一套「我覺得應該可以把 RxJS 講得更好懂」的方法，在這邊跟大家分享一下。</p>
<p>在開始之前，要先大力稱讚去年 iT 邦幫忙鐵人賽的 Web 組冠軍：<a href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199" target="_blank" rel="noopener">30 天精通 RxJS</a>，這系列文章寫得很完整，感受得出來作者下了很多功夫在這上面。看完這篇之後如果對更多應用有興趣的，可以去把這系列的文章讀完。</p>
<p>好，那就讓我們開始吧！</p>
<a id="more"></a>
<h1><span id="請你先忘掉-rxjs">請你先忘掉 RxJS</span></h1>
<p>沒錯，你沒看錯。</p>
<p>要學會 RxJS 的第一件事情就是：忘記它。</p>
<p>忘記有這個東西，完全忘記，先讓我講幾個其他東西，等我們需要講到 RxJS 的時候我會再提醒你的。</p>
<p>在我們談到主角之前，先來做一些有趣的事情吧！</p>
<h1><span id="程式基礎能力測試">程式基礎能力測試</span></h1>
<p>先讓我們做一個簡單的練習題暖身，題目是這樣的：</p>
<blockquote>
<p>有一個陣列，裡面有三種類型的資料：數字、a~z組成的字串、數字組成的字串，請你把每個數字以及數字組成的字串乘以二之後加總<br>
範例輸入：[1, 5, 9, 3, ‘hi’, ‘tb’, 456, ‘11’, ‘yoyoyo’]</p>
</blockquote>
<p>你看完之後應該會說：「這有什麼難的？」，並且在一分鐘以內就寫出下面的程式碼：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> source = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'tb'</span>, <span class="hljs-number">456</span>, <span class="hljs-string">'11'</span>, <span class="hljs-string">'yoyoyo'</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;</span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; source.length; i++) &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> num = <span class="hljs-built_in">parseInt</span>(source[i], <span class="hljs-number">10</span>);</span><br><span class="line">  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(num)) &#123;</span><br><span class="line">    total += num * <span class="hljs-number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相信大家一定都是很直覺的就寫出上面的程式碼，但如果你是個 functional programming 的愛好者，你可能會改用另外一種思路來解決問題：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> source = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'tb'</span>, <span class="hljs-number">456</span>, <span class="hljs-string">'11'</span>, <span class="hljs-string">'yoyoyo'</span>];</span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">let</span> total = source</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(x, <span class="hljs-number">10</span>))</span><br><span class="line">  .filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !<span class="hljs-built_in">isNaN</span>(x))</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">2</span>)</span><br><span class="line">  .reduce(<span class="hljs-function">(<span class="hljs-params">total, value</span>) =&gt;</span> total + value )</span><br></pre></td></tr></table></figure></p>
<p>一開始的例子叫做<code>Imperative（命令式）</code>，用陣列搭配一堆函式的例子叫做<code>Declarative（聲明式）</code>。如果你去查了一下定義，應該會看到這兩個的解釋：</p>
<blockquote>
<p>Imperative 是命令機器去做事情（how），這樣不管你想要的是什麼（what），都會按照你的命令實現；Declarative 是告訴機器你想要的是什麼（what），讓機器想出如何去做（how）</p>
</blockquote>
<p>好，你有看懂上面這些在說什麼嗎？</p>
<p>我是沒有啦。</p>
<p>所以讓我們再看一個例子，其實 Declarative 你已經常常在用了，只是你不知道而已，那就是 SQL：</p>
<p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> dogs <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> owners <span class="hljs-keyword">WHERE</span> dogs.owner_id = owners.id</span><br></pre></td></tr></table></figure></p>
<p>這句話就是：我要所有狗的資料加上主人的資料。</p>
<p>我只有說「我要」而已，那要怎麼拿到這些資料？我不知道，我也不用知道，都讓 SQL 底層決定怎麼去操作就好。</p>
<p>如果我要自己做出這些資料，在 JavaScript 裡面我必須這樣寫（程式碼取自<a href="http://www.vaikan.com/imperative-vs-declarative/" target="_blank" rel="noopener">声明式编程和命令式编程的比较</a>）：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//dogs = [&#123;name: 'Fido', owner_id: 1&#125;, &#123;...&#125;, ... ]</span></span><br><span class="line"><span class="hljs-comment">//owners = [&#123;id: 1, name: 'Bob'&#125;, &#123;...&#125;, ...]</span></span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">var</span> dogsWithOwners = []</span><br><span class="line"><span class="hljs-keyword">var</span> dog, owner</span><br><span class="line">  </span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> di=<span class="hljs-number">0</span>; di &lt; dogs.length; di++) &#123;</span><br><span class="line">  dog = dogs[di]</span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> oi=<span class="hljs-number">0</span>; oi &lt; owners.length; oi++) &#123;</span><br><span class="line">    owner = owners[oi]</span><br><span class="line">    <span class="hljs-keyword">if</span> (owner &amp;&amp; dog.owner_id == owner.id) &#123;</span><br><span class="line">      dogsWithOwners.push(&#123;</span><br><span class="line">        dog: dog,</span><br><span class="line">        owner: owner</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>應該可以大致體驗出兩者的差別吧？後者你必須自己一步步去決定該怎麼做，而前者只是僅僅跟你說：「我想要怎樣的資料」而已。</p>
<p>接著我們再把目光放回到把數字乘以二相加的那個練習。對我來說，最大的不同點是後面那個用陣列搭配函式的例子，他的核心概念是：</p>
<blockquote>
<p>把原始資料經過一連串的轉換，變成你想要的資訊</p>
</blockquote>
<p>這點超級重要，因為在一開始的例子中，我們是自己一步步去 parse，去檢查去相加，得出數字的總和。而後面的那個例子，他是把原始的資料（陣列），經過一系列的轉換（map, filter, reduce），最後變成了我們想要的答案。</p>
<p>畫成圖的話，應該會長這樣（請原諒我偷懶把乘二的部分拿掉了，但意思不影響）：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350819-7a09a500-f6eb-11e8-9f05-6d1303b93f60.png" alt="map"></p>
<p>把原始資料經過一連串的轉換，最後變成你想要的答案，這點就是後者最大的不同。只要你有了這個基礎知識之後，再來看 RxJS 就不會覺得太奇怪了。</p>
<h1><span id="reactive-programming">Reactive Programming</span></h1>
<p>談到 RxJS 的時候，都會談到 Reactive 這個詞，那什麼是 Reactive 呢？可以從英文上的字義來看，這個單字的意思是：「反應、反應性的」，意思就是你要對一些事情做出反應。</p>
<p>所以 Reactive 其實就是在講說：「某些事情發生時，我能夠做出反應」。</p>
<p>讓我們來舉一個大家非常熟知的例子：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'click!'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我們加了一個 event listener 在 window 上面，所以我們可以監聽到這個事件，每當使用者點擊的時候就列印出 log。換句話說，這樣就是：「當 window 被點擊時，我可以做出反應」。</p>
<h1><span id="正式進入-rxjs">正式進入 RxJS</span></h1>
<p>如果你去看 <a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> 的網頁，你會發現他有明確的定義 ReactiveX：</p>
<blockquote>
<p>ReactiveX is a combination of the best ideas from<br>
the Observer pattern, the Iterator pattern, and functional programming</p>
</blockquote>
<p>第一個 Observer pattern 就像是 event listener 那樣，在某些事情發生時，我們可以對其作出反應；第二個 Iterator pattern 我們跳過不講，我認為暫時不影響理解；第三個就像是一開始的例子，我們可以把一個陣列經過多次轉換，轉換成我們想要的資料。</p>
<p>在 Reactive Programming 裡面，最重要的兩個東西叫做 Observable 跟 Observer，其實一開始讓我最困惑的點是因為我英文不好，不知道這兩個到底誰是觀察的誰是被觀察的。</p>
<p>先把它們翻成中文，Observable 就是「可被觀察的」，Observer 就是所謂的「觀察者」。</p>
<p>這是什麼意思呢？就如同上面的例子一樣，當（可被觀察的東西）有事情發生，（Observer，觀察者）就可以做出反應。</p>
<p>直接舉一個例子你就知道了：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'click~'</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面這段程式碼跟我幫 window 加上 event listener 在做的事情完全一樣，只是這邊我們使用了 RxJS 提供的方法叫做<code>fromEvent</code>，來把一個 event 轉成 Observable（可被觀察的），並且在最後加上 subscribe。</p>
<p>這樣寫就代表說我訂閱了這個 Observable，只要有任何事情發生，就會執行我傳進去的 function。</p>
<p>所以到底什麼是 Observable？</p>
<p>Observable 就是一個可被觀察的對象，這個對象可以是任何東西（例如說上述例子就是 window 的 click 事件），當有新資料的時候（例如說新的點擊事件），你就可以接收到這個新資料的資訊並且做出反應。</p>
<p>比起 Observable 這個冷冰冰的說法，我更喜歡的一個說法是 stream，資料流。其實每一個 Observable 就是一個資料流，但什麼是資料流？你就想像成是會一直增加元素的陣列就好了，有新的事件發生就 push 進去。如果你喜歡更專業一點的說法，可以叫它：「時間序列上的一連串資料事件」（取自 <a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/" target="_blank" rel="noopener">Reactive Programming 簡介與教學(以 RxJS 為例)</a>）</p>
<p>或是我再舉一個例子，stream 的另外一個解釋就是所謂的「串流影片」，意思就是隨著你不斷播放，就會不斷下載新的片段進來。此時你腦中應該要有個畫面，就是像水流那樣，不斷有新的東西流進來，這個東西就叫做 stream。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350828-85f56700-f6eb-11e8-984e-78140c0a8228.gif" alt="giphy"></p>
<p>（圖片取自 <a href="https://media.giphy.com/media/xIkKIodaqNBdK/giphy.gif" target="_blank" rel="noopener">giphy</a>）</p>
<h1><span id="我理解資料流了然後呢">我理解資料流了，然後呢？</span></h1>
<p>上面有說過，我們可以把任何一個東西轉成 Observable，讓它變成資料流，可是這不就跟 addEventListener 一樣嗎？有什麼特別的？</p>
<p>有，還真的比較特別。</p>
<p>希望你沒有忘記我們剛開始做的那個小練習，就是把一個陣列透過一系列轉換，變成我們要的資料的那個練習。我剛剛有說，你可以把 Observable 想成是「會一直增加元素的陣列」，這代表什麼呢？</p>
<p>代表我們也可以把 Observable 做一系列的轉換！我們也可以用那些用在陣列上的 function！</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'click: '</span>, value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350837-91e12900-f6eb-11e8-8b59-dccc306b24e6.gif" alt="click"></p>
<p>我們把 click 事件經過 map 轉換為點擊到的 element，所以當我們最後在 subscribe 的時候，收到的 value 就會是我們點擊的東西。</p>
<p>接著來看一個稍微進階一點的例子：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="hljs-built_in">window</span>, <span class="hljs-string">'click'</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-number">1</span>)</span><br><span class="line">  .scan(<span class="hljs-function">(<span class="hljs-params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#counter'</span>).innerText = value;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350841-973e7380-f6eb-11e8-8eb0-443adb7114c6.gif" alt="counter"></p>
<p>首先我們先把每一個 click 事件都透過<code>map</code>轉換成 1（或者你也可以寫成<code>.mapTo(1)</code>），所以每按一次就送出一個數字 1。<code>scan</code>的話其實就是我們一開始對陣列用的<code>reduce</code>，你可以想成是換個名字而已。透過<code>scan</code>加總以後傳給 subscriber，顯示在頁面上面。</p>
<p>就這樣簡單幾行，就完成了一個計算點擊次數的 counter。</p>
<p>可以用一個簡單的 gif 圖來表示上面的範例：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350844-9ad1fa80-f6eb-11e8-9e14-861fb107e774.gif" alt="click_stream"></p>
<p>可是 Observable 不只這樣而已，接下來我們要進入到它最厲害的地方了。</p>
<h1><span id="威力無窮的組合技">威力無窮的組合技</span></h1>
<p>如果把兩個陣列合併，會變成什麼？例如說<code>[1, 2, 3]</code>跟<code>[4, 5, 6]</code>？</p>
<p>這要看你指的「合併」是什麼，如果是指串接，那就是<code>[1, 2, 3, 4, 5, 6]</code>，如果是指相加，那就是<code>[5, 7, 9]</code>。</p>
<p>那如果把兩個 Observable 合併會變成什麼？</p>
<p>Observable 跟陣列的差別就在於多了一個維度：時間。</p>
<p>Observable 是「時間序列上的一連串資料事件」，就像我前面講的一樣，可以看成是一個一直會有新資料進來的陣列。</p>
<p>我們先來看看一張很棒的圖，很清楚地解釋了兩個 Observable 合併會變成什麼：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350845-9e658180-f6eb-11e8-871f-92b229fefdd5.png" alt="merge 1"></p>
<p>（取自：<a href="http://rxmarbles.com/#merge%EF%BC%89" target="_blank" rel="noopener">http://rxmarbles.com/#merge）</a></p>
<p>上面是一個 Observable，每一個圓點代表一個資料，下面也是一樣，把這兩個合併之後就變成最下面那一條，看圖解應該還滿好懂的，就像是把兩個時間軸合併一樣。</p>
<p>讓我們來看一個可以展現合併強大之處的範例，我們有 +1 跟 -1 兩個按鈕以及文字顯示現在的數字是多少：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350864-b806c900-f6eb-11e8-8718-dce100ca1604.gif" alt="counter_adv"></p>
<p>該怎麼達成這個功能呢？基本的想法就是我們先把每個 +1 的 click 事件都通過<code>mapTo</code>變成數字 1，取叫 Observable_plus1 好了。再做出一個 Observable_minus1 是把每個 -1 的 click 事件都通過<code>mapTo</code>變成數字 -1。</p>
<p>把這兩個 Observable 合併之後，再利用剛剛提到的<code>scan</code>加總，就是目前應該要顯示的數字了！</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input[name=plus]'</span>), <span class="hljs-string">'click'</span>)</span><br><span class="line">  .mapTo(<span class="hljs-number">1</span>)</span><br><span class="line">  .merge(</span><br><span class="line">    Rx.Observable.fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input[name=minus]'</span>), <span class="hljs-string">'click'</span>)</span><br><span class="line">      .mapTo(<span class="hljs-number">-1</span>)</span><br><span class="line">  )</span><br><span class="line">  .scan(<span class="hljs-function">(<span class="hljs-params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#counter'</span>).innerText = value;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果你還是不懂的話，可以參考下面的精美範例，示範這兩個 Observable 是怎麼合在一起的（<code>O</code>代表點擊事件，<code>+1</code>跟<code>-1</code>則是<code>mapTo</code>之後的結果）：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350866-bccb7d00-f6eb-11e8-8aff-eaca7ace9137.gif" alt="plus"></p>
<p>讓我們來比較一下如果不用 Observable 的話，程式碼會長怎樣：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> total = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input[name=plus]'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  total++;</span><br><span class="line">  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#counter'</span>).innerText = total;</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input[name=minus]'</span>).addEventListener(<span class="hljs-string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  total--;</span><br><span class="line">  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'#counter'</span>).innerText = total;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>有沒有發覺兩者真的差別很大？就如同我之前所說的，是兩種完全不同的思考模式，所以 Reactive Programming 困難的地方不是在於理解，也不是在於語法（這兩者相信你目前都有些概念了），而是在於換一種全新的思考模式。</p>
<p>以上面的寫法來說，就是告訴電腦：「按下加的時候就把一個變數 +1，然後更改文字；按下減的時候就 -1 並且也更改文字」，就可以達成計數器的功能。</p>
<p>以 Reactive 的寫法，就是把按下加當成一個資料流，把按下減也當成一個資料流，再透過各種 function 把這兩個流轉換並且合併起來，讓最後的那個流就是我們想要的結果（計數器）。</p>
<p>你現在應該能體會到我一開始說的了：「把原始資料經過一連串的轉換，最後變成你想要的答案」，這點就是 Reactive Programming 最大的特色。</p>
<h1><span id="組合技中的組合技">組合技中的組合技</span></h1>
<p>我們來看一個更複雜一點的範例，是在 canvas 上面實現非常簡單的繪圖功能，就是滑鼠按下去之後可以畫畫，放開來就停止。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350868-c0f79a80-f6eb-11e8-9716-a0c4d114c61f.gif" alt="draw"></p>
<p>要實現這個功能很間單，canvas 提供<code>lineTo(x, y)</code>這個方法，只要在滑鼠移動時不斷呼叫這個方法，就可以不斷畫出圖形來。但有一點要注意的是當你在按下滑鼠時，應該先呼叫<code>moveTo(x, y)</code>把繪圖的點移到指定位置，為什麼呢？</p>
<p>假設我們第一次畫圖是在左上角，第二次按下滑鼠的位置是在右下角，如果沒有先用<code>moveTo</code>移動而是直接用<code>lineTo</code>的話，就會多一條線從左上角延伸到右下角。<code>moveTo</code>跟<code>lineTo</code>的差別就是前者只是移動，後者會跟上次的點連接在一起畫成一條線。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350873-c3f28b00-f6eb-11e8-8376-c87a1d261680.gif" alt="draw2"></p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'canvas'</span>);</span><br><span class="line"><span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);</span><br><span class="line">ctx.beginPath(); <span class="hljs-comment">// 開始畫畫</span></span><br><span class="line">  </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">draw</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">  ctx.lineTo(e.clientX,e.clientY); <span class="hljs-comment">// 移到滑鼠在的位置</span></span><br><span class="line">  ctx.stroke(); <span class="hljs-comment">// 畫畫</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="hljs-comment">// 按下去滑鼠才開始偵測 mousemove 事件</span></span><br><span class="line">canvas.addEventListener(<span class="hljs-string">'mousedown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">  ctx.moveTo(e.clientX, e.clientY); <span class="hljs-comment">// 每次按下的時候必須要先把繪圖的點移到那邊，否則會受上次畫的位置影響</span></span><br><span class="line">  canvas.addEventListener(<span class="hljs-string">'mousemove'</span>, draw);</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="hljs-comment">// 放開滑鼠就停止偵測 </span></span><br><span class="line">canvas.addEventListener(<span class="hljs-string">'mouseup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="line">  canvas.removeEventListener(<span class="hljs-string">'mousemove'</span>, draw);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>那如果在 RxJS 裡面，該怎麼實作這個功能呢？</p>
<p>首先憑直覺，應該就是先加上<code>mousedown</code>的事件對吧！至少有個開頭。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousedown'</span>)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'mousedown'</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>可是滑鼠按下去之後應該要變成什麼？這個時候應該要開始監聽<code>mousemove</code>對吧，所以我們這樣寫，用<code>mapTo</code>把每一個<code>mousedown</code>的事件都轉換成<code>mousemove</code>的 Observable：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousedown'</span>)</span><br><span class="line">  .mapTo(</span><br><span class="line">    Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousemove'</span>)</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value: '</span>, value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>接著你看一下 console，你會發現每當我點擊的時候，console 就會印出<code>FromEventObservable {_isScalar: false, sourceObj: canvas#canvas, eventName: &quot;mousemove&quot;, selector: undefined, options: undefined}</code></p>
<p>仔細想一下你會發現也滿合理的，因為我用<code>mapTo</code>把每一個滑鼠按下去的事件轉成一個 mousemove 的 Observable，所以用 subscribe 訂閱之後拿到的東西就會是這個 Observable。如果畫成圖，大概長得像這樣：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350879-c8b73f00-f6eb-11e8-852d-14e96c9d9fed.png" alt="flat"></p>
<p>好了，那怎麼辦呢？我想要的其實不是 Observable 本身，而是屬於這個 Observable 裡面的那些東西啊！現在這個情形就是 Observable 裡面又有 Observable，有兩層，可是我想要讓它變成一層就好，該怎麼辦呢？</p>
<p>在此提供一個讓 Observable 變簡單的訣竅：</p>
<blockquote>
<p>只要有問題，先想想 Array 就對了！</p>
</blockquote>
<p>我前面有提過，可以把 Observable 看成是加上時間維度的進階版陣列，因此只要是陣列有的方法，Observable 通常也都會有。</p>
<p>舉例來說，一個陣列可能長這樣：<code>[1, [2, 2.5], 3, [4, 5]]</code>一共有兩層，第二層也是一個陣列。</p>
<p>如果想讓它變一層的話怎麼辦呢？壓平！</p>
<p>有用過 lodash 或是其他類似的 library 的話，你應該有聽過<code>_.flatten</code>這個方法，可以把這種陣列壓平，變成：<code>[1, 2, 2.5, 3, 4, 5]</code>。</p>
<p>用 flat 這個關鍵字去搜尋 Rx 文件的話，你會找到一個方法叫做 <a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="noopener">FlatMap</a>，簡單來說就是先<code>map</code>之後再自動幫你壓平。</p>
<p>所以，我們可以把程式碼改成這樣：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousedown'</span>)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousemove'</span>))            </span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>當你點擊之後，會發現隨著滑鼠移動，console 會印出一大堆 log，就代表我們成功了。</p>
<p>畫成示意圖的話會變成這樣（為了方便說明，我把<code>flatMap</code>在圖片上變成<code>map</code>跟<code>flatten</code>兩個步驟）：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350882-ce148980-f6eb-11e8-8722-5a9ce5e2a939.png" alt="flat2"></p>
<p>接下來呢？接下來我們要讓它可以在滑鼠鬆開的時候停止，該怎麼做呢？RxJS 有一個方法叫做<code>takeUntil</code>，意思就是拿到…發生為止，傳進去的參數必須是一個 Observable。</p>
<p>舉例來說，如果寫<code>.takeUntil(window, 'click')</code>，就表示如果任何<code>window</code>的點擊事件發生，這個 Observable 就會立刻終止，不會再送出任何資料。</p>
<p>應用在繪畫的例子上，我們只要把<code>takeUntil</code>後面傳的參數換成滑鼠鬆開就好！順便把<code>subscribe</code>跟畫畫的 function 也一起完成吧！</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousedown'</span>)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousemove'</span>))</span><br><span class="line">  .takeUntil(Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mouseup'</span>))         </span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    draw(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>改完之後馬上來實驗一下！滑鼠按下去之後順利開始畫圖，鬆開以後畫圖停止，完美！</p>
<p>咦，可是怎麼按下第二次就沒反應了？我們做出了一個「只能夠成功畫一次圖」的 Observable。</p>
<p>為什麼呢？我們可以先來看一下<code>takeUntil</code>的示意圖（取自：<a href="http://rxmarbles.com/#takeUntil%EF%BC%89" target="_blank" rel="noopener">http://rxmarbles.com/#takeUntil）</a></p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350900-e5537700-f6eb-11e8-9a25-f53bc4a892ee.png" alt="takeuntil"></p>
<p>以我們的情形來說，就是只要<code>mouseup</code>事件發生，「整個 Observable」就會停止，所以只有第一次能夠畫圖成功。但我們想要的其實不是這樣，我們想要的是只有<code>mousemove</code>停止而已，而不是整個都停止。</p>
<p>所以，我們應該把<code>takeUntil</code>放在<code>mousemove</code>的後面，也就是：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousedown'</span>)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousemove'</span>)</span><br><span class="line">      .takeUntil(Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mouseup'</span>))  </span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    draw(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>這樣子裡面的那個<code>mousemove</code>的 Observable 就會在滑鼠鬆開時停止發送事件，而我們最外層的這個 Observable 監聽的是滑鼠按下，會一直監聽下去。</p>
<p>到這邊其實就差不多了，但還有一個小 bug 要修，就是我們沒有在<code>mousedown</code>的時候利用<code>moveTo</code>移動，造成我們一開始說的那個會把上次畫的跟這次畫的連在一起的問題。</p>
<p>那怎麼辦呢？我已經把<code>mousedown</code>事件轉成其他資料流了，我要怎麼在<code>mousedown</code>的時候做事？</p>
<p>有一個方法叫做<code>do</code>，就是為了這種情形而設立的，使用時機是：「你想做一點事，卻又不想影響資料流」，有點像是能夠針對不同階段 subscribe 的感覺，<code>mousedown</code>的時候 subscribe 一次，最後要畫圖的時候又 subscribe 一次。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousedown'</span>)</span><br><span class="line">  .do(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.moveTo(e.clientX, e.clientY)</span><br><span class="line">  &#125;)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mousemove'</span>)</span><br><span class="line">      .takeUntil(Rx.Observable.fromEvent(canvas, <span class="hljs-string">'mouseup'</span>))  </span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;</span><br><span class="line">    draw(e);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>到這邊，我們就順利完成了畫圖的功能。</p>
<p>如果你想試試看你有沒有搞懂，可以實作看看拖拉移動物體的功能，原理跟這個很類似，都是偵測滑鼠的事件並且做出反應。</p>
<h1><span id="喝口水休息一下下半場要開始了">喝口水休息一下，下半場要開始了</span></h1>
<p>上半場的目標在於讓你理解什麼是 Rx，並且掌握幾個基本概念：</p>
<ol>
<li>一個資料流可以經過一系列轉換，變成另一個資料流</li>
<li>這些轉換基本上都跟陣列有的差不多，像是<code>map</code>、<code>filter</code>、<code>flatten</code>等等</li>
<li>你可以合併多個 Observable，也可以把二維的 Observable 壓平</li>
</ol>
<p>下半場專注的點則是在於實戰應用，並且圍繞著 RxJS 最適合的場景之一：API。</p>
<p>前面我們有提到說可以把 DOM 物件的 event 變成資料流，但除了這個以外，Promise 其實也可以變成資料流。概念其實也很簡單啦，就是 Promise 被 resovle 的時候就發送一個資料，被 reject 的時候就終止。</p>
<p>讓我們來看一個簡單的小範例，每按一次按鈕就會發送一個 request</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendRequest</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">'https://jsonplaceholder.typicode.com/posts/1'</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">Rx.Observable.fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input[name=send]'</span>), <span class="hljs-string">'click'</span>)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> Rx.Observable.fromPromise(sendRequest()))</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>這邊用<code>flatMap</code>的原因跟剛才的畫圖範例一樣，我們要在按下按鈕時，把原本的資料流轉換成新的資料流，如果只用<code>map</code>的話，會變成一個二維的 Observable，所以必須要用<code>flatten</code>把它壓平。</p>
<p>你可以試試看把<code>flatMap</code>改成<code>map</code>，你最後 subscribe 得到的值就會是一堆 Observable 而不是你想要的資料。</p>
<p>知道怎麼用 Rx 來處理 API 之後，就可以來做一個經典範例了：AutoComplete。</p>
<p>我在做這個範例的時候有極大部分參考<a href="https://ithelp.ithome.com.tw/articles/10188457" target="_blank" rel="noopener">30 天精通 RxJS(19): 實務範例 - 簡易 Auto Complete 實作</a>、<a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/" target="_blank" rel="noopener">Reactive Programming 簡介與教學(以 RxJS 為例)</a>以及<a href="http://www.alloyteam.com/2016/12/learn-rxjs/" target="_blank" rel="noopener">构建流式应用—RxJS详解</a>，再次感謝這三篇文章。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350905-eb495800-f6eb-11e8-9ed8-3f0a1ce31d73.gif" alt="auto"></p>
<p>為了要讓大家能夠體會 Reactive Programming 跟一般的有什麼不一樣，我們先用老方法做出這個 Auto Complete 的功能吧！</p>
<p>先來寫一下最底層的兩個函式，負責抓資料的以及 render 建議清單的，我們使用維基百科的 API 來當作範例：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchWikipedia</span> (<span class="hljs-params">term</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> $.ajax(&#123;</span><br><span class="line">        url: <span class="hljs-string">'http://en.wikipedia.org/w/api.php'</span>,</span><br><span class="line">        dataType: <span class="hljs-string">'jsonp'</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            action: <span class="hljs-string">'opensearch'</span>,</span><br><span class="line">            format: <span class="hljs-string">'json'</span>,</span><br><span class="line">            search: term</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).promise();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderList</span> (<span class="hljs-params">list</span>) </span>&#123;</span><br><span class="line">  $(<span class="hljs-string">'.auto-complete__list'</span>).empty();</span><br><span class="line">  $(<span class="hljs-string">'.auto-complete__list'</span>).append(list.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">'&lt;li&gt;'</span> + item + <span class="hljs-string">'&lt;/li&gt;'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>這邊要注意的一個點是維基百科回傳的資料會是一個陣列，格式如下：</p>
<p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[你輸入的關鍵字, 關鍵字清單, 每個關鍵字的介紹, 每個關鍵字的連結]</span><br><span class="line">  </span><br><span class="line">// 範例：</span><br><span class="line">[</span><br><span class="line">  &quot;dd&quot;,</span><br><span class="line">  [&quot;Dd&quot;, &quot;DDR3 SDRAM&quot;, &quot;DD tank&quot;],</span><br><span class="line">  [&quot;&quot;, &quot;Double data rate type three SDRAM (DDR3 SDRAM)&quot;, &quot;DD or Duplex Drive tanks&quot;],</span><br><span class="line">  [https://en.wikipedia.org/wiki/Dd&quot;, &quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;, &quot;...略&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>在我們的簡單示範中，只需要取 index 為 1 的那個關鍵字清單就好了。而<code>renderList</code>這個 function 則是傳進一個陣列，就會把陣列內容轉成<code>li</code>顯示出來。</p>
<p>有了這兩個最基礎的 function 之後，就可以很輕易地完成 Auto Complete 的功能：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>).addEventListener(<span class="hljs-string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  searchWikipedia(e.target.value).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    renderList(data[<span class="hljs-number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>程式碼應該很好懂，就是每次按下輸入東西的時候去 call api，把回傳的資料餵給<code>renderList</code>去渲染。</p>
<p>最基本的功能完成了，我們要來做一點優化，因為這樣子的實作其實是有一些問題的。</p>
<p>第一個問題，現在只要每打一個字就會送出一個 request，可是這樣做其實有點浪費，因為使用者可能快速的輸入了：<code>java</code>想要找相關的資料，他根本不在乎<code>j</code>、<code>ja</code>、<code>jav</code>這三個 request。</p>
<p>要怎麼做呢？我們就改寫成如果 250ms 裡面沒有再輸入新的東西才發送 request 就好，就可以避免這種多餘的浪費。</p>
<p>這種技巧稱作<code>debounce</code>，實作上也很簡單，就是利用<code>setTimeout</code>跟<code>clearTimeout</code>。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>).addEventListener(<span class="hljs-string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (timer) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    searchWikipedia(e.target.value).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      renderList(data[<span class="hljs-number">1</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="hljs-number">250</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>在 input 事件被觸發之後，我們不直接做事情，而是設置了一個 250ms 過後會觸發的 timer，如果 250ms 內 input 再次被觸發的話，我們就把上次的 timer 清掉，再重新設置一個。</p>
<p>如此一來，就可以保證使用者如果在短時間內不斷輸入文字的話，不會送出相對應的 request，而是會等到最後一個字打完之後的 250 ms 才發出 request。</p>
<p>解決了第一個問題之後，還有一個潛在的問題需要解決。</p>
<p>假設我現在輸入<code>a</code>，接著刪除然後再輸入<code>b</code>，所以第一個 request 會是<code>a</code>的結果，第二個 request 會是<code>b</code>的結果。我們假設 server 出了一點問題，所以第二個的 response 反而比第一個還先到達（可能<code>b</code>的搜尋結果有 cache 但是<code>a</code>沒有），這時候就會先顯示<code>b</code>的內容，等到第一個 response 回來時，再顯示<code>a</code>的內容。</p>
<p>可是這樣 UI 就有問題了，我明明輸入的是<code>b</code>，怎麼 auto complete 的推薦關鍵字是<code>a</code>開頭？</p>
<p>所以我們必須要做個檢查，檢查返回的資料跟我現在輸入的資料是不是一致，如果一致的話才 render：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;</span><br><span class="line"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>).addEventListener(<span class="hljs-string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (timer) &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    searchWikipedia(e.target.value).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] === <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>).value) &#123;</span><br><span class="line">        renderList(data[<span class="hljs-number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="hljs-number">250</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>到這裡應該就差不多了，該有的功能都有了。</p>
<p>接著，讓我們來挑戰用 RxJS 實作吧！</p>
<p>首先，先從簡單版的開始做，就是不包含 debounce 跟上面 API 順序問題的實作，監聽 input 事件轉換成 request，然後用<code>flatMap</code>壓平，其實就跟上面的流程差不多：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>), <span class="hljs-string">'input'</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Rx.Observable.from(searchWikipedia(value)).map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>這邊用了兩個<code>map</code>，一個是把<code>e</code>轉成<code>e.target.value</code>，一個是把傳回來的結果轉成<code>res[1]</code>，因為我們只需要關鍵字列表，其他的東西其實都不用。</p>
<p>那要如何實作<code>debounce</code>的功能呢？</p>
<p>RxJS 已經幫你實作好了，所以你只要加上<code>.debounceTime(250)</code>就好了，就是這麼簡單。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>), <span class="hljs-string">'input'</span>)</span><br><span class="line">  .debounceTime(<span class="hljs-number">250</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .flatMap(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Rx.Observable.from(searchWikipedia(value)).map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>還有最後一個問題要解決，那就是剛才提到的 request 的順序問題。</p>
<p>Observable 有一個不同的解法，我來解釋給大家聽聽。</p>
<p>其實除了<code>flatMap</code>以外，還有另外一種方式叫做<code>switchMap</code>，他們的差別在於要怎麼把 Observable 給壓平。前者我們之前介紹過了，就是會把每一個二維的 Observable 都壓平，並且「每一個都執行」。</p>
<p>而<code>switchMap</code>的差別在於，他永遠只會處理最後一個 Observable。拿我們的例子來說，假設第一個 request 還沒回來的時候，第二個 request 就發出去了，那我們的 Observable 就只會處理第二個 request，而不管第一個。</p>
<p>第一個還是會發送，還是會接收到資料，只是接收到資料以後不會再把這個資料 emit 到 Observable 上面，意思就是根本沒人理這個資料了。</p>
<p>可以看一下簡陋的圖解，<code>flatMap</code>每一個 promise resolve 之後的資料都會被發送到我們的 Observable 上面：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350911-f2706600-f6eb-11e8-990a-d7bb0cbf48f4.png" alt="flatmap"></p>
<p>而<code>switchMap</code>只會處理最後一個：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350913-f603ed00-f6eb-11e8-86a7-62fdc83c9345.png" alt="switchmap"></p>
<p>所以我們只要把<code>flatMap</code>改成<code>switchMap</code>，就可以永遠只關注最後一個發送的 request，不用去管 request 傳回來的順序，因為前面的 request 都跟這個 Observable 無關了。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>), <span class="hljs-string">'input'</span>)</span><br><span class="line">  .debounceTime(<span class="hljs-number">250</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .switchMap(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Rx.Observable.from(searchWikipedia(value)).map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>做到這邊，就跟剛剛實作的功能一模一樣了。</p>
<p>但其實還有地方可以改進，我們來做個小小的加強好了。現在的話當我輸入<code>abc</code>，會出現<code>abc</code>的相關關鍵字，接著我把<code>abc</code>全部刪掉，讓 input 變成空白，會發現 API 這時候回傳一個錯誤：<code>The &quot;search&quot; parameter must be set.</code>。</p>
<p>因此，我們可以在 input 是空的時候，不發送 request，只回傳一個空陣列，而回傳空陣列這件事情可以用<code>Rx.Observable.of([])</code>來完成，這樣會創造一個會發送空陣列的 Observable：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>), <span class="hljs-string">'input'</span>)</span><br><span class="line">  .debounceTime(<span class="hljs-number">250</span>)</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.value)</span><br><span class="line">  .switchMap(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> value.length &lt; <span class="hljs-number">1</span> ? Rx.Observable.of([]) : Rx.Observable.from(searchWikipedia(value)).map(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res[<span class="hljs-number">1</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    renderList(value);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>還有一個點擊關鍵字清單之後把文字設定成關鍵字的功能，在這邊就不示範給大家看了，但其實就是再創造一個 Observable 去監聽點擊事件，點到的時候就設定文字並且把關鍵字清單給清掉。</p>
<p>我直接附上參考程式碼：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable</span><br><span class="line">  .fromEvent(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete__list'</span>), <span class="hljs-string">'click'</span>)</span><br><span class="line">  .filter(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.matches(<span class="hljs-string">'li'</span>))</span><br><span class="line">  .map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.target.innerHTML)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.auto-complete input'</span>).value = value;</span><br><span class="line">    renderList([])</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>雖然我只介紹了最基本的操作，但 RxJS 的強大之處就在於除了這些，你甚至還有<code>retry</code>可以用，只要輕鬆加上這個，就能夠有自動重試的功能。</p>
<p>相關的應用場景還有很多，只要是跟 API 有關連的幾乎都可以用 RxJS 很優雅的解決。</p>
<h1><span id="react-redux-的非同步解決方案redux-observable">React + Redux 的非同步解決方案：redux-observable</span></h1>
<p>這是我們今天的最後一個主題了，也是我開場所提到的。</p>
<p>React + Redux 這一套非常常見的組合，一直都有一個問題存在，那就是沒有規範非同步行為（例如說 API）到底應該怎麼處理。而開源社群也有許多不同的解決方案，例如說 redux-thunk、redux-promise、redux-saga 等等。</p>
<p>我們前面講了這麼多東西，舉了這麼多範例，就是要證明給大家看 Reactive programming 很適合拿來解決複雜的非同步問題。因此，Netflix 就開源了這套<a href="https://redux-observable.js.org/" target="_blank" rel="noopener">redux-observable</a>，用 RxJS 來處理非同步行為。</p>
<p>在瞭解 RxJS 之後，可以很輕鬆的理解<code>redux-observable</code>的原理。</p>
<p>在 redux 的應用裡面，所有的 action 都會通過 middleware，你可以在這邊對 action 做任何處理。或者我們也可以把 action 看做是一個 Observable，例如說：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 範例而已</span></span><br><span class="line">Rx.Observable.from(actionStreams)</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(action.type, action.payload)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>有了這個以後，我們就可以做一些很有趣的事情，例如說偵測到某個 action 的時候，我們就發送 request，並且把 response 放進另外一個 action 裡面送出去。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.from(actionStreams)</span><br><span class="line">  .filter(<span class="hljs-function"><span class="hljs-params">action</span> =&gt;</span> action.type === <span class="hljs-string">'GET_USER_INFO'</span>)</span><br><span class="line">  .switchMap(</span><br><span class="line">    action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId))</span><br><span class="line">  )</span><br><span class="line">  .subscribe(<span class="hljs-function"><span class="hljs-params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: <span class="hljs-string">'SET_USER_INFO'</span>,</span><br><span class="line">      payload: userInfo</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面就是一個簡單的例子，但其實<code>redux-observable</code>已經幫我們處理掉很多東西了，所以我們只要記得一個概念：</p>
<blockquote>
<p>action in, action out</p>
</blockquote>
<p><code>redux-observable</code> 是一個 middleware，你可以在裡面加上很多<code>epic</code>，每一個<code>epic</code>就是一個 Observable，你可以監聽某一個指定的 action，做一些處理，再轉成另外一個 action。</p>
<p>直接看程式碼會比較好懂：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> Actions <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions/user'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> ActionTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'./actionTypes/user'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> getUserEpic = <span class="hljs-function"><span class="hljs-params">action$</span> =&gt;</span></span><br><span class="line">  action$.ofType(actionTypes.GET_USER)</span><br><span class="line">    .switchMap(</span><br><span class="line">      action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId))</span><br><span class="line">    ).map(<span class="hljs-function"><span class="hljs-params">userInfo</span> =&gt;</span> Actions.setUsers(userInfo))</span><br></pre></td></tr></table></figure></p>
<p>大概就是像這樣，我們監聽一個 action type（GET_USER），一接收到的時候就發送 request，並且把結果轉為<code>setUsers</code>這個 action，這就是所謂的 action in, action out。</p>
<p>這樣的好處是什麼？好處是明確制定了一個規範，當你的 component 需要資料的時候，就送出一個 get 的 action，這個 action 經過 middleware 的時候會觸發 epic，epic 發 request 給 server 拿資料，轉成另外一個 set 的 action，經過 reducer 設定資料以後更新到 component 的 props。</p>
<p>可以看這張流程圖：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49350925-fe5c2800-f6eb-11e8-9ce6-a4d15c8130a6.png" alt="observable"></p>
<p>總之呢，<code>epic</code>就是一個 Observable，你只要確保你最後回傳的東西是一個 action 就好，那個 action 就會被送到 reducer 去。</p>
<p>礙於篇幅的關係，今天對於<code>redux-observable</code>只是概念性的帶過去而已，沒有時間好好示範，之後再來找個時間好好寫一下<code>redux-observable</code>的實戰應用。</p>
<h1><span id="結論">結論</span></h1>
<p>從一開始的陣列講到 Observable，講到畫圖的範例再講到經典的 Auto Complete，最後還講了<code>redux-observable</code>，這一路的過程中，希望大家有體會到 Observable 在處理非同步行為的強大之處以及簡潔。</p>
<p>這篇的目的是希望能讓大家理解 Observable 大概在做什麼，以及介紹一些簡單的應用場景，希望能提供一篇簡單易懂的中文入門文章，讓更多人能體會到 Observable 的威力。</p>
<p>喜歡這篇的話可以幫忙分享出去，發現哪邊有寫錯也歡迎留言指正，感謝。</p>
<p>參考資料：</p>
<p><a href="https://ithelp.ithome.com.tw/articles/10186104" target="_blank" rel="noopener">30 天精通 RxJS (01)：認識 RxJS</a><br>
<a href="http://blog.techbridge.cc/2016/05/28/reactive-programming-intro-by-rxjs/" target="_blank" rel="noopener">Reactive Programming 簡介與教學(以 RxJS 為例)</a><br>
<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">The introduction to Reactive Programming you’ve been missing</a><br>
<a href="http://www.alloyteam.com/2016/12/learn-rxjs/" target="_blank" rel="noopener">构建流式应用—RxJS详解</a><br>
<a href="https://medium.com/kevin-salters-blog/epic-middleware-in-redux-e4385b6ff7c6" target="_blank" rel="noopener">Epic Middleware in Redux</a><br>
<a href="http://blog.danieleghidoli.it/2016/10/22/http-rxjs-observables-angular/" target="_blank" rel="noopener">Combining multiple Http streams with RxJS Observables in Angular2</a></p>
<p>影片：<br>
<a href="https://www.youtube.com/watch?v=AslncyG8whg" target="_blank" rel="noopener">Netflix JavaScript Talks - RxJS + Redux + React = Amazing!</a><br>
<a href="https://www.youtube.com/watch?v=2LCo926NFLI" target="_blank" rel="noopener">RxJS Quick Start with Practical Examples</a><br>
<a href="https://www.youtube.com/watch?v=ei7FsoXKPl0" target="_blank" rel="noopener">RxJS Observables Crash Course</a><br>
<a href="https://www.youtube.com/watch?v=COviCoUtwx4" target="_blank" rel="noopener">Netflix JavaScript Talks - RxJS Version 5</a><br>
<a href="https://www.youtube.com/watch?v=3LKMwkuK0ZE" target="_blank" rel="noopener">RxJS 5 Thinking Reactively | Ben Lesh</a></p>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Front-end/">#Front-end</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2018/01/15/react-performance-immutable-and-scu/">React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2017/10/04/payment-request-api/">統一網頁支付介面：Payment Request API</a>
            
        </span>
    </div>
    
</article>


<div class="sharebox">
    
<div class="sharethis-inline-share-buttons"></div>
<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5d8b39b069ba670012bf92b9&amp;product=inline-share-buttons" async="async"></script>

</div>



<div class="comments">
    <h3 class="title is-4">評論</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'https://blog.huli.tw/2017/12/08/introduction-to-rxjs-observable/';
        this.page.identifier = '2017/12/08/introduction-to-rxjs-observable/';
        
        this.language = 'en';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'huli' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Huli&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-tw");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站內搜尋">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '頁面',
                CATEGORIES: '分類',
                TAGS: '標籤',
                UNTITLED: '(無標題)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>