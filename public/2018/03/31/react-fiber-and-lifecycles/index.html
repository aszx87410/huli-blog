<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>淺談 React Fiber 及其對 lifecycles 造成的影響 - Huli</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content>





    <meta name="description" content="前言 雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fibe">
<meta name="keywords" content="Front-end,React">
<meta property="og:type" content="article">
<meta property="og:title" content="淺談 React Fiber 及其對 lifecycles 造成的影響">
<meta property="og:url" content="https://blog.huli.tw/2018/03/31/react-fiber-and-lifecycles/index.html">
<meta property="og:site_name" content="Huli">
<meta property="og:description" content="前言 雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fibe">
<meta property="og:locale" content="zh-tw">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351561-fea9f280-f6ee-11e8-834a-89bd7937b17f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351564-02d61000-f6ef-11e8-8b36-6323ed4d7620.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351571-06699700-f6ef-11e8-916a-a100a6c17974.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/2755720/49351577-09fd1e00-f6ef-11e8-8cc5-9e0f849ad52a.png">
<meta property="og:updated_time" content="2019-09-25T11:43:55.584Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="淺談 React Fiber 及其對 lifecycles 造成的影響">
<meta name="twitter:description" content="前言 雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fibe">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/2755720/49351561-fea9f280-f6ee-11e8-834a-89bd7937b17f.png">





<link rel="icon" href="/img/lidemy_logo.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

<link rel="stylesheet" href="/css/style.css">

<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-49773306-3"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-49773306-3');
</script>


    


</head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    Huli
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item " href="/archives">文章列表</a>
            
            <a class="navbar-item " href="/categories">分類</a>
            
            <a class="navbar-item " href="/recommend">推薦閱讀</a>
            
            <a class="navbar-item " href="/about">關於我</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜尋" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" target="_blank" title="Medium" href="https://medium.com/@hulitw">
                
                <i class="fab fa-medium"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="Twitter" href="https://twitter.com/aszx87410">
                
                <i class="fab fa-twitter"></i>
                
            </a>
               
            <a class="navbar-item" target="_blank" title="Facebook" href="https://www.facebook.com/profile.php?id=100000221410594">
                
                <i class="fab fa-facebook"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            淺談 React Fiber 及其對 lifecycles 造成的影響
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2018-03-31T20:10:00.000Z" itemprop="datePublished">2018年3月31日(1 年前)</time>
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/React/">React</a>
        </span>
        
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <h1><span id="前言">前言</span></h1>
<p>雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。</p>
<p>真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。</p>
<p>這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber 底層的運作（因為我也還沒認真研究過），只會用白話文跟你說 Fiber 大概是怎樣，是為了解決什麼樣子的問題而誕生。</p>
<a id="more"></a>
<h1><span id="萬里之行始於-bug">萬里之行，始於 Bug</span></h1>
<p>每一次能踩到 Bug 的機會，我都會好好把握。</p>
<p>為什麼？因為這是一次強迫你學習的機會。Bug 解不掉，你就沒辦法繼續下去，所以為了要解決 Bug，你必須去探究原因，必須知道這個問題為什麼產生，以及應該要怎麼解決。</p>
<p>當然，你也可以直接從 Stack Overflow 找答案然後複製貼上，覆蓋這張牌結束這回合。可是工作久了你會發現，不是所有問題都可以從那上面找到解答。</p>
<p>舉例來說，我一年前寫的<a href="https://blog.techbridge.cc/2017/03/24/difficult-problem-of-cookie/" target="_blank" rel="noopener">我遇過的最難的 Cookie 問題</a>對我來說就是一個很好的學習機會。</p>
<p>好，那這次我又是遇到什麼 Bug 呢？</p>
<p>我們公司的產品有用到redux-form，而問題是這樣的，我有兩個頁面，都用了同一個 component，叫做<code>FormBlock</code>好了。</p>
<p>我先去 A 頁面，再去 B 頁面，再回來 A 頁面，我的 redux-form 的 validation 就失效了，在表單 submit 的時候並不會執行 validation。</p>
<p>那時候搜到了幾個相關的 issue，但還是想自己查個清楚，就跑去找了 redux-form 的原始碼，研究了幾個小時終於找到出問題的地方。</p>
<p>在 redux-form <a href="https://github.com/erikras/redux-form/blob/5c13be079476cb0d0430ca88fd3e1abbd09e674a/src/selectors/isValid.js#L37" target="_blank" rel="noopener">執行 validation</a> 的時候，會先檢查 fields 是不是有被註冊過，如果沒被註冊的話，就直接回傳<code>true</code>，不會進行任何驗證，我自己加了幾個 console.log 之後，發現問題就是出在這邊，field 沒有被註冊到。</p>
<p>接著就來找一下是在哪邊註冊的，發現在<code>componentWillMount</code>的時候，會 dispatch 一個 action 來註冊所有的表單欄位（<code>REGISTER_FIELD</code>）。</p>
<p>然後在<code>componentWillUnmount</code>的時候，redux-form 會 dispatch 一個 action 叫做<code>DESTROY</code>（<a href="https://github.com/erikras/redux-form/blob/5c13be079476cb0d0430ca88fd3e1abbd09e674a/src/createReduxForm.js#L556" target="_blank" rel="noopener">相關程式碼</a>），把所有註冊的 field 給清掉。</p>
<p>到目前為止，一切看似都很合理。我在離開 B 頁面的時候，觸發<code>FormBlock</code>的<code>componentWillUnmount</code>，取消註冊所有的 field，在進入 A 頁面時，觸發<code>FormBlock</code>的<code>componentWillMount</code>，把所有的 field 重新註冊回來。</p>
<p>可是如果你打開 redux-devtool，會發現順序跟你想像中不太一樣：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351561-fea9f280-f6ee-11e8-834a-89bd7937b17f.png" alt="form"></p>
<p>咦？怎麼會先註冊再刪除？而且因為刪除了，所以驗證就失效了，不會執行任何驗證的邏輯。</p>
<p>再仔細找了一下相關的資料，看到這篇 <a href="https://github.com/facebook/react/issues/9214#issuecomment-287763538" target="_blank" rel="noopener">Browser back button not working with react-router@4.0.0-beta.7 and react@16-alpha.4</a> Issue 以及 Redux 以及 React 的開發者 gaearon 在下面的回答：</p>
<blockquote>
<p>In React 15, if A is replaced by B, we unmount A, and then create and mount B:</p>
</blockquote>
<blockquote>
<ol>
<li>A.componentWillUnmount</li>
<li>B.constructor</li>
<li>B.componentWillMount</li>
<li>B.componentDidMount</li>
</ol>
</blockquote>
<blockquote>
<p>In Fiber, we create B first, and only later unmount A and mount B:</p>
</blockquote>
<blockquote>
<ol>
<li>B.constructor</li>
<li>B.componentWillMount</li>
<li>A.componentWillUnmount</li>
<li>B.componentDidMount</li>
</ol>
</blockquote>
<p>在 React 16 以後，由於這樣子的順序改變，導致了上面 redux-form 的 lifecycle 執行順序跟預期中不符，也間接導致了我開頭所說的那個 Bug。</p>
<p>到了這邊，問題產生的原因一路從 redux-form 本身追到了 React，又更細節的追到了 Fiber，看來，沒辦法再繼續逃避 Fiber 了。</p>
<p>先一併奉上跟 redux-form 以及執行順序相關的其他參考資料，再讓我們好好看看 Fiber。</p>
<ol>
<li><a href="https://github.com/erikras/redux-form/issues/3566" target="_blank" rel="noopener">Re-mounting a Field component erases the field-level validation function</a></li>
<li><a href="https://github.com/facebook/react/issues/12233" target="_blank" rel="noopener">Ordering of componentWillMount/Unmount in React 16</a></li>
<li><a href="https://github.com/facebook/react/issues/11106" target="_blank" rel="noopener">Asynchronous ComponentWillUnmount in React 16</a></li>
</ol>
<h1><span id="fiber-到底是什麼">Fiber 到底是什麼？</span></h1>
<p>要瞭解一個新的東西，最快的方式就是回答以下問題：</p>
<ol>
<li>它是拿來解決什麼問題的？</li>
<li>解決方法是什麼？</li>
</ol>
<p>只要能了解這兩個問題，就能對這個新的東西有初步的概念，儘管你還是不知道實作細節，但至少你知道它帶來的影響及改變是什麼。</p>
<p>我們先來看一下一直存在於 React 的一個問題。</p>
<p>假設你現在有一個超級多功能的 App，有著超級多的 Component，然後你改變了最上層的 Component（假設它叫<code>&lt;App /&gt;</code>） 的 state。</p>
<p>因為 state 變了，所以就會來執行這個<code>&lt;App /&gt;</code>的 render function，然後執行<code>App</code>底下的 component 的 render function，就這樣一直往下執行下去，直到碰到最底層為止。</p>
<p>你如果去看 call stack，就會發現這個 call stack 超大一個：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351564-02d61000-f6ef-11e8-8b36-6323ed4d7620.png" alt="call"></p>
<p>（圖片來源：<a href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/" target="_blank" rel="noopener">React Fiber現状確認</a>）</p>
<p>這樣會造成什麼問題呢？因為你的 call stack 太深而且東西太多，再加上這個過程又是不能被中斷的，會導致 main thread 被 block 住，在這時間之內你做任何事情，瀏覽器都不會有反應。</p>
<p>簡單來說呢，就是因為要做的事太多，所以 main thread 就會 block 住了，這就是 React 在效能上會碰到的一個問題。</p>
<p>到這邊，我們已經回答第一個問題了，Fiber 就是為了解決這個問題而產生的解法。接著我們來回答第二個問題：解決方法是什麼？</p>
<blockquote>
<p>既然問題的成因是：「要做的事情太多又不能中斷」，那我們只要發明一個「可以中斷」的機制就好啦！不要一次全部更新，而是增量更新（incremental rendering），就可以解決這個問題了！</p>
</blockquote>
<p>比起原本的一次性更新，假如我們能夠把要更新的工作切成一個個小的工作，每次只執行一個小工作，那這樣 main thread 就不會被 block 住了，因為每個小工作之間都可以有空檔去做別的事情（響應使用者的點擊、繪製新的畫面等等）。</p>
<p>就像下面這張示意圖一樣，每次完成一點點的工作，而不是一次完成全部的：</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351571-06699700-f6ef-11e8-916a-a100a6c17974.png" alt="cartoon"></p>
<p>（圖片來源：<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017<br>
</a>）</p>
<p>好了，你已經知道什麼是 Fiber 了，這就是 Fiber。每一個小工作就叫做 Fiber，而 Fiber 在英文裡面是纖維的意思，所以又有人把這個機制稱作「纖程」。</p>
<p>或是換個角度想，原本的問題是因為程式裡面這樣子一層層執行 render function 的方法是透過 call stack，每次 call 一個 function 就把一個新的任務丟到 stack frame 去，可是這樣子的機制會導致任務無法中斷。</p>
<p>於是 Fiber 就實作出了 virtual stack frame，簡單來說就是自己用 js 再模擬出一個 call stack 的感覺，但好處就是自己有完全的掌控權，而不是被 js 的運行機制給綁住。</p>
<p>再幫大家重新整理一次，沒有 Fiber 之前，你要更新的時候都是「一次性」的更新，中間無法中斷，導致 main thread 在這期間會被 block 住。</p>
<p>有了 Fiber 這個機制之後，我們把一個大更新切成很多塊小的更新，每次只更新一點點，這樣子在更新的空檔 main thread 就能去做其他事情，而不會被綁住。</p>
<p>聽起來十分美好，問題迎刃而解，可是副作用是什麼呢？</p>
<h2><span id="fiber-所帶來的改變">Fiber 所帶來的改變</span></h2>
<p>把核心換成 Fiber 之後，是要付出一些代價的。在 Fiber 裡面的工作其實分成兩個階段：</p>
<ol>
<li>render/reconciliation</li>
<li>commit</li>
</ol>
<p>簡單來說呢，第一階段就是找出需要改變的部分，而第二階段是真正的把這些改變應用到 DOM 上面去。第一階段是可以被中斷，也可以被重新執行的，而第二階段跟以前一樣，必須一口氣做完。</p>
<p>而這兩個階段也對應到不同的生命週期：</p>
<h3><span id="第一階段">第一階段</span></h3>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
</ul>
<h3><span id="第二階段">第二階段</span></h3>
<ul>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
</ul>
<p>因為第一階段是可以中斷並且之後再重新執行的，所以會導致在第一階段裡的這些函數，有可能被 call 很多次。</p>
<p><img src="https://user-images.githubusercontent.com/2755720/49351577-09fd1e00-f6ef-11e8-8cc5-9e0f849ad52a.png" alt="life"></p>
<p>（圖片來源：<a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017<br>
</a>）</p>
<p>所以，假設你之前習慣在<code>componentWillMount</code>裡面就呼叫 API 拿資料的話，就會導致你 call 了不只一次的 API，會浪費一些頻寬，要改變的話就要把這些 code 移到<code>componentDidMount</code>去，就只會保證被 call 一次而已。</p>
<p>總之呢，自從內部機制改成 Fiber 之後（從 React 16 開始，所以如果你是用 16 以上的版本，已經是 Fiber 了），React 的生命週期函數被呼叫的次數跟方式會跟以前不太一樣。</p>
<p>除此之外就是我開頭提的那個順序的不一樣，這點也是值得注意的一個部分。雖然看起來不是什麼大問題，但如果不知道這點的話可能會生出一些莫名其妙的 Bug。</p>
<h2><span id="react-的未來">React 的未來</span></h2>
<p>React 16.3 在昨天<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" target="_blank" rel="noopener">正式發佈</a>了，伴隨而來的是正式的 context API 以及 lifecycle 的改變。</p>
<p>隨著 Fiber 的正式上線，未來可以期待會有更多令人興奮的新功能。比如說在<a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html" target="_blank" rel="noopener">Sneak Peek: Beyond React 16</a>這篇提到的<code>time slicing</code>，把整個 App 的體驗變得更順暢。</p>
<p>而<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">Update on Async Rendering</a>這篇文章也提到了非同步渲染的進展。</p>
<p>自從內部的機制改成 Fiber 之後，就讓 async rendering 得以發揮最大的效能。</p>
<p>但為了 async rendering，是需要付出一些代價的。原本的 lifecycle API 在這種場景底下可能會有一些問題，官方有給出許多常見的例子，也包含我們上面所說到的，<code>componentWillMount</code>會被呼叫多次的問題：</p>
<p>（忽略原本的範例程式碼，但大意就是在<code>componentWillMount</code>裡面 call API）</p>
<blockquote>
<p>The above code is problematic for both server rendering (where the external data won’t be used) and the upcoming async rendering mode (where the request might be initiated multiple times).</p>
</blockquote>
<blockquote>
<p>The recommended upgrade path for most use cases is to move data-fetching into componentDidMount</p>
</blockquote>
<p>對於 async rendering，會引起問題的是以下三個生命週期：</p>
<ol>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ol>
<p>這三個 lifecycle 會在 React 17 裡面被拿掉（如果你還是想用的話可以加上<code>UNSAFE_</code>，例如說改成<code>UNSAFE_componentWillMount</code>就一樣可以用），但既然都說是 UNSAFE 了，沒有理由繼續使用下去。</p>
<p>舊的不去新的不來，在最新發佈的 16.3 中，引入了兩個新的 lifecycle 來解決上面的那些問題：</p>
<ol>
<li>getDerivedStateFromProps</li>
<li>getSnapshotBeforeUpdate</li>
</ol>
<p>第一個很顯然是要來取代<code>componentWillReceiveProps</code>的，而第二個是拿來取代<code>componentWillUpdate</code>的。或其實有些場景底下，用<code>componentDidUpdate</code>也可以取代原本那兩個生命週期。</p>
<p>至於最前面所提到的<code>componentWillMount</code>，則建議把裡面的程式碼搬到<code>componentDidMount</code>去。</p>
<p>接著讓我們快速來看一下新的生命週期如何替代舊的，以下我就直接使用官方給的範例了。這個範例會偵測 props 來決定要不要改變 state，是很常見的應用場景：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Before</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="hljs-literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.currentRow !== nextProps.currentRow) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.setState(&#123;</span><br><span class="line">        isScrollingDown:</span><br><span class="line">          nextProps.currentRow &gt; <span class="hljs-keyword">this</span>.props.currentRow,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而新的生命週期<code>static getDerivedStateFromProps</code>，會在 component 被建立還有收到新的 props 的時候被呼叫，但只會傳入新的 props 跟舊的 state，因此我們可以這樣改：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// After</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 初始化 state</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="hljs-literal">false</span>,</span><br><span class="line">    lastRow: <span class="hljs-literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="hljs-comment">// 把新的 props 跟舊的 state 做比較</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (nextProps.currentRow !== prevState.lastRow) &#123;</span><br><span class="line">      <span class="hljs-comment">// 回傳新的 state</span></span><br><span class="line">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">        isScrollingDown: nextProps.currentRow &gt; prevState.lastRow,</span><br><span class="line">        lastRow: nextProps.currentRow, <span class="hljs-comment">// 同步一下 state</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-comment">// return null 代表不用改變 state</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其實說穿了就只是你自己把以前<code>componentWillReceiveProps</code>會傳來的<code>prevProps</code>存到 state 裡面，改成跟 state 來比較而已。</p>
<p>看到這邊你可能會很疑惑：「那為什麼 getDerivedStateFromProps 不直接把 prevProps 傳進來就好？」</p>
<p>React 官方給的理由有兩個：</p>
<ol>
<li>因為 getDerivedStateFromProps 在初始化的時候也會被 call，所以第一次的 prevProps 會是 null，代表你每次都要做一次 null check，這樣不好</li>
<li>不傳 prevProps 就代表 React 不用幫你記住 prevProps 了，對未來在記憶體上面的優化有幫助</li>
</ol>
<p>總之呢，以後就不會有<code>componentWillReceiveProps</code>可以用了，你要自己把需要的<code>prevProps</code>保存在 state 裡面，並且在<code>getDerivedStateFromProps</code>裡面進行比較。</p>
<p>再看另外一個例子，這個例子的目的是要在新增 item 的時候維持捲軸的位置，所以必須在 update 之前保存舊的高度，在 update 之後去調整捲軸的位置：</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  listRef = <span class="hljs-literal">null</span>;</span><br><span class="line">  previousScrollHeight = <span class="hljs-literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="hljs-comment">// 有新增 item 的話，記住現在的高度</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.list.length &lt; nextProps.list.length) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.previousScrollHeight = <span class="hljs-keyword">this</span>.listRef.scrollHeight;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="hljs-comment">// 如果 previousScrollHeight 不是 null，代表有新增 item</span></span><br><span class="line">    <span class="hljs-comment">// 調整捲軸位置</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.previousScrollHeight !== <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.listRef.scrollTop += <span class="hljs-keyword">this</span>.listRef.scrollHeight - <span class="hljs-keyword">this</span>.previousScrollHeight;</span><br><span class="line">      <span class="hljs-keyword">this</span>.previousScrollHeight = <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="hljs-keyword">this</span>.setListRef&#125;&gt;</span><br><span class="line">        &#123;<span class="hljs-comment">/* ...contents... */</span>&#125;</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">  </span></span><br><span class="line"><span class="hljs-regexp">  setListRef = ref =&gt; &#123;</span></span><br><span class="line"><span class="hljs-regexp">    this.listRef = ref;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>那這樣子會帶來的問題是什麼呢？還記得我們前面有提過 Fiber 有兩個階段嗎？render 跟 commit。這兩個階段會有時間差，而<code>componentWillUpdate</code>是處於第一個階段，<code>componentDidUpdate</code>是屬於第二個階段。</p>
<p>假如使用者在這兩個階段之間做了一些事情，例如說調整視窗的尺寸，那你存的高度就不會是正確的了，而是會拿到舊的值。</p>
<p>解決方法就是利用新的生命週期<code>getSnapshotBeforeUpdate</code>，這個會在 DOM 被更新之前呼叫，可以保證你拿到的東西一定是最新的。</p>
<p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  listRef = <span class="hljs-literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="hljs-comment">// 如果 list 有變動，就回傳現在的捲軸高度</span></span><br><span class="line">    <span class="hljs-comment">// 這個回傳值會被當作 componentDidUpdate 的第三個參數</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (prevProps.list.length &lt; <span class="hljs-keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listRef.scrollHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="hljs-comment">// snapshot 就是上面回傳的那個值</span></span><br><span class="line">    <span class="hljs-comment">// 如果不是 null，就利用 snapshot 來調整捲軸高度</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (snapshot !== <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.listRef.scrollTop +=</span><br><span class="line">        <span class="hljs-keyword">this</span>.listRef.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="hljs-keyword">this</span>.setListRef&#125;&gt;</span><br><span class="line">        &#123;<span class="hljs-comment">/* ...contents... */</span>&#125;</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">  </span></span><br><span class="line"><span class="hljs-regexp">  setListRef = ref =&gt; &#123;</span></span><br><span class="line"><span class="hljs-regexp">    this.listRef = ref;</span></span><br><span class="line"><span class="hljs-regexp">  &#125;;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>總之呢，結合搭配使用 commit phase 的 lifecycle（<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>）以及新引進的<code>getDerivedStateFromProps</code>與<code>getSnapshotBeforeUpdate</code>，就可以取代掉舊的那些有可能會造成問題的 lifecycle。</p>
<p>如果想要看更多範例的話，這篇很值得參考：<a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html" target="_blank" rel="noopener">Update on Async Rendering</a>。</p>
<h2><span id="結論">結論</span></h2>
<p>效能一直是 Web App 很注重的一個點，而需要把握的原則就只有一個：不要 block main thread。只要 main thread 可以做事，它就可以去處理其他事情，例如說響應使用者的 click 或是繪製新的畫面等等。</p>
<p>而 React 原本的機制會造成問題，因此將內部核心用 Fiber 改寫，把一大個不可中斷的任務切割成許多小的、可以中斷的工作，而可以切割之後也使得以後有平行化的可能，render 的速度可能又會更快一點。</p>
<p>但也因為這樣機制的改變，影響到原本的生命週期，一個不小心就會出狀況，而官方也發布了新的兩個生命週期來解決這個問題。</p>
<p>身為 React 長期的使用者，對這種大的改變雖然覺得要改 code 很煩，但長期來看其實是利多，畢竟可以做的事情又更多了，效能也會愈來愈好。</p>
<p>這篇總結了近期我研究 Fiber 跟關注 React 新的變化的一些心得，Fiber 底層的實作機制因為我也不是很理解，所以不敢出來班門弄斧，只希望能透過白話文讓大家理解這個機制大概是長怎樣。</p>
<p>如果有哪邊有講錯，還麻煩不吝指正，感謝。</p>
<p>參考資料：</p>
<ol>
<li><a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noopener">React Fiber Architecture</a></li>
<li><a href="https://giamir.com/what-is-react-fiber" target="_blank" rel="noopener">What is React Fiber ?</a></li>
<li><a href="https://github.com/xieyu/blog/blob/master/React/from-jsx-to-dom.md" target="_blank" rel="noopener">React中state render到html dom的流程分析</a></li>
<li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">完全理解React Fiber</a></li>
<li><a href="https://medium.com/@_cybai/%E7%BF%BB%E8%AD%AF-react-fiber-%E7%8F%BE%E7%8B%80%E7%A2%BA%E8%AA%8D-fd3808072279" target="_blank" rel="noopener">[翻譯] React Fiber 現狀確認</a></li>
<li><a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" target="_blank" rel="noopener">React v16.3.0: New lifecycles and context API</a></li>
<li><a href="https://reactjs.org/docs/design-principles.html#scheduling" target="_blank" rel="noopener">React Docs - Scheduling</a></li>
<li><a href="https://tech.youzan.com/react-fiber/" target="_blank" rel="noopener">浅谈React 16中的Fiber机制</a></li>
<li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs" target="_blank" rel="noopener">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li>
</ol>

    
    </div>
    
    <div class="columns is-variable is-1 is-multiline is-mobile">
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/Front-end/">#Front-end</a></span>
    
        <span class="column is-narrow"><a class="tag is-light article-tag" href="/tags/React/">#React</a></span>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop  article-nav-prev">
            
            <a href="/2018/06/23/javascript-call-by-value-or-reference/">深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？</a>
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2018/03/12/css-keylogger/">CSS keylogger：攻擊與防禦</a>
            
        </span>
    </div>
    
</article>


<div class="sharebox">
    
<div class="sharethis-inline-share-buttons"></div>
<script type="text/javascript" src="https://platform-api.sharethis.com/js/sharethis.js#property=5d8b39b069ba670012bf92b9&amp;product=inline-share-buttons" async="async"></script>

</div>



<div class="comments">
    <h3 class="title is-4">評論</h3>
    
<script>
    var disqus_config = function () {
        this.page.url = 'https://blog.huli.tw/2018/03/31/react-fiber-and-lifecycles/';
        this.page.identifier = '2018/03/31/react-fiber-and-lifecycles/';
        
        this.language = 'en';
        
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'huli' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>

    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2019 Huli&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-tw");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    


<script src="/js/script.js"></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站內搜尋">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '頁面',
                CATEGORIES: '分類',
                TAGS: '標籤',
                UNTITLED: '(無標題)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js"></script>
    
</body>
</html>